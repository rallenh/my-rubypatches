diff -Nuarp ruby-2.7.8.a/abrt.c ruby-2.7.8.b/abrt.c
--- ruby-2.7.8.a/abrt.c	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.8.b/abrt.c	2023-05-20 18:17:27.029200688 -0400
@@ -0,0 +1,12 @@
+#include "internal.h"
+
+void
+Init_abrt(void)
+{
+  rb_eval_string(
+    "  begin\n"
+    "    require 'abrt'\n"
+    "  rescue LoadError\n"
+    "  end\n"
+  );
+}
diff -Nuarp ruby-2.7.8.a/addr2line.c ruby-2.7.8.b/addr2line.c
--- ruby-2.7.8.a/addr2line.c	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/addr2line.c	2023-05-20 18:17:41.788381473 -0400
@@ -163,11 +163,12 @@ typedef struct obj_info {
     struct dwarf_section debug_info;
     struct dwarf_section debug_line;
     struct dwarf_section debug_ranges;
+    struct dwarf_section debug_rnglists;
     struct dwarf_section debug_str;
     struct obj_info *next;
 } obj_info_t;
 
-#define DWARF_SECTION_COUNT 5
+#define DWARF_SECTION_COUNT 6
 
 static struct dwarf_section *
 obj_dwarf_section_at(obj_info_t *obj, int n)
@@ -177,6 +178,7 @@ obj_dwarf_section_at(obj_info_t *obj, in
         &obj->debug_info,
         &obj->debug_line,
         &obj->debug_ranges,
+        &obj->debug_rnglists,
         &obj->debug_str
     };
     if (n < 0 || DWARF_SECTION_COUNT <= n) {
@@ -415,7 +417,7 @@ parse_debug_line_cu(int num_traces, void
 	    FILL_LINE();
 	    break;
 	case DW_LNS_advance_pc:
-	    a = uleb128((char **)&p);
+	    a = uleb128((char **)&p) * header.minimum_instruction_length;
 	    addr += a;
 	    break;
 	case DW_LNS_advance_line: {
@@ -454,7 +456,7 @@ parse_debug_line_cu(int num_traces, void
 	    /* isa = (unsigned int)*/(void)uleb128((char **)&p);
 	    break;
 	case 0:
-	    a = *(unsigned char *)p++;
+	    a = uleb128((char **)&p);
 	    op = *p++;
 	    switch (op) {
 	    case DW_LNE_end_sequence:
@@ -768,6 +770,18 @@ enum
     DW_FORM_addrx4 = 0x2c
 };
 
+/* Range list entry encodings */
+enum {
+    DW_RLE_end_of_list = 0x00,
+    DW_RLE_base_addressx = 0x01,
+    DW_RLE_startx_endx = 0x02,
+    DW_RLE_startx_length = 0x03,
+    DW_RLE_offset_pair = 0x04,
+    DW_RLE_base_address = 0x05,
+    DW_RLE_start_end = 0x06,
+    DW_RLE_start_length = 0x07
+};
+
 enum {
     VAL_none = 0,
     VAL_cstr = 1,
@@ -921,6 +935,23 @@ debug_info_reader_init(DebugInfoReader *
 }
 
 static void
+di_skip_die_attributes(char **p)
+{
+    for (;;) {
+        uint64_t at = uleb128(p);
+        uint64_t form = uleb128(p);
+        if (!at && !form) break;
+        switch (form) {
+          default:
+            break;
+          case DW_FORM_implicit_const:
+            sleb128(p);
+            break;
+        }
+    }
+}
+
+static void
 di_read_debug_abbrev_cu(DebugInfoReader *reader)
 {
     uint64_t prev = 0;
@@ -934,12 +965,7 @@ di_read_debug_abbrev_cu(DebugInfoReader
         prev = abbrev_number;
         uleb128(&p); /* tag */
         p++; /* has_children */
-        /* skip content */
-        for (;;) {
-            uint64_t at = uleb128(&p);
-            uint64_t form = uleb128(&p);
-            if (!at && !form) break;
-        }
+        di_skip_die_attributes(&p);
     }
 }
 
@@ -1203,12 +1229,7 @@ di_find_abbrev(DebugInfoReader *reader,
     /* skip 255th record */
     uleb128(&p); /* tag */
     p++; /* has_children */
-    /* skip content */
-    for (;;) {
-        uint64_t at = uleb128(&p);
-        uint64_t form = uleb128(&p);
-        if (!at && !form) break;
-    }
+    di_skip_die_attributes(&p);
     for (uint64_t n = uleb128(&p); abbrev_number != n; n = uleb128(&p)) {
         if (n == 0) {
             fprintf(stderr,"%d: Abbrev Number %"PRId64" not found\n",__LINE__, abbrev_number);
@@ -1216,12 +1237,7 @@ di_find_abbrev(DebugInfoReader *reader,
         }
         uleb128(&p); /* tag */
         p++; /* has_children */
-        /* skip content */
-        for (;;) {
-            uint64_t at = uleb128(&p);
-            uint64_t form = uleb128(&p);
-            if (!at && !form) break;
-        }
+        di_skip_die_attributes(&p);
     }
     return p;
 }
@@ -1349,6 +1365,21 @@ ranges_set(ranges_t *ptr, DebugInfoValue
     }
 }
 
+static uint64_t
+read_dw_form_addr(DebugInfoReader *reader, char **ptr)
+{
+    char *p = *ptr;
+    *ptr = p + reader->format;
+    if (reader->format == 4) {
+        return read_uint32(&p);
+    } else if (reader->format == 8) {
+        return read_uint64(&p);
+    } else {
+        fprintf(stderr,"unknown address_size:%d", reader->address_size);
+        abort();
+    }
+}
+
 static uintptr_t
 ranges_include(DebugInfoReader *reader, ranges_t *ptr, uint64_t addr)
 {
@@ -1362,8 +1393,50 @@ ranges_include(DebugInfoReader *reader,
     }
     else if (ptr->ranges_set) {
         /* TODO: support base address selection entry */
-        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        char *p;
         uint64_t base = ptr->low_pc_set ? ptr->low_pc : reader->current_low_pc;
+        if (reader->obj->debug_rnglists.ptr) {
+            p = reader->obj->debug_rnglists.ptr + ptr->ranges;
+            for (;;) {
+                uint8_t rle = read_uint8(&p);
+                uintptr_t base_address = 0;
+                uintptr_t from, to;
+                if (rle == DW_RLE_end_of_list) break;
+                switch (rle) {
+                  case DW_RLE_base_addressx:
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_startx_endx:
+                    uleb128(&p);
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_startx_length:
+                    uleb128(&p);
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_offset_pair:
+                    from = base_address + uleb128(&p);
+                    to = base_address + uleb128(&p);
+                    if (base + from <= addr && addr < base + to) {
+                        return from;
+                    }
+                    break;
+                  case DW_RLE_base_address:
+                    base_address = read_dw_form_addr(reader, &p);
+                    break;
+                  case DW_RLE_start_end:
+                    read_dw_form_addr(reader, &p);
+                    read_dw_form_addr(reader, &p);
+                    break;
+                  case DW_RLE_start_length:
+                    read_dw_form_addr(reader, &p);
+                    uleb128(&p);
+                    break;
+                }
+            }
+            return false;
+        }
+        p = reader->obj->debug_ranges.ptr + ptr->ranges;
         for (;;) {
             uintptr_t from = read_uintptr(&p);
             uintptr_t to = read_uintptr(&p);
@@ -1703,6 +1776,7 @@ fill_lines(int num_traces, void **traces
                     ".debug_info",
                     ".debug_line",
                     ".debug_ranges",
+                    ".debug_rnglists",
                     ".debug_str"
                 };
 
@@ -1952,6 +2026,7 @@ found_mach_header:
                     "__debug_info",
                     "__debug_line",
                     "__debug_ranges",
+                    "__debug_rnglists",
                     "__debug_str"
                 };
                 struct LP(segment_command) *scmd = (struct LP(segment_command) *)lcmd;
diff -Nuarp ruby-2.7.8.a/addr2line.c.orig ruby-2.7.8.b/addr2line.c.orig
--- ruby-2.7.8.a/addr2line.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.8.b/addr2line.c.orig	2023-05-20 18:16:53.031784259 -0400
@@ -0,0 +1,2665 @@
+/**********************************************************************
+
+  addr2line.c -
+
+  $Author$
+
+  Copyright (C) 2010 Shinichiro Hamaji
+
+**********************************************************************/
+
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wgnu-empty-initializer"
+#pragma clang diagnostic ignored "-Wgcc-compat"
+#endif
+
+#include "ruby/config.h"
+#include "ruby/defines.h"
+#include "ruby/missing.h"
+#include "addr2line.h"
+
+#include <stdio.h>
+#include <errno.h>
+
+#ifdef HAVE_LIBPROC_H
+#include <libproc.h>
+#endif
+
+#ifdef HAVE_STDBOOL_H
+#include <stdbool.h>
+#else
+#include "missing/stdbool.h"
+#endif
+
+#if defined(USE_ELF) || defined(HAVE_MACH_O_LOADER_H)
+
+#include <fcntl.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+/* Make alloca work the best possible way.  */
+#ifdef __GNUC__
+# ifndef alloca
+#  define alloca __builtin_alloca
+# endif
+#else
+# ifdef HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+#pragma alloca
+#  else
+#   ifndef alloca		/* predefined by HP cc +Olibcalls */
+void *alloca();
+#   endif
+#  endif /* AIX */
+# endif	/* HAVE_ALLOCA_H */
+#endif /* __GNUC__ */
+
+#ifdef HAVE_DLADDR
+# include <dlfcn.h>
+#endif
+
+#ifdef HAVE_MACH_O_LOADER_H
+# include <crt_externs.h>
+# include <mach-o/fat.h>
+# include <mach-o/loader.h>
+# include <mach-o/nlist.h>
+# include <mach-o/stab.h>
+#endif
+
+#ifdef USE_ELF
+# ifdef __OpenBSD__
+#  include <elf_abi.h>
+# else
+#  include <elf.h>
+# endif
+
+#ifndef ElfW
+# if SIZEOF_VOIDP == 8
+#  define ElfW(x) Elf64##_##x
+# else
+#  define ElfW(x) Elf32##_##x
+# endif
+#endif
+#ifndef ELF_ST_TYPE
+# if SIZEOF_VOIDP == 8
+#  define ELF_ST_TYPE ELF64_ST_TYPE
+# else
+#  define ELF_ST_TYPE ELF32_ST_TYPE
+# endif
+#endif
+#endif
+
+#ifdef SHF_COMPRESSED
+# if defined(ELFCOMPRESS_ZLIB) && defined(HAVE_LIBZ)
+   /* FreeBSD 11.0 lacks ELFCOMPRESS_ZLIB */
+#  include <zlib.h>
+#  define SUPPORT_COMPRESSED_DEBUG_LINE
+# endif
+#else /* compatibility with glibc < 2.22 */
+# define SHF_COMPRESSED 0
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
+#define DW_LNS_copy                     0x01
+#define DW_LNS_advance_pc               0x02
+#define DW_LNS_advance_line             0x03
+#define DW_LNS_set_file                 0x04
+#define DW_LNS_set_column               0x05
+#define DW_LNS_negate_stmt              0x06
+#define DW_LNS_set_basic_block          0x07
+#define DW_LNS_const_add_pc             0x08
+#define DW_LNS_fixed_advance_pc         0x09
+#define DW_LNS_set_prologue_end         0x0a /* DWARF3 */
+#define DW_LNS_set_epilogue_begin       0x0b /* DWARF3 */
+#define DW_LNS_set_isa                  0x0c /* DWARF3 */
+
+/* Line number extended opcode name. */
+#define DW_LNE_end_sequence             0x01
+#define DW_LNE_set_address              0x02
+#define DW_LNE_define_file              0x03
+#define DW_LNE_set_discriminator        0x04  /* DWARF4 */
+
+PRINTF_ARGS(static int kprintf(const char *fmt, ...), 1, 2);
+
+typedef struct line_info {
+    const char *dirname;
+    const char *filename;
+    const char *path; /* object path */
+    int line;
+
+    uintptr_t base_addr;
+    uintptr_t saddr;
+    const char *sname; /* function name */
+
+    struct line_info *next;
+} line_info_t;
+
+struct dwarf_section {
+    char *ptr;
+    size_t size;
+    uint64_t flags;
+};
+
+typedef struct obj_info {
+    const char *path; /* object path */
+    char *mapped;
+    size_t mapped_size;
+    void *uncompressed;
+    uintptr_t base_addr;
+    uintptr_t vmaddr;
+    struct dwarf_section debug_abbrev;
+    struct dwarf_section debug_info;
+    struct dwarf_section debug_line;
+    struct dwarf_section debug_ranges;
+    struct dwarf_section debug_str;
+    struct obj_info *next;
+} obj_info_t;
+
+#define DWARF_SECTION_COUNT 5
+
+static struct dwarf_section *
+obj_dwarf_section_at(obj_info_t *obj, int n)
+{
+    struct dwarf_section *ary[] = {
+        &obj->debug_abbrev,
+        &obj->debug_info,
+        &obj->debug_line,
+        &obj->debug_ranges,
+        &obj->debug_str
+    };
+    if (n < 0 || DWARF_SECTION_COUNT <= n) {
+        abort();
+    }
+    return ary[n];
+}
+
+struct debug_section_definition {
+    const char *name;
+    struct dwarf_section *dwarf;
+};
+
+/* Avoid consuming stack as this module may be used from signal handler */
+static char binary_filename[PATH_MAX + 1];
+
+static unsigned long
+uleb128(char **p)
+{
+    unsigned long r = 0;
+    int s = 0;
+    for (;;) {
+	unsigned char b = *(unsigned char *)(*p)++;
+	if (b < 0x80) {
+	    r += (unsigned long)b << s;
+	    break;
+	}
+	r += (b & 0x7f) << s;
+	s += 7;
+    }
+    return r;
+}
+
+static long
+sleb128(char **p)
+{
+    long r = 0;
+    int s = 0;
+    for (;;) {
+	unsigned char b = *(unsigned char *)(*p)++;
+	if (b < 0x80) {
+	    if (b & 0x40) {
+		r -= (0x80 - b) << s;
+	    }
+	    else {
+		r += (b & 0x3f) << s;
+	    }
+	    break;
+	}
+	r += (b & 0x7f) << s;
+	s += 7;
+    }
+    return r;
+}
+
+static const char *
+get_nth_dirname(unsigned long dir, char *p)
+{
+    if (!dir--) {
+	return "";
+    }
+    while (dir--) {
+	while (*p) p++;
+	p++;
+	if (!*p) {
+	    kprintf("Unexpected directory number %lu in %s\n",
+		    dir, binary_filename);
+	    return "";
+	}
+    }
+    return p;
+}
+
+static void
+fill_filename(int file, char *include_directories, char *filenames, line_info_t *line, obj_info_t *obj)
+{
+    int i;
+    char *p = filenames;
+    char *filename;
+    unsigned long dir;
+    for (i = 1; i <= file; i++) {
+	filename = p;
+	if (!*p) {
+	    /* Need to output binary file name? */
+	    kprintf("Unexpected file number %d in %s at %tx\n",
+		    file, binary_filename, filenames - obj->mapped);
+	    return;
+	}
+	while (*p) p++;
+	p++;
+	dir = uleb128(&p);
+	/* last modified. */
+	uleb128(&p);
+	/* size of the file. */
+	uleb128(&p);
+
+	if (i == file) {
+	    line->filename = filename;
+	    line->dirname = get_nth_dirname(dir, include_directories);
+	}
+    }
+}
+
+static void
+fill_line(int num_traces, void **traces, uintptr_t addr, int file, int line,
+	  char *include_directories, char *filenames,
+	  obj_info_t *obj, line_info_t *lines, int offset)
+{
+    int i;
+    addr += obj->base_addr - obj->vmaddr;
+    for (i = offset; i < num_traces; i++) {
+	uintptr_t a = (uintptr_t)traces[i];
+	/* We assume one line code doesn't result >100 bytes of native code.
+       We may want more reliable way eventually... */
+	if (addr < a && a < addr + 100) {
+	    fill_filename(file, include_directories, filenames, &lines[i], obj);
+	    lines[i].line = line;
+	}
+    }
+}
+
+struct LineNumberProgramHeader {
+    uint64_t unit_length;
+    uint16_t version;
+    uint8_t format; /* 4 or 8 */
+    uint64_t header_length;
+    uint8_t minimum_instruction_length;
+    uint8_t maximum_operations_per_instruction;
+    uint8_t default_is_stmt;
+    int8_t line_base;
+    uint8_t line_range;
+    uint8_t opcode_base;
+    /* uint8_t standard_opcode_lengths[opcode_base-1]; */
+    const char *include_directories;
+    const char *filenames;
+    const char *cu_start;
+    const char *cu_end;
+};
+
+static int
+parse_debug_line_header(const char **pp, struct LineNumberProgramHeader *header)
+{
+    const char *p = *pp;
+    header->unit_length = *(uint32_t *)p;
+    p += sizeof(uint32_t);
+
+    header->format = 4;
+    if (header->unit_length == 0xffffffff) {
+	header->unit_length = *(uint64_t *)p;
+	p += sizeof(uint64_t);
+        header->format = 8;
+    }
+
+    header->cu_end = p + header->unit_length;
+
+    header->version = *(uint16_t *)p;
+    p += sizeof(uint16_t);
+    if (header->version > 4) return -1;
+
+    header->header_length = header->format == 4 ? *(uint32_t *)p : *(uint64_t *)p;
+    p += header->format;
+    header->cu_start = p + header->header_length;
+
+    header->minimum_instruction_length = *(uint8_t *)p++;
+
+    if (header->version >= 4) {
+        /* maximum_operations_per_instruction = *(uint8_t *)p; */
+        if (*p != 1) return -1; /* For non-VLIW architectures, this field is 1 */
+        p++;
+    }
+
+    header->default_is_stmt = *(uint8_t *)p++;
+    header->line_base = *(int8_t *)p++;
+    header->line_range = *(uint8_t *)p++;
+    header->opcode_base = *(uint8_t *)p++;
+    /* header->standard_opcode_lengths = (uint8_t *)p - 1; */
+    p += header->opcode_base - 1;
+
+    header->include_directories = p;
+
+    /* temporary measure for compress-debug-sections */
+    if (p >= header->cu_end) return -1;
+
+    /* skip include directories */
+    while (*p) {
+	p = memchr(p, '\0', header->cu_end - p);
+	if (!p) return -1;
+	p++;
+    }
+    p++;
+
+    header->filenames = p;
+
+    *pp = header->cu_start;
+
+    return 0;
+}
+
+static int
+parse_debug_line_cu(int num_traces, void **traces, char **debug_line,
+		obj_info_t *obj, line_info_t *lines, int offset)
+{
+    const char *p = (const char *)*debug_line;
+    struct LineNumberProgramHeader header;
+
+    /* The registers. */
+    unsigned long addr = 0;
+    unsigned int file = 1;
+    unsigned int line = 1;
+    /* unsigned int column = 0; */
+    int is_stmt;
+    /* int basic_block = 0; */
+    /* int end_sequence = 0; */
+    /* int prologue_end = 0; */
+    /* int epilogue_begin = 0; */
+    /* unsigned int isa = 0; */
+
+    if (parse_debug_line_header(&p, &header))
+        return -1;
+    is_stmt = header.default_is_stmt;
+
+#define FILL_LINE()						    \
+    do {							    \
+	fill_line(num_traces, traces, addr, file, line,		    \
+                  (char *)header.include_directories,               \
+                  (char *)header.filenames,                         \
+		  obj, lines, offset);				    \
+	/*basic_block = prologue_end = epilogue_begin = 0;*/	    \
+    } while (0)
+
+    while (p < header.cu_end) {
+	unsigned long a;
+	unsigned char op = *p++;
+	switch (op) {
+	case DW_LNS_copy:
+	    FILL_LINE();
+	    break;
+	case DW_LNS_advance_pc:
+	    a = uleb128((char **)&p);
+	    addr += a;
+	    break;
+	case DW_LNS_advance_line: {
+	    long a = sleb128((char **)&p);
+	    line += a;
+	    break;
+	}
+	case DW_LNS_set_file:
+	    file = (unsigned int)uleb128((char **)&p);
+	    break;
+	case DW_LNS_set_column:
+	    /*column = (unsigned int)*/(void)uleb128((char **)&p);
+	    break;
+	case DW_LNS_negate_stmt:
+	    is_stmt = !is_stmt;
+	    break;
+	case DW_LNS_set_basic_block:
+	    /*basic_block = 1; */
+	    break;
+	case DW_LNS_const_add_pc:
+	    a = ((255UL - header.opcode_base) / header.line_range) *
+		header.minimum_instruction_length;
+	    addr += a;
+	    break;
+	case DW_LNS_fixed_advance_pc:
+	    a = *(unsigned char *)p++;
+	    addr += a;
+	    break;
+	case DW_LNS_set_prologue_end:
+	    /* prologue_end = 1; */
+	    break;
+	case DW_LNS_set_epilogue_begin:
+	    /* epilogue_begin = 1; */
+	    break;
+	case DW_LNS_set_isa:
+	    /* isa = (unsigned int)*/(void)uleb128((char **)&p);
+	    break;
+	case 0:
+	    a = *(unsigned char *)p++;
+	    op = *p++;
+	    switch (op) {
+	    case DW_LNE_end_sequence:
+		/* end_sequence = 1; */
+		FILL_LINE();
+		addr = 0;
+		file = 1;
+		line = 1;
+		/* column = 0; */
+		is_stmt = header.default_is_stmt;
+		/* end_sequence = 0; */
+		/* isa = 0; */
+		break;
+	    case DW_LNE_set_address:
+		addr = *(unsigned long *)p;
+		p += sizeof(unsigned long);
+		break;
+	    case DW_LNE_define_file:
+		kprintf("Unsupported operation in %s\n",
+			binary_filename);
+		break;
+	    case DW_LNE_set_discriminator:
+		/* TODO:currently ignore */
+		uleb128((char **)&p);
+		break;
+	    default:
+		kprintf("Unknown extended opcode: %d in %s\n",
+			op, binary_filename);
+	    }
+	    break;
+	default: {
+            uint8_t adjusted_opcode = op - header.opcode_base;
+            uint8_t operation_advance = adjusted_opcode / header.line_range;
+            /* NOTE: this code doesn't support VLIW */
+            addr += operation_advance * header.minimum_instruction_length;
+            line += header.line_base + (adjusted_opcode % header.line_range);
+	    FILL_LINE();
+	}
+	}
+    }
+    *debug_line = (char *)p;
+    return 0;
+}
+
+static int
+parse_debug_line(int num_traces, void **traces,
+		 char *debug_line, unsigned long size,
+		 obj_info_t *obj, line_info_t *lines, int offset)
+{
+    char *debug_line_end = debug_line + size;
+    while (debug_line < debug_line_end) {
+	if (parse_debug_line_cu(num_traces, traces, &debug_line, obj, lines, offset))
+	    return -1;
+    }
+    if (debug_line != debug_line_end) {
+	kprintf("Unexpected size of .debug_line in %s\n",
+		binary_filename);
+    }
+    return 0;
+}
+
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+	   obj_info_t **objp, line_info_t *lines, int offset);
+
+static void
+append_obj(obj_info_t **objp)
+{
+    obj_info_t *newobj = calloc(1, sizeof(obj_info_t));
+    if (*objp) (*objp)->next = newobj;
+    *objp = newobj;
+}
+
+#ifdef USE_ELF
+static void
+follow_debuglink(const char *debuglink, int num_traces, void **traces,
+		 obj_info_t **objp, line_info_t *lines, int offset)
+{
+    /* Ideally we should check 4 paths to follow gnu_debuglink,
+       but we handle only one case for now as this format is used
+       by some linux distributions. See GDB's info for detail. */
+    static const char global_debug_dir[] = "/usr/lib/debug";
+    const size_t global_debug_dir_len = sizeof(global_debug_dir) - 1;
+    char *p;
+    obj_info_t *o1 = *objp, *o2;
+    size_t len;
+
+    p = strrchr(binary_filename, '/');
+    if (!p) {
+	return;
+    }
+    p[1] = '\0';
+
+    len = strlen(binary_filename);
+    if (len >= PATH_MAX - global_debug_dir_len)
+	len = PATH_MAX - global_debug_dir_len - 1;
+    memmove(binary_filename + global_debug_dir_len, binary_filename, len);
+    memcpy(binary_filename, global_debug_dir, global_debug_dir_len);
+    len += global_debug_dir_len;
+    strlcpy(binary_filename + len, debuglink, PATH_MAX - len);
+
+    append_obj(objp);
+    o2 = *objp;
+    o2->base_addr = o1->base_addr;
+    o2->path = o1->path;
+    fill_lines(num_traces, traces, 0, objp, lines, offset);
+}
+#endif
+
+enum
+{
+    DW_TAG_compile_unit = 0x11,
+    DW_TAG_inlined_subroutine = 0x1d,
+    DW_TAG_subprogram = 0x2e,
+};
+
+/* Attributes encodings */
+enum
+{
+    DW_AT_sibling = 0x01,
+    DW_AT_location = 0x02,
+    DW_AT_name = 0x03,
+    /* Reserved 0x04 */
+    /* Reserved 0x05 */
+    /* Reserved 0x06 */
+    /* Reserved 0x07 */
+    /* Reserved 0x08 */
+    DW_AT_ordering = 0x09,
+    /* Reserved 0x0a */
+    DW_AT_byte_size = 0x0b,
+    /* Reserved 0x0c */
+    DW_AT_bit_size = 0x0d,
+    /* Reserved 0x0e */
+    /* Reserved 0x0f */
+    DW_AT_stmt_list = 0x10,
+    DW_AT_low_pc = 0x11,
+    DW_AT_high_pc = 0x12,
+    DW_AT_language = 0x13,
+    /* Reserved 0x14 */
+    DW_AT_discr = 0x15,
+    DW_AT_discr_value = 0x16,
+    DW_AT_visibility = 0x17,
+    DW_AT_import = 0x18,
+    DW_AT_string_length = 0x19,
+    DW_AT_common_reference = 0x1a,
+    DW_AT_comp_dir = 0x1b,
+    DW_AT_const_value = 0x1c,
+    DW_AT_containing_type = 0x1d,
+    DW_AT_default_value = 0x1e,
+    /* Reserved 0x1f */
+    DW_AT_inline = 0x20,
+    DW_AT_is_optional = 0x21,
+    DW_AT_lower_bound = 0x22,
+    /* Reserved 0x23 */
+    /* Reserved 0x24 */
+    DW_AT_producer = 0x25,
+    /* Reserved 0x26 */
+    DW_AT_prototyped = 0x27,
+    /* Reserved 0x28 */
+    /* Reserved 0x29 */
+    DW_AT_return_addr = 0x2a,
+    /* Reserved 0x2b */
+    DW_AT_start_scope = 0x2c,
+    /* Reserved 0x2d */
+    DW_AT_bit_stride = 0x2e,
+    DW_AT_upper_bound = 0x2f,
+    /* Reserved 0x30 */
+    DW_AT_abstract_origin = 0x31,
+    DW_AT_accessibility = 0x32,
+    DW_AT_address_class = 0x33,
+    DW_AT_artificial = 0x34,
+    DW_AT_base_types = 0x35,
+    DW_AT_calling_convention = 0x36,
+    DW_AT_count = 0x37,
+    DW_AT_data_member_location = 0x38,
+    DW_AT_decl_column = 0x39,
+    DW_AT_decl_file = 0x3a,
+    DW_AT_decl_line = 0x3b,
+    DW_AT_declaration = 0x3c,
+    DW_AT_discr_list = 0x3d,
+    DW_AT_encoding = 0x3e,
+    DW_AT_external = 0x3f,
+    DW_AT_frame_base = 0x40,
+    DW_AT_friend = 0x41,
+    DW_AT_identifier_case = 0x42,
+    /* Reserved 0x43 */
+    DW_AT_namelist_item = 0x44,
+    DW_AT_priority = 0x45,
+    DW_AT_segment = 0x46,
+    DW_AT_specification = 0x47,
+    DW_AT_static_link = 0x48,
+    DW_AT_type = 0x49,
+    DW_AT_use_location = 0x4a,
+    DW_AT_variable_parameter = 0x4b,
+    DW_AT_virtuality = 0x4c,
+    DW_AT_vtable_elem_location = 0x4d,
+    DW_AT_allocated = 0x4e,
+    DW_AT_associated = 0x4f,
+    DW_AT_data_location = 0x50,
+    DW_AT_byte_stride = 0x51,
+    DW_AT_entry_pc = 0x52,
+    DW_AT_use_UTF8 = 0x53,
+    DW_AT_extension = 0x54,
+    DW_AT_ranges = 0x55,
+    DW_AT_trampoline = 0x56,
+    DW_AT_call_column = 0x57,
+    DW_AT_call_file = 0x58,
+    DW_AT_call_line = 0x59,
+    DW_AT_description = 0x5a,
+    DW_AT_binary_scale = 0x5b,
+    DW_AT_decimal_scale = 0x5c,
+    DW_AT_small = 0x5d,
+    DW_AT_decimal_sign = 0x5e,
+    DW_AT_digit_count = 0x5f,
+    DW_AT_picture_string = 0x60,
+    DW_AT_mutable = 0x61,
+    DW_AT_threads_scaled = 0x62,
+    DW_AT_explicit = 0x63,
+    DW_AT_object_pointer = 0x64,
+    DW_AT_endianity = 0x65,
+    DW_AT_elemental = 0x66,
+    DW_AT_pure = 0x67,
+    DW_AT_recursive = 0x68,
+    DW_AT_signature = 0x69,
+    DW_AT_main_subprogram = 0x6a,
+    DW_AT_data_bit_offset = 0x6b,
+    DW_AT_const_expr = 0x6c,
+    DW_AT_enum_class = 0x6d,
+    DW_AT_linkage_name = 0x6e,
+    DW_AT_string_length_bit_size = 0x6f,
+    DW_AT_string_length_byte_size = 0x70,
+    DW_AT_rank = 0x71,
+    DW_AT_str_offsets_base = 0x72,
+    DW_AT_addr_base = 0x73,
+    DW_AT_rnglists_base = 0x74,
+    /* Reserved 0x75 */
+    DW_AT_dwo_name = 0x76,
+    DW_AT_reference = 0x77,
+    DW_AT_rvalue_reference = 0x78,
+    DW_AT_macros = 0x79,
+    DW_AT_call_all_calls = 0x7a,
+    DW_AT_call_all_source_calls = 0x7b,
+    DW_AT_call_all_tail_calls = 0x7c,
+    DW_AT_call_return_pc = 0x7d,
+    DW_AT_call_value = 0x7e,
+    DW_AT_call_origin = 0x7f,
+    DW_AT_call_parameter = 0x80,
+    DW_AT_call_pc = 0x81,
+    DW_AT_call_tail_call = 0x82,
+    DW_AT_call_target = 0x83,
+    DW_AT_call_target_clobbered = 0x84,
+    DW_AT_call_data_location = 0x85,
+    DW_AT_call_data_value = 0x86,
+    DW_AT_noreturn = 0x87,
+    DW_AT_alignment = 0x88,
+    DW_AT_export_symbols = 0x89,
+    DW_AT_deleted = 0x8a,
+    DW_AT_defaulted = 0x8b,
+    DW_AT_loclists_base = 0x8c,
+    DW_AT_lo_user = 0x2000,
+    DW_AT_hi_user = 0x3fff
+};
+
+/* Attribute form encodings */
+enum
+{
+    DW_FORM_addr = 0x01,
+    /* Reserved 0x02 */
+    DW_FORM_block2 = 0x03,
+    DW_FORM_block4 = 0x04,
+    DW_FORM_data2 = 0x05,
+    DW_FORM_data4 = 0x06,
+    DW_FORM_data8 = 0x07,
+    DW_FORM_string = 0x08,
+    DW_FORM_block = 0x09,
+    DW_FORM_block1 = 0x0a,
+    DW_FORM_data1 = 0x0b,
+    DW_FORM_flag = 0x0c,
+    DW_FORM_sdata = 0x0d,
+    DW_FORM_strp = 0x0e,
+    DW_FORM_udata = 0x0f,
+    DW_FORM_ref_addr = 0x10,
+    DW_FORM_ref1 = 0x11,
+    DW_FORM_ref2 = 0x12,
+    DW_FORM_ref4 = 0x13,
+    DW_FORM_ref8 = 0x14,
+    DW_FORM_ref_udata = 0x15,
+    DW_FORM_indirect = 0x16,
+    DW_FORM_sec_offset = 0x17,
+    DW_FORM_exprloc = 0x18,
+    DW_FORM_flag_present = 0x19,
+    DW_FORM_strx = 0x1a,
+    DW_FORM_addrx = 0x1b,
+    DW_FORM_ref_sup4 = 0x1c,
+    DW_FORM_strp_sup = 0x1d,
+    DW_FORM_data16 = 0x1e,
+    DW_FORM_line_strp = 0x1f,
+    DW_FORM_ref_sig8 = 0x20,
+    DW_FORM_implicit_const = 0x21,
+    DW_FORM_loclistx = 0x22,
+    DW_FORM_rnglistx = 0x23,
+    DW_FORM_ref_sup8 = 0x24,
+    DW_FORM_strx1 = 0x25,
+    DW_FORM_strx2 = 0x26,
+    DW_FORM_strx3 = 0x27,
+    DW_FORM_strx4 = 0x28,
+    DW_FORM_addrx1 = 0x29,
+    DW_FORM_addrx2 = 0x2a,
+    DW_FORM_addrx3 = 0x2b,
+    DW_FORM_addrx4 = 0x2c
+};
+
+enum {
+    VAL_none = 0,
+    VAL_cstr = 1,
+    VAL_data = 2,
+    VAL_uint = 3,
+    VAL_int = 4
+};
+
+# define ABBREV_TABLE_SIZE 256
+typedef struct {
+    obj_info_t *obj;
+    char *file;
+    char *current_cu;
+    uint64_t current_low_pc;
+    char *debug_line_cu_end;
+    char *debug_line_files;
+    char *debug_line_directories;
+    char *p;
+    char *cu_end;
+    char *pend;
+    char *q0;
+    char *q;
+    int format; // 4 or 8
+    uint8_t address_size;
+    int level;
+    char *abbrev_table[ABBREV_TABLE_SIZE];
+} DebugInfoReader;
+
+typedef struct {
+    ptrdiff_t pos;
+    int tag;
+    int has_children;
+} DIE;
+
+typedef struct {
+    union {
+        char *ptr;
+        uint64_t uint64;
+        int64_t int64;
+    } as;
+    uint64_t off;
+    uint64_t at;
+    uint64_t form;
+    size_t size;
+    int type;
+} DebugInfoValue;
+
+/* TODO: Big Endian */
+#define MERGE_2INTS(a,b,sz) (((uint64_t)(b)<<sz)|(a))
+
+static uint16_t
+get_uint16(const uint8_t *p)
+{
+    return (uint16_t)MERGE_2INTS(p[0],p[1],8);
+}
+
+static uint32_t
+get_uint32(const uint8_t *p)
+{
+    return (uint32_t)MERGE_2INTS(get_uint16(p),get_uint16(p+2),16);
+}
+
+static uint64_t
+get_uint64(const uint8_t *p)
+{
+    return MERGE_2INTS(get_uint32(p),get_uint32(p+4),32);
+}
+
+static uint8_t
+read_uint8(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 1);
+    return *p;
+}
+
+static uint16_t
+read_uint16(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 2);
+    return get_uint16(p);
+}
+
+static uint32_t
+read_uint24(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 3);
+    return (*p << 16) | get_uint16(p+1);
+}
+
+static uint32_t
+read_uint32(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 4);
+    return get_uint32(p);
+}
+
+static uint64_t
+read_uint64(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 8);
+    return get_uint64(p);
+}
+
+static uintptr_t
+read_uintptr(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + SIZEOF_VOIDP);
+#if SIZEOF_VOIDP == 8
+    return get_uint64(p);
+#else
+    return get_uint32(p);
+#endif
+}
+
+static uint64_t
+read_uint(DebugInfoReader *reader)
+{
+    if (reader->format == 4) {
+        return read_uint32(&reader->p);
+    } else { /* 64 bit */
+        return read_uint64(&reader->p);
+    }
+}
+
+static uint64_t
+read_uleb128(DebugInfoReader *reader)
+{
+    return uleb128(&reader->p);
+}
+
+static int64_t
+read_sleb128(DebugInfoReader *reader)
+{
+    return sleb128(&reader->p);
+}
+
+static void
+debug_info_reader_init(DebugInfoReader *reader, obj_info_t *obj)
+{
+    reader->file = obj->mapped;
+    reader->obj = obj;
+    reader->p = obj->debug_info.ptr;
+    reader->pend = obj->debug_info.ptr + obj->debug_info.size;
+    reader->debug_line_cu_end = obj->debug_line.ptr;
+}
+
+static void
+di_read_debug_abbrev_cu(DebugInfoReader *reader)
+{
+    uint64_t prev = 0;
+    char *p = reader->q0;
+    for (;;) {
+        uint64_t abbrev_number = uleb128(&p);
+        if (abbrev_number <= prev) break;
+        if (abbrev_number < ABBREV_TABLE_SIZE) {
+            reader->abbrev_table[abbrev_number] = p;
+        }
+        prev = abbrev_number;
+        uleb128(&p); /* tag */
+        p++; /* has_children */
+        /* skip content */
+        for (;;) {
+            uint64_t at = uleb128(&p);
+            uint64_t form = uleb128(&p);
+            if (!at && !form) break;
+        }
+    }
+}
+
+static int
+di_read_debug_line_cu(DebugInfoReader *reader)
+{
+    const char *p;
+    struct LineNumberProgramHeader header;
+
+    p = (const char *)reader->debug_line_cu_end;
+    if (parse_debug_line_header(&p, &header))
+        return -1;
+
+    reader->debug_line_cu_end = (char *)header.cu_end;
+    reader->debug_line_directories = (char *)header.include_directories;
+    reader->debug_line_files = (char *)header.filenames;
+
+    return 0;
+}
+
+static void
+set_uint_value(DebugInfoValue *v, uint64_t n)
+{
+    v->as.uint64 = n;
+    v->type = VAL_uint;
+}
+
+static void
+set_int_value(DebugInfoValue *v, int64_t n)
+{
+    v->as.int64 = n;
+    v->type = VAL_int;
+}
+
+static void
+set_cstr_value(DebugInfoValue *v, char *s)
+{
+    v->as.ptr = s;
+    v->off = 0;
+    v->type = VAL_cstr;
+}
+
+static void
+set_cstrp_value(DebugInfoValue *v, char *s, uint64_t off)
+{
+    v->as.ptr = s;
+    v->off = off;
+    v->type = VAL_cstr;
+}
+
+static void
+set_data_value(DebugInfoValue *v, char *s)
+{
+    v->as.ptr = s;
+    v->type = VAL_data;
+}
+
+static const char *
+get_cstr_value(DebugInfoValue *v)
+{
+    if (v->as.ptr) {
+        return v->as.ptr + v->off;
+    } else {
+        return NULL;
+    }
+}
+
+static void
+debug_info_reader_read_value(DebugInfoReader *reader, uint64_t form, DebugInfoValue *v)
+{
+    switch (form) {
+      case DW_FORM_addr:
+        if (reader->address_size == 4) {
+            set_uint_value(v, read_uint32(&reader->p));
+        } else if (reader->address_size == 8) {
+            set_uint_value(v, read_uint64(&reader->p));
+        } else {
+            fprintf(stderr,"unknown address_size:%d", reader->address_size);
+            abort();
+        }
+        break;
+      case DW_FORM_block2:
+        v->size = read_uint16(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_block4:
+        v->size = read_uint32(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_data2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_data4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_data8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_string:
+        v->size = strlen(reader->p);
+        set_cstr_value(v, reader->p);
+        reader->p += v->size + 1;
+        break;
+      case DW_FORM_block:
+        v->size = uleb128(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_block1:
+        v->size = read_uint8(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_data1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_flag:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_sdata:
+        set_int_value(v, read_sleb128(reader));
+        break;
+      case DW_FORM_strp:
+        set_cstrp_value(v, reader->obj->debug_str.ptr, read_uint(reader));
+        break;
+      case DW_FORM_udata:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_ref_addr:
+        if (reader->address_size == 4) {
+            set_uint_value(v, read_uint32(&reader->p));
+        } else if (reader->address_size == 8) {
+            set_uint_value(v, read_uint64(&reader->p));
+        } else {
+            fprintf(stderr,"unknown address_size:%d", reader->address_size);
+            abort();
+        }
+        break;
+      case DW_FORM_ref1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_ref2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_ref4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_ref8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_ref_udata:
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_indirect:
+        /* TODO: read the referred value */
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_sec_offset:
+        set_uint_value(v, read_uint(reader)); /* offset */
+        /* addrptr: debug_addr */
+        /* lineptr: debug_line */
+        /* loclist: debug_loclists */
+        /* loclistptr: debug_loclists */
+        /* macptr: debug_macro */
+        /* rnglist: debug_rnglists */
+        /* rnglistptr: debug_rnglists */
+        /* stroffsetsptr: debug_str_offsets */
+        break;
+      case DW_FORM_exprloc:
+        v->size = (size_t)read_uleb128(reader);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_flag_present:
+        set_uint_value(v, 1);
+        break;
+      case DW_FORM_strx:
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_addrx:
+        /* TODO: read .debug_addr */
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_ref_sup4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_strp_sup:
+        set_uint_value(v, read_uint(reader));
+        /* *p = reader->sup_file + reader->sup_str->sh_offset + ret; */
+        break;
+      case DW_FORM_data16:
+        v->size = 16;
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_line_strp:
+        set_uint_value(v, read_uint(reader));
+        /* *p = reader->file + reader->line->sh_offset + ret; */
+        break;
+      case DW_FORM_ref_sig8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_implicit_const:
+        set_int_value(v, sleb128(&reader->q));
+        break;
+      case DW_FORM_loclistx:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_rnglistx:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_ref_sup8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_strx1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_strx2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_strx3:
+        set_uint_value(v, read_uint24(&reader->p));
+        break;
+      case DW_FORM_strx4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_addrx1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_addrx2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_addrx3:
+        set_uint_value(v, read_uint24(&reader->p));
+        break;
+      case DW_FORM_addrx4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case 0:
+        goto fail;
+        break;
+    }
+    return;
+
+  fail:
+    fprintf(stderr, "%d: unsupported form: %#"PRIx64"\n", __LINE__, form);
+    exit(1);
+}
+
+/* find abbrev in current compilation unit */
+static char *
+di_find_abbrev(DebugInfoReader *reader, uint64_t abbrev_number)
+{
+    char *p;
+    if (abbrev_number < ABBREV_TABLE_SIZE) {
+        return reader->abbrev_table[abbrev_number];
+    }
+    p = reader->abbrev_table[ABBREV_TABLE_SIZE-1];
+    /* skip 255th record */
+    uleb128(&p); /* tag */
+    p++; /* has_children */
+    /* skip content */
+    for (;;) {
+        uint64_t at = uleb128(&p);
+        uint64_t form = uleb128(&p);
+        if (!at && !form) break;
+    }
+    for (uint64_t n = uleb128(&p); abbrev_number != n; n = uleb128(&p)) {
+        if (n == 0) {
+            fprintf(stderr,"%d: Abbrev Number %"PRId64" not found\n",__LINE__, abbrev_number);
+            exit(1);
+        }
+        uleb128(&p); /* tag */
+        p++; /* has_children */
+        /* skip content */
+        for (;;) {
+            uint64_t at = uleb128(&p);
+            uint64_t form = uleb128(&p);
+            if (!at && !form) break;
+        }
+    }
+    return p;
+}
+
+#if 0
+static void
+hexdump0(const unsigned char *p, size_t n)
+{
+    size_t i;
+    fprintf(stderr, "     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+    for (i=0; i < n; i++){
+        switch (i & 15) {
+          case 0:
+            fprintf(stderr, "%02zd: %02X ", i/16, p[i]);
+            break;
+          case 15:
+            fprintf(stderr, "%02X\n", p[i]);
+            break;
+          default:
+            fprintf(stderr, "%02X ", p[i]);
+            break;
+        }
+    }
+    if ((i & 15) != 15) {
+        fprintf(stderr, "\n");
+    }
+}
+#define hexdump(p,n) hexdump0((const unsigned char *)p, n)
+
+static void
+div_inspect(DebugInfoValue *v)
+{
+    switch (v->type) {
+      case VAL_uint:
+        fprintf(stderr,"%d: type:%d size:%zx v:%lx\n",__LINE__,v->type,v->size,v->as.uint64);
+        break;
+      case VAL_int:
+        fprintf(stderr,"%d: type:%d size:%zx v:%ld\n",__LINE__,v->type,v->size,(int64_t)v->as.uint64);
+        break;
+      case VAL_cstr:
+        fprintf(stderr,"%d: type:%d size:%zx v:'%s'\n",__LINE__,v->type,v->size,v->as.ptr);
+        break;
+      case VAL_data:
+        fprintf(stderr,"%d: type:%d size:%zx v:\n",__LINE__,v->type,v->size);
+        hexdump(v->as.ptr, 16);
+        break;
+    }
+}
+#endif
+
+static DIE *
+di_read_die(DebugInfoReader *reader, DIE *die)
+{
+    uint64_t abbrev_number = uleb128(&reader->p);
+    if (abbrev_number == 0) {
+        reader->level--;
+        return NULL;
+    }
+
+    reader->q = di_find_abbrev(reader, abbrev_number);
+
+    die->pos = reader->p - reader->obj->debug_info.ptr - 1;
+    die->tag = (int)uleb128(&reader->q); /* tag */
+    die->has_children = *reader->q++; /* has_children */
+    if (die->has_children) {
+        reader->level++;
+    }
+    return die;
+}
+
+static DebugInfoValue *
+di_read_record(DebugInfoReader *reader, DebugInfoValue *vp)
+{
+    uint64_t at = uleb128(&reader->q);
+    uint64_t form = uleb128(&reader->q);
+    if (!at || !form) return NULL;
+    vp->at = at;
+    vp->form = form;
+    debug_info_reader_read_value(reader, form, vp);
+    return vp;
+}
+
+static void
+di_skip_records(DebugInfoReader *reader)
+{
+    for (;;) {
+        DebugInfoValue v = {{}};
+        uint64_t at = uleb128(&reader->q);
+        uint64_t form = uleb128(&reader->q);
+        if (!at || !form) return;
+        debug_info_reader_read_value(reader, form, &v);
+    }
+}
+
+typedef struct {
+    uint64_t low_pc;
+    uint64_t high_pc;
+    uint64_t ranges;
+    bool low_pc_set;
+    bool high_pc_set;
+    bool ranges_set;
+} ranges_t;
+
+static void
+ranges_set(ranges_t *ptr, DebugInfoValue *v)
+{
+    switch (v->at) {
+      case DW_AT_low_pc:
+        ptr->low_pc = v->as.uint64;
+        ptr->low_pc_set = true;
+        break;
+      case DW_AT_high_pc:
+        if (v->form == DW_FORM_addr) {
+            ptr->high_pc = v->as.uint64;
+        }
+        else {
+            ptr->high_pc = ptr->low_pc + v->as.uint64;
+        }
+        ptr->high_pc_set = true;
+        break;
+      case DW_AT_ranges:
+        ptr->ranges = v->as.uint64;
+        ptr->ranges_set = true;
+        break;
+    }
+}
+
+static uintptr_t
+ranges_include(DebugInfoReader *reader, ranges_t *ptr, uint64_t addr)
+{
+    if (ptr->high_pc_set) {
+        if (ptr->ranges_set || !ptr->low_pc_set) {
+            exit(1);
+        }
+        if (ptr->low_pc <= addr && addr <= ptr->high_pc) {
+            return (uintptr_t)ptr->low_pc;
+        }
+    }
+    else if (ptr->ranges_set) {
+        /* TODO: support base address selection entry */
+        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        uint64_t base = ptr->low_pc_set ? ptr->low_pc : reader->current_low_pc;
+        for (;;) {
+            uintptr_t from = read_uintptr(&p);
+            uintptr_t to = read_uintptr(&p);
+            if (!from && !to) break;
+            if (from == UINTPTR_MAX) {
+                /* base address selection entry */
+                base = to;
+            }
+            else if (base + from <= addr && addr < base + to) {
+                return from;
+            }
+        }
+    }
+    else if (ptr->low_pc_set) {
+        if (ptr->low_pc == addr) {
+            return (uintptr_t)ptr->low_pc;
+        }
+    }
+    return false;
+}
+
+#if 0
+static void
+ranges_inspect(DebugInfoReader *reader, ranges_t *ptr)
+{
+    if (ptr->high_pc_set) {
+        if (ptr->ranges_set || !ptr->low_pc_set) {
+            fprintf(stderr,"low_pc_set:%d high_pc_set:%d ranges_set:%d\n",ptr->low_pc_set,ptr->high_pc_set,ptr->ranges_set);
+            exit(1);
+        }
+        fprintf(stderr,"low_pc:%"PRIx64" high_pc:%"PRIx64"\n",ptr->low_pc,ptr->high_pc);
+    }
+    else if (ptr->ranges_set) {
+        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        fprintf(stderr,"low_pc:%"PRIx64" ranges:%"PRIx64" %lx ",ptr->low_pc,ptr->ranges, p-reader->obj->mapped);
+        for (;;) {
+            uintptr_t from = read_uintptr(&p);
+            uintptr_t to = read_uintptr(&p);
+            if (!from && !to) break;
+            fprintf(stderr,"%"PRIx64"-%"PRIx64" ",ptr->low_pc+from,ptr->low_pc+to);
+        }
+        fprintf(stderr,"\n");
+    }
+    else if (ptr->low_pc_set) {
+        fprintf(stderr,"low_pc:%"PRIx64"\n",ptr->low_pc);
+    }
+    else {
+        fprintf(stderr,"empty\n");
+    }
+}
+#endif
+
+static int
+di_read_cu(DebugInfoReader *reader)
+{
+    uint64_t unit_length;
+    uint16_t version;
+    uint64_t debug_abbrev_offset;
+    reader->format = 4;
+    reader->current_cu = reader->p;
+    unit_length = read_uint32(&reader->p);
+    if (unit_length == 0xffffffff) {
+        unit_length = read_uint64(&reader->p);
+        reader->format = 8;
+    }
+    reader->cu_end = reader->p + unit_length;
+    version = read_uint16(&reader->p);
+    if (version > 5) {
+        return -1;
+    }
+    else if (version == 5) {
+        /* unit_type = */ read_uint8(&reader->p);
+        reader->address_size = read_uint8(&reader->p);
+        debug_abbrev_offset = read_uint(reader);
+    }
+    else {
+        debug_abbrev_offset = read_uint(reader);
+        reader->address_size = read_uint8(&reader->p);
+    }
+    reader->q0 = reader->obj->debug_abbrev.ptr + debug_abbrev_offset;
+
+    reader->level = 0;
+    di_read_debug_abbrev_cu(reader);
+    if (di_read_debug_line_cu(reader)) return -1;
+
+#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER_BUILD_DATE)
+    /* Though DWARF specifies "the applicable base address defaults to the base
+       address of the compilation unit", but GCC seems to use zero as default */
+#else
+    do {
+        DIE die;
+
+        if (!di_read_die(reader, &die)) continue;
+
+        if (die.tag != DW_TAG_compile_unit) {
+            di_skip_records(reader);
+            break;
+        }
+
+        /* enumerate abbrev */
+        for (;;) {
+            DebugInfoValue v = {{}};
+            if (!di_read_record(reader, &v)) break;
+            switch (v.at) {
+              case DW_AT_low_pc:
+                reader->current_low_pc = v.as.uint64;
+                break;
+            }
+        }
+    } while (0);
+#endif
+    return 0;
+}
+
+static void
+read_abstract_origin(DebugInfoReader *reader, uint64_t abstract_origin, line_info_t *line)
+{
+    char *p = reader->p;
+    char *q = reader->q;
+    int level = reader->level;
+    DIE die;
+
+    reader->p = reader->current_cu + abstract_origin;
+    if (!di_read_die(reader, &die)) goto finish;
+
+    /* enumerate abbrev */
+    for (;;) {
+        DebugInfoValue v = {{}};
+        if (!di_read_record(reader, &v)) break;
+        switch (v.at) {
+          case DW_AT_name:
+            line->sname = get_cstr_value(&v);
+            break;
+        }
+    }
+
+  finish:
+    reader->p = p;
+    reader->q = q;
+    reader->level = level;
+}
+
+static void
+debug_info_read(DebugInfoReader *reader, int num_traces, void **traces,
+         line_info_t *lines, int offset) {
+    while (reader->p < reader->cu_end) {
+        DIE die;
+        ranges_t ranges = {};
+        line_info_t line = {};
+
+        if (!di_read_die(reader, &die)) continue;
+        /* fprintf(stderr,"%d:%tx: <%d>\n",__LINE__,die.pos,reader->level,die.tag); */
+
+        if (die.tag != DW_TAG_subprogram && die.tag != DW_TAG_inlined_subroutine) {
+          skip_die:
+            di_skip_records(reader);
+            continue;
+        }
+
+        /* enumerate abbrev */
+        for (;;) {
+            DebugInfoValue v = {{}};
+            /* ptrdiff_t pos = reader->p - reader->p0; */
+            if (!di_read_record(reader, &v)) break;
+            /* fprintf(stderr,"\n%d:%tx: AT:%lx FORM:%lx\n",__LINE__,pos,v.at,v.form); */
+            /* div_inspect(&v); */
+            switch (v.at) {
+              case DW_AT_name:
+                line.sname = get_cstr_value(&v);
+                break;
+              case DW_AT_call_file:
+                fill_filename((int)v.as.uint64, reader->debug_line_directories, reader->debug_line_files, &line, reader->obj);
+                break;
+              case DW_AT_call_line:
+                line.line = (int)v.as.uint64;
+                break;
+              case DW_AT_low_pc:
+              case DW_AT_high_pc:
+              case DW_AT_ranges:
+                ranges_set(&ranges, &v);
+                break;
+              case DW_AT_declaration:
+                goto skip_die;
+              case DW_AT_inline:
+                /* 1 or 3 */
+                break; /* goto skip_die; */
+              case DW_AT_abstract_origin:
+                read_abstract_origin(reader, v.as.uint64, &line);
+                break; /* goto skip_die; */
+            }
+        }
+        /* ranges_inspect(reader, &ranges); */
+        /* fprintf(stderr,"%d:%tx: %x ",__LINE__,diepos,die.tag); */
+        for (int i=offset; i < num_traces; i++) {
+            uintptr_t addr = (uintptr_t)traces[i];
+            uintptr_t offset = addr - reader->obj->base_addr + reader->obj->vmaddr;
+            uintptr_t saddr = ranges_include(reader, &ranges, offset);
+            if (saddr) {
+                /* fprintf(stderr, "%d:%tx: %d %lx->%lx %x %s: %s/%s %d %s %s %s\n",__LINE__,die.pos, i,addr,offset, die.tag,line.sname,line.dirname,line.filename,line.line,reader->obj->path,line.sname,lines[i].sname); */
+                if (lines[i].sname) {
+                    line_info_t *lp = malloc(sizeof(line_info_t));
+                    memcpy(lp, &lines[i], sizeof(line_info_t));
+                    lines[i].next = lp;
+                    lp->dirname = line.dirname;
+                    lp->filename = line.filename;
+                    lp->line = line.line;
+                    lp->saddr = 0;
+                }
+                lines[i].path = reader->obj->path;
+                lines[i].base_addr = line.base_addr;
+                lines[i].sname = line.sname;
+                lines[i].saddr = saddr + reader->obj->base_addr - reader->obj->vmaddr;
+            }
+        }
+    }
+}
+
+#ifdef USE_ELF
+static unsigned long
+uncompress_debug_section(ElfW(Shdr) *shdr, char *file, char **ptr)
+{
+    *ptr = NULL;
+#ifdef SUPPORT_COMPRESSED_DEBUG_LINE
+    ElfW(Chdr) *chdr = (ElfW(Chdr) *)(file + shdr->sh_offset);
+    unsigned long destsize = chdr->ch_size;
+    int ret = 0;
+
+    if (chdr->ch_type != ELFCOMPRESS_ZLIB) {
+	/* unsupported compression type */
+	return 0;
+    }
+
+    *ptr = malloc(destsize);
+    if (!*ptr) return 0;
+    ret = uncompress((Bytef *)*ptr, &destsize,
+	    (const Bytef*)chdr + sizeof(ElfW(Chdr)),
+            shdr->sh_size - sizeof(ElfW(Chdr)));
+    if (ret != Z_OK) goto fail;
+    return destsize;
+
+fail:
+    free(*ptr);
+    *ptr = NULL;
+#endif
+    return 0;
+}
+
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+	   obj_info_t **objp, line_info_t *lines, int offset)
+{
+    int i, j;
+    char *shstr;
+    ElfW(Ehdr) *ehdr;
+    ElfW(Shdr) *shdr, *shstr_shdr;
+    ElfW(Shdr) *gnu_debuglink_shdr = NULL;
+    int fd;
+    off_t filesize;
+    char *file;
+    ElfW(Shdr) *symtab_shdr = NULL, *strtab_shdr = NULL;
+    ElfW(Shdr) *dynsym_shdr = NULL, *dynstr_shdr = NULL;
+    obj_info_t *obj = *objp;
+    uintptr_t dladdr_fbase = 0;
+
+    fd = open(binary_filename, O_RDONLY);
+    if (fd < 0) {
+	goto fail;
+    }
+    filesize = lseek(fd, 0, SEEK_END);
+    if (filesize < 0) {
+	int e = errno;
+	close(fd);
+	kprintf("lseek: %s\n", strerror(e));
+	goto fail;
+    }
+#if SIZEOF_OFF_T > SIZEOF_SIZE_T
+    if (filesize > (off_t)SIZE_MAX) {
+	close(fd);
+	kprintf("Too large file %s\n", binary_filename);
+	goto fail;
+    }
+#endif
+    lseek(fd, 0, SEEK_SET);
+    /* async-signal unsafe */
+    file = (char *)mmap(NULL, (size_t)filesize, PROT_READ, MAP_SHARED, fd, 0);
+    if (file == MAP_FAILED) {
+	int e = errno;
+	close(fd);
+	kprintf("mmap: %s\n", strerror(e));
+	goto fail;
+    }
+    close(fd);
+
+    ehdr = (ElfW(Ehdr) *)file;
+    if (memcmp(ehdr->e_ident, "\177ELF", 4) != 0) {
+	/*
+	 * Huh? Maybe filename was overridden by setproctitle() and
+	 * it match non-elf file.
+	 */
+	goto fail;
+    }
+    obj->mapped = file;
+    obj->mapped_size = (size_t)filesize;
+
+    shdr = (ElfW(Shdr) *)(file + ehdr->e_shoff);
+
+    shstr_shdr = shdr + ehdr->e_shstrndx;
+    shstr = file + shstr_shdr->sh_offset;
+
+    for (i = 0; i < ehdr->e_shnum; i++) {
+        char *section_name = shstr + shdr[i].sh_name;
+	switch (shdr[i].sh_type) {
+	  case SHT_STRTAB:
+	    if (!strcmp(section_name, ".strtab")) {
+		strtab_shdr = shdr + i;
+	    }
+	    else if (!strcmp(section_name, ".dynstr")) {
+		dynstr_shdr = shdr + i;
+	    }
+	    break;
+	  case SHT_SYMTAB:
+	    /* if (!strcmp(section_name, ".symtab")) */
+	    symtab_shdr = shdr + i;
+	    break;
+	  case SHT_DYNSYM:
+	    /* if (!strcmp(section_name, ".dynsym")) */
+	    dynsym_shdr = shdr + i;
+	    break;
+	  case SHT_PROGBITS:
+	    if (!strcmp(section_name, ".gnu_debuglink")) {
+		gnu_debuglink_shdr = shdr + i;
+	    }
+            else {
+                const char *debug_section_names[] = {
+                    ".debug_abbrev",
+                    ".debug_info",
+                    ".debug_line",
+                    ".debug_ranges",
+                    ".debug_str"
+                };
+
+                for (j=0; j < DWARF_SECTION_COUNT; j++) {
+                    struct dwarf_section *s = obj_dwarf_section_at(obj, j);
+
+                    if (strcmp(section_name, debug_section_names[j]) != 0)
+                        continue;
+
+                    s->ptr = file + shdr[i].sh_offset;
+                    s->size = shdr[i].sh_size;
+                    s->flags = shdr[i].sh_flags;
+                    if (s->flags & SHF_COMPRESSED) {
+                        s->size = uncompress_debug_section(&shdr[i], file, &s->ptr);
+                        if (!s->size) goto fail;
+                    }
+                    break;
+                }
+            }
+	    break;
+	}
+    }
+
+    if (offset == -1) {
+	/* main executable */
+	offset = 0;
+	if (dynsym_shdr && dynstr_shdr) {
+	    char *strtab = file + dynstr_shdr->sh_offset;
+	    ElfW(Sym) *symtab = (ElfW(Sym) *)(file + dynsym_shdr->sh_offset);
+	    int symtab_count = (int)(dynsym_shdr->sh_size / sizeof(ElfW(Sym)));
+            void *handle = dlopen(NULL, RTLD_NOW|RTLD_LOCAL);
+            if (handle) {
+                for (j = 0; j < symtab_count; j++) {
+                    ElfW(Sym) *sym = &symtab[j];
+                    Dl_info info;
+                    void *s;
+                    if (ELF_ST_TYPE(sym->st_info) != STT_FUNC || sym->st_size == 0) continue;
+                    s = dlsym(handle, strtab + sym->st_name);
+                    if (s && dladdr(s, &info)) {
+                        obj->base_addr = dladdr_fbase;
+                        dladdr_fbase = (uintptr_t)info.dli_fbase;
+                        break;
+                    }
+                }
+                dlclose(handle);
+            }
+	    if (ehdr->e_type == ET_EXEC) {
+		obj->base_addr = 0;
+	    }
+	    else {
+		/* PIE (position-independent executable) */
+		obj->base_addr = dladdr_fbase;
+	    }
+	}
+    }
+
+    if (obj->debug_info.ptr && obj->debug_abbrev.ptr) {
+        DebugInfoReader reader;
+        debug_info_reader_init(&reader, obj);
+        i = 0;
+        while (reader.p < reader.pend) {
+            /* fprintf(stderr, "%d:%tx: CU[%d]\n", __LINE__, reader.p - reader.obj->debug_info.ptr, i++); */
+            if (di_read_cu(&reader)) goto use_symtab;
+            debug_info_read(&reader, num_traces, traces, lines, offset);
+        }
+    }
+    else {
+        /* This file doesn't have dwarf, use symtab or dynsym */
+use_symtab:
+        if (!symtab_shdr) {
+            /* This file doesn't have symtab, use dynsym instead */
+            symtab_shdr = dynsym_shdr;
+            strtab_shdr = dynstr_shdr;
+        }
+
+        if (symtab_shdr && strtab_shdr) {
+            char *strtab = file + strtab_shdr->sh_offset;
+            ElfW(Sym) *symtab = (ElfW(Sym) *)(file + symtab_shdr->sh_offset);
+            int symtab_count = (int)(symtab_shdr->sh_size / sizeof(ElfW(Sym)));
+            for (j = 0; j < symtab_count; j++) {
+                ElfW(Sym) *sym = &symtab[j];
+                uintptr_t saddr = (uintptr_t)sym->st_value + obj->base_addr;
+                if (ELF_ST_TYPE(sym->st_info) != STT_FUNC) continue;
+                for (i = offset; i < num_traces; i++) {
+                    uintptr_t d = (uintptr_t)traces[i] - saddr;
+                    if (lines[i].line > 0 || d > (uintptr_t)sym->st_size)
+                        continue;
+                    /* fill symbol name and addr from .symtab */
+                    if (!lines[i].sname) lines[i].sname = strtab + sym->st_name;
+                    lines[i].saddr = saddr;
+                    lines[i].path  = obj->path;
+                    lines[i].base_addr = obj->base_addr;
+                }
+            }
+        }
+    }
+
+    if (!obj->debug_line.ptr) {
+	/* This file doesn't have .debug_line section,
+	   let's check .gnu_debuglink section instead. */
+	if (gnu_debuglink_shdr && check_debuglink) {
+	    follow_debuglink(file + gnu_debuglink_shdr->sh_offset,
+			     num_traces, traces,
+			     objp, lines, offset);
+	}
+	goto finish;
+    }
+
+    if (parse_debug_line(num_traces, traces,
+            obj->debug_line.ptr,
+            obj->debug_line.size,
+            obj, lines, offset) == -1)
+        goto fail;
+
+finish:
+    return dladdr_fbase;
+fail:
+    return (uintptr_t)-1;
+}
+#else /* Mach-O */
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+        obj_info_t **objp, line_info_t *lines, int offset)
+{
+# ifdef __LP64__
+#  define LP(x) x##_64
+# else
+#  define LP(x) x
+# endif
+    int fd;
+    off_t filesize;
+    char *file, *p = NULL;
+    obj_info_t *obj = *objp;
+    struct LP(mach_header) *header;
+    uintptr_t dladdr_fbase = 0;
+
+    {
+        char *s = binary_filename;
+        char *base = strrchr(binary_filename, '/')+1;
+        size_t max = PATH_MAX;
+        size_t size = strlen(binary_filename);
+        size_t basesize = size - (base - binary_filename);
+        s += size;
+        max -= size;
+        p = s;
+        size = strlcpy(s, ".dSYM/Contents/Resources/DWARF/", max);
+        if (size == 0) goto fail;
+        s += size;
+        max -= size;
+        if (max <= basesize) goto fail;
+        memcpy(s, base, basesize);
+        s[basesize] = 0;
+
+        fd = open(binary_filename, O_RDONLY);
+        if (fd < 0) {
+            *p = 0; /* binary_filename becomes original file name */
+            fd = open(binary_filename, O_RDONLY);
+            if (fd < 0) {
+                goto fail;
+            }
+        }
+    }
+
+    filesize = lseek(fd, 0, SEEK_END);
+    if (filesize < 0) {
+        int e = errno;
+        close(fd);
+        kprintf("lseek: %s\n", strerror(e));
+        goto fail;
+    }
+#if SIZEOF_OFF_T > SIZEOF_SIZE_T
+    if (filesize > (off_t)SIZE_MAX) {
+        close(fd);
+        kprintf("Too large file %s\n", binary_filename);
+        goto fail;
+    }
+#endif
+    lseek(fd, 0, SEEK_SET);
+    /* async-signal unsafe */
+    file = (char *)mmap(NULL, (size_t)filesize, PROT_READ, MAP_SHARED, fd, 0);
+    if (file == MAP_FAILED) {
+        int e = errno;
+        close(fd);
+        kprintf("mmap: %s\n", strerror(e));
+        goto fail;
+    }
+    close(fd);
+
+    obj->mapped = file;
+    obj->mapped_size = (size_t)filesize;
+
+    header = (struct LP(mach_header) *)file;
+    if (header->magic == LP(MH_MAGIC)) {
+        /* non universal binary */
+        p = file;
+    }
+    else if (header->magic == FAT_CIGAM) {
+        struct LP(mach_header) *mhp = _NSGetMachExecuteHeader();
+        struct fat_header *fat = (struct fat_header *)file;
+        char *q = file + sizeof(*fat);
+        uint32_t nfat_arch = __builtin_bswap32(fat->nfat_arch);
+        /* fprintf(stderr,"%d: fat:%s %d\n",__LINE__, binary_filename,nfat_arch); */
+        for (uint32_t i = 0; i < nfat_arch; i++) {
+            struct fat_arch *arch = (struct fat_arch *)q;
+            cpu_type_t cputype = __builtin_bswap32(arch->cputype);
+            cpu_subtype_t cpusubtype = __builtin_bswap32(arch->cpusubtype);
+            uint32_t offset = __builtin_bswap32(arch->offset);
+            /* fprintf(stderr,"%d: fat %d %x/%x %x/%x\n",__LINE__, i, mhp->cputype,mhp->cpusubtype, cputype,cpusubtype); */
+            if (mhp->cputype == cputype &&
+                    (cpu_subtype_t)(mhp->cpusubtype & ~CPU_SUBTYPE_MASK) == cpusubtype) {
+                p = file + offset;
+                file = p;
+                header = (struct LP(mach_header) *)p;
+                if (header->magic == LP(MH_MAGIC)) {
+                    goto found_mach_header;
+                }
+                break;
+            }
+            q += sizeof(*arch);
+        }
+        kprintf("'%s' is not a Mach-O universal binary file!\n",binary_filename);
+        close(fd);
+        goto fail;
+    }
+    else {
+        kprintf("'%s' is not a "
+# ifdef __LP64__
+                "64"
+# else
+                "32"
+# endif
+                "-bit Mach-O file!\n",binary_filename);
+        close(fd);
+        goto fail;
+    }
+found_mach_header:
+    p += sizeof(*header);
+
+    for (uint32_t i = 0; i < (uint32_t)header->ncmds; i++) {
+        struct load_command *lcmd = (struct load_command *)p;
+        switch (lcmd->cmd) {
+          case LP(LC_SEGMENT):
+            {
+                static const char *debug_section_names[] = {
+                    "__debug_abbrev",
+                    "__debug_info",
+                    "__debug_line",
+                    "__debug_ranges",
+                    "__debug_str"
+                };
+                struct LP(segment_command) *scmd = (struct LP(segment_command) *)lcmd;
+                if (strcmp(scmd->segname, "__TEXT") == 0) {
+                    obj->vmaddr = scmd->vmaddr;
+                }
+                else if (strcmp(scmd->segname, "__DWARF") == 0) {
+                    p += sizeof(struct LP(segment_command));
+                    for (uint64_t i = 0; i < scmd->nsects; i++) {
+                        struct LP(section) *sect = (struct LP(section) *)p;
+                        p += sizeof(struct LP(section));
+                        for (int j=0; j < DWARF_SECTION_COUNT; j++) {
+                            struct dwarf_section *s = obj_dwarf_section_at(obj, j);
+
+                            if (strcmp(sect->sectname, debug_section_names[j]) != 0)
+                                continue;
+
+                            s->ptr = file + sect->offset;
+                            s->size = sect->size;
+                            s->flags = sect->flags;
+                            if (s->flags & SHF_COMPRESSED) {
+                                goto fail;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+            break;
+
+          case LC_SYMTAB:
+            {
+                struct symtab_command *cmd = (struct symtab_command *)lcmd;
+                struct LP(nlist) *nl = (struct LP(nlist) *)(file + cmd->symoff);
+                char *strtab = file + cmd->stroff, *sname = 0;
+                uint32_t j;
+                uintptr_t saddr = 0;
+                /* kprintf("[%2d]: %x/symtab %p\n", i, cmd->cmd, p); */
+                for (j = 0; j < cmd->nsyms; j++) {
+                    uintptr_t symsize, d;
+                    struct LP(nlist) *e = &nl[j];
+                        /* kprintf("[%2d][%4d]: %02x/%x/%x: %s %llx\n", i, j, e->n_type,e->n_sect,e->n_desc,strtab+e->n_un.n_strx,e->n_value); */
+                    if (e->n_type != N_FUN) continue;
+                    if (e->n_sect) {
+                        saddr = (uintptr_t)e->n_value + obj->base_addr - obj->vmaddr;
+                        sname = strtab + e->n_un.n_strx;
+                        /* kprintf("[%2d][%4d]: %02x/%x/%x: %s %llx\n", i, j, e->n_type,e->n_sect,e->n_desc,strtab+e->n_un.n_strx,e->n_value); */
+                        continue;
+                    }
+                    for (int k = offset; k < num_traces; k++) {
+                        d = (uintptr_t)traces[k] - saddr;
+                        symsize = e->n_value;
+                        /* kprintf("%lx %lx %lx\n",saddr,symsize,traces[k]); */
+                        if (lines[k].line > 0 || d > (uintptr_t)symsize)
+                            continue;
+                        /* fill symbol name and addr from .symtab */
+                        if (!lines[k].sname) lines[k].sname = sname;
+                        lines[k].saddr = saddr;
+                        lines[k].path  = obj->path;
+                        lines[k].base_addr = obj->base_addr;
+                    }
+                }
+            }
+        }
+        p += lcmd->cmdsize;
+    }
+
+    if (obj->debug_info.ptr && obj->debug_abbrev.ptr) {
+        DebugInfoReader reader;
+        debug_info_reader_init(&reader, obj);
+        while (reader.p < reader.pend) {
+            if (di_read_cu(&reader)) goto fail;
+            debug_info_read(&reader, num_traces, traces, lines, offset);
+        }
+    }
+
+    if (parse_debug_line(num_traces, traces,
+            obj->debug_line.ptr,
+            obj->debug_line.size,
+            obj, lines, offset) == -1)
+        goto fail;
+
+    return dladdr_fbase;
+fail:
+    return (uintptr_t)-1;
+}
+#endif
+
+#define HAVE_MAIN_EXE_PATH
+#if defined(__FreeBSD__)
+# include <sys/sysctl.h>
+#endif
+/* ssize_t main_exe_path(void)
+ *
+ * store the path of the main executable to `binary_filename`,
+ * and returns strlen(binary_filename).
+ * it is NUL terminated.
+ */
+#if defined(__linux__)
+static ssize_t
+main_exe_path(void)
+{
+# define PROC_SELF_EXE "/proc/self/exe"
+    ssize_t len = readlink(PROC_SELF_EXE, binary_filename, PATH_MAX);
+    if (len < 0) return 0;
+    binary_filename[len] = 0;
+    return len;
+}
+#elif defined(__FreeBSD__)
+static ssize_t
+main_exe_path(void)
+{
+    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};
+    size_t len = PATH_MAX;
+    int err = sysctl(mib, 4, binary_filename, &len, NULL, 0);
+    if (err) {
+	kprintf("Can't get the path of ruby");
+	return -1;
+    }
+    len--; /* sysctl sets strlen+1 */
+    return len;
+}
+#elif defined(HAVE_LIBPROC_H)
+static ssize_t
+main_exe_path(void)
+{
+    int len = proc_pidpath(getpid(), binary_filename, PATH_MAX);
+    if (len == 0) return 0;
+    binary_filename[len] = 0;
+    return len;
+}
+#else
+#undef HAVE_MAIN_EXE_PATH
+#endif
+
+static void
+print_line0(line_info_t *line, void *address)
+{
+    uintptr_t addr = (uintptr_t)address;
+    uintptr_t d = addr - line->saddr;
+    if (!address) {
+        /* inlined */
+        if (line->dirname && line->dirname[0]) {
+            kprintf("%s(%s) %s/%s:%d\n", line->path, line->sname, line->dirname, line->filename, line->line);
+        }
+        else {
+            kprintf("%s(%s) %s:%d\n", line->path, line->sname, line->filename, line->line);
+        }
+    }
+    else if (!line->path) {
+        kprintf("[0x%"PRIxPTR"]\n", addr);
+    }
+    else if (!line->saddr || !line->sname) {
+        kprintf("%s(0x%"PRIxPTR") [0x%"PRIxPTR"]\n", line->path, addr-line->base_addr, addr);
+    }
+    else if (line->line <= 0) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"]\n", line->path, line->sname,
+                d, addr);
+    }
+    else if (!line->filename) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] ???:%d\n", line->path, line->sname,
+                d, addr, line->line);
+    }
+    else if (line->dirname && line->dirname[0]) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] %s/%s:%d\n", line->path, line->sname,
+                d, addr, line->dirname, line->filename, line->line);
+    }
+    else {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] %s:%d\n", line->path, line->sname,
+                d, addr, line->filename, line->line);
+    }
+}
+
+static void
+print_line(line_info_t *line, void *address)
+{
+    print_line0(line, address);
+    if (line->next) {
+        print_line(line->next, NULL);
+    }
+}
+
+void
+rb_dump_backtrace_with_lines(int num_traces, void **traces)
+{
+    int i;
+    /* async-signal unsafe */
+    line_info_t *lines = (line_info_t *)calloc(num_traces, sizeof(line_info_t));
+    obj_info_t *obj = NULL;
+    /* 2 is NULL + main executable */
+    void **dladdr_fbases = (void **)calloc(num_traces+2, sizeof(void *));
+#ifdef HAVE_MAIN_EXE_PATH
+    char *main_path = NULL; /* used on printing backtrace */
+    ssize_t len;
+    if ((len = main_exe_path()) > 0) {
+	main_path = (char *)alloca(len + 1);
+	if (main_path) {
+	    uintptr_t addr;
+	    memcpy(main_path, binary_filename, len+1);
+	    append_obj(&obj);
+	    obj->path = main_path;
+	    addr = fill_lines(num_traces, traces, 1, &obj, lines, -1);
+	    if (addr != (uintptr_t)-1) {
+		dladdr_fbases[0] = (void *)addr;
+	    }
+	}
+    }
+#endif
+
+    /* fill source lines by reading dwarf */
+    for (i = 0; i < num_traces; i++) {
+	Dl_info info;
+	if (lines[i].line) continue;
+	if (dladdr(traces[i], &info)) {
+	    const char *path;
+	    void **p;
+
+	    /* skip symbols which is in already checked objects */
+	    /* if the binary is strip-ed, this may effect */
+	    for (p=dladdr_fbases; *p; p++) {
+		if (*p == info.dli_fbase) {
+		    lines[i].path = info.dli_fname;
+		    lines[i].sname = info.dli_sname;
+		    goto next_line;
+		}
+	    }
+	    *p = info.dli_fbase;
+
+	    append_obj(&obj);
+	    obj->base_addr = (uintptr_t)info.dli_fbase;
+	    path = info.dli_fname;
+	    obj->path = path;
+	    lines[i].path = path;
+            lines[i].sname = info.dli_sname;
+            lines[i].saddr = (uintptr_t)info.dli_saddr;
+	    strlcpy(binary_filename, path, PATH_MAX);
+	    if (fill_lines(num_traces, traces, 1, &obj, lines, i) == (uintptr_t)-1)
+		break;
+	}
+next_line:
+	continue;
+    }
+
+    /* output */
+    for (i = 0; i < num_traces; i++) {
+        print_line(&lines[i], traces[i]);
+
+	/* FreeBSD's backtrace may show _start and so on */
+	if (lines[i].sname && strcmp("main", lines[i].sname) == 0)
+	    break;
+    }
+
+    /* free */
+    while (obj) {
+	obj_info_t *o = obj;
+        for (i=0; i < DWARF_SECTION_COUNT; i++) {
+            struct dwarf_section *s = obj_dwarf_section_at(obj, i);
+            if (s->flags & SHF_COMPRESSED) {
+                free(s->ptr);
+            }
+        }
+	if (obj->mapped_size) {
+	    munmap(obj->mapped, obj->mapped_size);
+	}
+	obj = o->next;
+	free(o);
+    }
+    for (i = 0; i < num_traces; i++) {
+        line_info_t *line = lines[i].next;
+        while (line) {
+            line_info_t *l = line;
+            line = line->next;
+            free(l);
+        }
+    }
+    free(lines);
+    free(dladdr_fbases);
+}
+
+/* From FreeBSD's lib/libstand/printf.c */
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
+#include <stdarg.h>
+#define MAXNBUF (sizeof(intmax_t) * CHAR_BIT + 1)
+static inline int toupper(int c) { return ('A' <= c && c <= 'Z') ? (c&0x5f) : c; }
+#define    hex2ascii(hex)  (hex2ascii_data[hex])
+static const char hex2ascii_data[] = "0123456789abcdefghijklmnopqrstuvwxyz";
+static inline int imax(int a, int b) { return (a > b ? a : b); }
+static int kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, va_list ap);
+
+static void putce(int c)
+{
+    char s[1];
+    ssize_t ret;
+
+    s[0] = (char)c;
+    ret = write(2, s, 1);
+    (void)ret;
+}
+
+static int
+kprintf(const char *fmt, ...)
+{
+	va_list ap;
+	int retval;
+
+	va_start(ap, fmt);
+	retval = kvprintf(fmt, putce, NULL, 10, ap);
+	va_end(ap);
+	return retval;
+}
+
+/*
+ * Put a NUL-terminated ASCII number (base <= 36) in a buffer in reverse
+ * order; return an optional length and a pointer to the last character
+ * written in the buffer (i.e., the first character of the string).
+ * The buffer pointed to by `nbuf' must have length >= MAXNBUF.
+ */
+static char *
+ksprintn(char *nbuf, uintmax_t num, int base, int *lenp, int upper)
+{
+	char *p, c;
+
+	p = nbuf;
+	*p = '\0';
+	do {
+		c = hex2ascii(num % base);
+		*++p = upper ? toupper(c) : c;
+	} while (num /= base);
+	if (lenp)
+		*lenp = (int)(p - nbuf);
+	return (p);
+}
+
+/*
+ * Scaled down version of printf(3).
+ *
+ * Two additional formats:
+ *
+ * The format %b is supported to decode error registers.
+ * Its usage is:
+ *
+ *	printf("reg=%b\n", regval, "<base><arg>*");
+ *
+ * where <base> is the output base expressed as a control character, e.g.
+ * \10 gives octal; \20 gives hex.  Each arg is a sequence of characters,
+ * the first of which gives the bit number to be inspected (origin 1), and
+ * the next characters (up to a control character, i.e. a character <= 32),
+ * give the name of the register.  Thus:
+ *
+ *	kvprintf("reg=%b\n", 3, "\10\2BITTWO\1BITONE\n");
+ *
+ * would produce output:
+ *
+ *	reg=3<BITTWO,BITONE>
+ *
+ * XXX:  %D  -- Hexdump, takes pointer and separator string:
+ *		("%6D", ptr, ":")   -> XX:XX:XX:XX:XX:XX
+ *		("%*D", len, ptr, " " -> XX XX XX XX ...
+ */
+static int
+kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, va_list ap)
+{
+#define PCHAR(c) {int cc=(c); if (func) (*func)(cc); else *d++ = cc; retval++; }
+	char nbuf[MAXNBUF];
+	char *d;
+	const char *p, *percent, *q;
+	unsigned char *up;
+	int ch, n;
+	uintmax_t num;
+	int base, lflag, qflag, tmp, width, ladjust, sharpflag, neg, sign, dot;
+	int cflag, hflag, jflag, tflag, zflag;
+	int dwidth, upper;
+	char padc;
+	int stop = 0, retval = 0;
+
+	num = 0;
+	if (!func)
+		d = (char *) arg;
+	else
+		d = NULL;
+
+	if (fmt == NULL)
+		fmt = "(fmt null)\n";
+
+	if (radix < 2 || radix > 36)
+		radix = 10;
+
+	for (;;) {
+		padc = ' ';
+		width = 0;
+		while ((ch = (unsigned char)*fmt++) != '%' || stop) {
+			if (ch == '\0')
+				return (retval);
+			PCHAR(ch);
+		}
+		percent = fmt - 1;
+		qflag = 0; lflag = 0; ladjust = 0; sharpflag = 0; neg = 0;
+		sign = 0; dot = 0; dwidth = 0; upper = 0;
+		cflag = 0; hflag = 0; jflag = 0; tflag = 0; zflag = 0;
+reswitch:	switch (ch = (unsigned char)*fmt++) {
+		case '.':
+			dot = 1;
+			goto reswitch;
+		case '#':
+			sharpflag = 1;
+			goto reswitch;
+		case '+':
+			sign = 1;
+			goto reswitch;
+		case '-':
+			ladjust = 1;
+			goto reswitch;
+		case '%':
+			PCHAR(ch);
+			break;
+		case '*':
+			if (!dot) {
+				width = va_arg(ap, int);
+				if (width < 0) {
+					ladjust = !ladjust;
+					width = -width;
+				}
+			} else {
+				dwidth = va_arg(ap, int);
+			}
+			goto reswitch;
+		case '0':
+			if (!dot) {
+				padc = '0';
+				goto reswitch;
+			}
+		case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+				for (n = 0;; ++fmt) {
+					n = n * 10 + ch - '0';
+					ch = *fmt;
+					if (ch < '0' || ch > '9')
+						break;
+				}
+			if (dot)
+				dwidth = n;
+			else
+				width = n;
+			goto reswitch;
+		case 'b':
+			num = (unsigned int)va_arg(ap, int);
+			p = va_arg(ap, char *);
+			for (q = ksprintn(nbuf, num, *p++, NULL, 0); *q;)
+				PCHAR(*q--);
+
+			if (num == 0)
+				break;
+
+			for (tmp = 0; *p;) {
+				n = *p++;
+				if (num & (1 << (n - 1))) {
+					PCHAR(tmp ? ',' : '<');
+					for (; (n = *p) > ' '; ++p)
+						PCHAR(n);
+					tmp = 1;
+				} else
+					for (; *p > ' '; ++p)
+						continue;
+			}
+			if (tmp)
+				PCHAR('>');
+			break;
+		case 'c':
+			PCHAR(va_arg(ap, int));
+			break;
+		case 'D':
+			up = va_arg(ap, unsigned char *);
+			p = va_arg(ap, char *);
+			if (!width)
+				width = 16;
+			while(width--) {
+				PCHAR(hex2ascii(*up >> 4));
+				PCHAR(hex2ascii(*up & 0x0f));
+				up++;
+				if (width)
+					for (q=p;*q;q++)
+						PCHAR(*q);
+			}
+			break;
+		case 'd':
+		case 'i':
+			base = 10;
+			sign = 1;
+			goto handle_sign;
+		case 'h':
+			if (hflag) {
+				hflag = 0;
+				cflag = 1;
+			} else
+				hflag = 1;
+			goto reswitch;
+		case 'j':
+			jflag = 1;
+			goto reswitch;
+		case 'l':
+			if (lflag) {
+				lflag = 0;
+				qflag = 1;
+			} else
+				lflag = 1;
+			goto reswitch;
+		case 'n':
+			if (jflag)
+				*(va_arg(ap, intmax_t *)) = retval;
+			else if (qflag)
+				*(va_arg(ap, int64_t *)) = retval;
+			else if (lflag)
+				*(va_arg(ap, long *)) = retval;
+			else if (zflag)
+				*(va_arg(ap, size_t *)) = retval;
+			else if (hflag)
+				*(va_arg(ap, short *)) = retval;
+			else if (cflag)
+				*(va_arg(ap, char *)) = retval;
+			else
+				*(va_arg(ap, int *)) = retval;
+			break;
+		case 'o':
+			base = 8;
+			goto handle_nosign;
+		case 'p':
+			base = 16;
+			sharpflag = (width == 0);
+			sign = 0;
+			num = (uintptr_t)va_arg(ap, void *);
+			goto number;
+		case 'q':
+			qflag = 1;
+			goto reswitch;
+		case 'r':
+			base = radix;
+			if (sign)
+				goto handle_sign;
+			goto handle_nosign;
+		case 's':
+			p = va_arg(ap, char *);
+			if (p == NULL)
+				p = "(null)";
+			if (!dot)
+				n = (int)strlen (p);
+			else
+				for (n = 0; n < dwidth && p[n]; n++)
+					continue;
+
+			width -= n;
+
+			if (!ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			while (n--)
+				PCHAR(*p++);
+			if (ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			break;
+		case 't':
+			tflag = 1;
+			goto reswitch;
+		case 'u':
+			base = 10;
+			goto handle_nosign;
+		case 'X':
+			upper = 1;
+		case 'x':
+			base = 16;
+			goto handle_nosign;
+		case 'y':
+			base = 16;
+			sign = 1;
+			goto handle_sign;
+		case 'z':
+			zflag = 1;
+			goto reswitch;
+handle_nosign:
+			sign = 0;
+			if (jflag)
+				num = va_arg(ap, uintmax_t);
+			else if (qflag)
+				num = va_arg(ap, uint64_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, unsigned long);
+			else if (zflag)
+				num = va_arg(ap, size_t);
+			else if (hflag)
+				num = (unsigned short)va_arg(ap, int);
+			else if (cflag)
+				num = (unsigned char)va_arg(ap, int);
+			else
+				num = va_arg(ap, unsigned int);
+			goto number;
+handle_sign:
+			if (jflag)
+				num = va_arg(ap, intmax_t);
+			else if (qflag)
+				num = va_arg(ap, int64_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, long);
+			else if (zflag)
+				num = va_arg(ap, ssize_t);
+			else if (hflag)
+				num = (short)va_arg(ap, int);
+			else if (cflag)
+				num = (char)va_arg(ap, int);
+			else
+				num = va_arg(ap, int);
+number:
+			if (sign && (intmax_t)num < 0) {
+				neg = 1;
+				num = -(intmax_t)num;
+			}
+			p = ksprintn(nbuf, num, base, &n, upper);
+			tmp = 0;
+			if (sharpflag && num != 0) {
+				if (base == 8)
+					tmp++;
+				else if (base == 16)
+					tmp += 2;
+			}
+			if (neg)
+				tmp++;
+
+			if (!ladjust && padc == '0')
+				dwidth = width - tmp;
+			width -= tmp + imax(dwidth, n);
+			dwidth -= n;
+			if (!ladjust)
+				while (width-- > 0)
+					PCHAR(' ');
+			if (neg)
+				PCHAR('-');
+			if (sharpflag && num != 0) {
+				if (base == 8) {
+					PCHAR('0');
+				} else if (base == 16) {
+					PCHAR('0');
+					PCHAR('x');
+				}
+			}
+			while (dwidth-- > 0)
+				PCHAR('0');
+
+			while (*p)
+				PCHAR(*p--);
+
+			if (ladjust)
+				while (width-- > 0)
+					PCHAR(' ');
+
+			break;
+		default:
+			while (percent < fmt)
+				PCHAR(*percent++);
+			/*
+			 * Since we ignore an formatting argument it is no
+			 * longer safe to obey the remaining formatting
+			 * arguments as the arguments will no longer match
+			 * the format specs.
+			 */
+			stop = 1;
+			break;
+		}
+	}
+#undef PCHAR
+}
+#else /* defined(USE_ELF) */
+#error not supported
+#endif
diff -Nuarp ruby-2.7.8.a/common.mk ruby-2.7.8.b/common.mk
--- ruby-2.7.8.a/common.mk	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/common.mk	2023-05-20 18:17:27.030200700 -0400
@@ -81,7 +81,8 @@ ENC_MK        = enc.mk
 MAKE_ENC      = -f $(ENC_MK) V="$(V)" UNICODE_HDR_DIR="$(UNICODE_HDR_DIR)" \
 		RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(mflags)
 
-COMMONOBJS    = array.$(OBJEXT) \
+COMMONOBJS    = abrt.$(OBJEXT) \
+                array.$(OBJEXT) \
 		ast.$(OBJEXT) \
 		bignum.$(OBJEXT) \
 		class.$(OBJEXT) \
diff -Nuarp ruby-2.7.8.a/configure.ac ruby-2.7.8.b/configure.ac
--- ruby-2.7.8.a/configure.ac	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/configure.ac	2023-05-20 18:17:59.782601883 -0400
@@ -98,7 +98,7 @@ RUBY_BASE_NAME=`echo ruby | sed "$progra
 RUBYW_BASE_NAME=`echo rubyw | sed "$program_transform_name"`
 AC_SUBST(RUBY_BASE_NAME)
 AC_SUBST(RUBYW_BASE_NAME)
-AC_SUBST(RUBY_VERSION_NAME, '${RUBY_BASE_NAME}-${ruby_version}')
+AC_SUBST(RUBY_VERSION_NAME, '${RUBY_BASE_NAME}-${ruby_version_dir_name}')
 
 AC_CANONICAL_TARGET
 test x"$target_alias" = x &&
@@ -1873,6 +1873,7 @@ AC_CHECK_FUNCS(lstat)
 AC_CHECK_FUNCS(lutimes)
 AC_CHECK_FUNCS(malloc_usable_size)
 AC_CHECK_FUNCS(malloc_size)
+AC_CHECK_FUNCS(malloc_trim)
 AC_CHECK_FUNCS(mblen)
 AC_CHECK_FUNCS(memalign)
 AC_CHECK_FUNCS(memset_s)
@@ -3140,6 +3141,11 @@ AS_IF([test ${multiarch+set}], [
 ])
 
 archlibdir='${libdir}/${arch}'
+AC_ARG_WITH(archlibdir,
+	    AS_HELP_STRING([--with-archlibdir=DIR],
+			   [prefix for libruby [[LIBDIR/ARCH]]]),
+	    [archlibdir="$withval"])
+
 sitearchlibdir='${libdir}/${sitearch}'
 archincludedir='${includedir}/${arch}'
 sitearchincludedir='${includedir}/${sitearch}'
@@ -3729,9 +3735,6 @@ AS_CASE(["$target_os"],
     rubyw_install_name='$(RUBYW_INSTALL_NAME)'
     ])
 
-rubylibdir='${rubylibprefix}/${ruby_version}'
-rubyarchdir=${multiarch+'${rubyarchprefix}/${ruby_version}'}${multiarch-'${rubylibdir}/${arch}'}
-
 rubyarchprefix=${multiarch+'${archlibdir}/${RUBY_BASE_NAME}'}${multiarch-'${rubylibprefix}/${arch}'}
 AC_ARG_WITH(rubyarchprefix,
 	    AS_HELP_STRING([--with-rubyarchprefix=DIR],
@@ -3754,56 +3757,67 @@ AC_ARG_WITH(ridir,
 AC_SUBST(ridir)
 AC_SUBST(RI_BASE_NAME)
 
-AC_ARG_WITH(ruby-version,
-	    AS_HELP_STRING([--with-ruby-version=STR], [ruby version string for version specific directories [[full]] (full|minor|STR)]),
-            [ruby_version=$withval],
-            [ruby_version=full])
 unset RUBY_LIB_VERSION
-unset RUBY_LIB_VERSION_STYLE
-AS_CASE(["$ruby_version"],
-  [full],  [RUBY_LIB_VERSION_STYLE='3	/* full */'],
-  [minor], [RUBY_LIB_VERSION_STYLE='2	/* minor */'])
-AS_IF([test ${RUBY_LIB_VERSION_STYLE+set}], [
-    {
-    echo "#define RUBY_LIB_VERSION_STYLE $RUBY_LIB_VERSION_STYLE"
-    echo '#define STRINGIZE(x) x'
-    test -f revision.h -o -f "${srcdir}/revision.h" || echo '#define RUBY_REVISION 0'
-    echo '#include "version.h"'
-    echo 'ruby_version=RUBY_LIB_VERSION'
-    } > conftest.c
-    ruby_version="`$CPP -I. -I"${srcdir}" -I"${srcdir}/include" conftest.c | sed '/^ruby_version=/!d;s/ //g'`"
-    eval $ruby_version
-], [test -z "${ruby_version}"], [
-    AC_MSG_ERROR([No ruby version, No place for bundled libraries])
-], [
-    RUBY_LIB_VERSION="${ruby_version}"
-])
+RUBY_LIB_VERSION_STYLE='3	/* full */'
+{
+echo "#define RUBY_LIB_VERSION_STYLE $RUBY_LIB_VERSION_STYLE"
+echo '#define STRINGIZE(x) x'
+test -f revision.h -o -f "${srcdir}/revision.h" || echo '#define RUBY_REVISION 0'
+echo '#include "version.h"'
+echo 'ruby_version=RUBY_LIB_VERSION'
+} > conftest.c
+ruby_version="`$CPP -I. -I"${srcdir}" -I"${srcdir}/include" conftest.c | sed '/^ruby_version=/!d;s/ //g'`"
+eval $ruby_version
+
+RUBY_LIB_VERSION="${ruby_version}"
+
 AC_SUBST(RUBY_LIB_VERSION_STYLE)
 AC_SUBST(RUBY_LIB_VERSION)
 
+AC_ARG_WITH(ruby-version,
+	    AS_HELP_STRING([--with-ruby-version=STR], [ruby version string for version specific directories [[full]] (full|STR)]),
+            [ruby_version_dir_name=$withval],
+            [ruby_version_dir_name=full])
+AS_CASE(["$ruby_version_dir_name"],
+  [full], [ruby_version_dir_name='${ruby_version}'])
+
+ruby_version_dir=/'${ruby_version_dir_name}'
+
+if test -z "${ruby_version_dir_name}"; then
+    unset ruby_version_dir
+    AC_DEFINE(RUBY_LIB_VERSION_BLANK, 1)
+fi
+
+rubylibdir='${rubylibprefix}'${ruby_version_dir}
+rubyarchdir=${multiarch+'${rubyarchprefix}'${ruby_version_dir}}${multiarch-'${rubylibdir}/${arch}'}
+
 AC_ARG_WITH(sitedir,
 	    AS_HELP_STRING([--with-sitedir=DIR], [site libraries in DIR [[RUBY_LIB_PREFIX/site_ruby]], "no" to disable site directory]),
             [sitedir=$withval],
             [sitedir='${rubylibprefix}/site_ruby'])
-sitelibdir='${sitedir}/${ruby_version}'
+sitelibdir='${sitedir}'${ruby_version_dir}
 
 AC_ARG_WITH(sitearchdir,
 	    AS_HELP_STRING([--with-sitearchdir=DIR],
 			   [architecture dependent site libraries in DIR [[SITEDIR/SITEARCH]], "no" to disable site directory]),
             [sitearchdir=$withval],
-            [sitearchdir=${multiarch+'${rubysitearchprefix}/site_ruby/${ruby_version}'}${multiarch-'${sitelibdir}/${sitearch}'}])
+            [sitearchdir=${multiarch+'${rubysitearchprefix}/site_ruby'${ruby_version_dir}}${multiarch-'${sitelibdir}/${sitearch}'}])
 
 AC_ARG_WITH(vendordir,
 	    AS_HELP_STRING([--with-vendordir=DIR], [vendor libraries in DIR [[RUBY_LIB_PREFIX/vendor_ruby]], "no" to disable vendor directory]),
             [vendordir=$withval],
             [vendordir='${rubylibprefix}/vendor_ruby'])
-vendorlibdir='${vendordir}/${ruby_version}'
+vendorlibdir='${vendordir}'${ruby_version_dir}
 
 AC_ARG_WITH(vendorarchdir,
 	    AS_HELP_STRING([--with-vendorarchdir=DIR],
 			   [architecture dependent vendor libraries in DIR [[VENDORDIR/SITEARCH]], "no" to disable vendor directory]),
             [vendorarchdir=$withval],
-            [vendorarchdir=${multiarch+'${rubysitearchprefix}/vendor_ruby/${ruby_version}'}${multiarch-'${vendorlibdir}/${sitearch}'}])
+            [vendorarchdir=${multiarch+'${rubysitearchprefix}/vendor_ruby'${ruby_version_dir}}${multiarch-'${vendorlibdir}/${sitearch}'}])
+
+AC_ARG_WITH(rubygemsdir,
+           AS_HELP_STRING([--with-rubygemsdir=DIR], [custom rubygems directory]),
+            [rubygemsdir=$withval])
 
 AS_IF([test "${LOAD_RELATIVE+set}"], [
     AC_DEFINE_UNQUOTED(LOAD_RELATIVE, $LOAD_RELATIVE)
@@ -3820,6 +3834,7 @@ AC_SUBST(sitearchincludedir)dnl
 AC_SUBST(arch)dnl
 AC_SUBST(sitearch)dnl
 AC_SUBST(ruby_version)dnl
+AC_SUBST(ruby_version_dir_name)dnl
 AC_SUBST(rubylibdir)dnl
 AC_SUBST(rubyarchdir)dnl
 AC_SUBST(sitedir)dnl
@@ -3828,10 +3843,13 @@ AC_SUBST(sitearchdir)dnl
 AC_SUBST(vendordir)dnl
 AC_SUBST(vendorlibdir)dnl
 AC_SUBST(vendorarchdir)dnl
+AC_SUBST(rubygemsdir)dnl
 
 AC_SUBST(CONFIGURE, "`echo $0 | sed 's|.*/||'`")dnl
 AC_SUBST(configure_args, "`echo "${ac_configure_args}" | sed 's/\\$/$$/g'`")dnl
 
+target_cpu=`echo $target_cpu | sed s/i.86/i386/`
+
 AS_IF([test "${universal_binary-no}" = yes ], [
     arch="universal-${target_os}"
     AS_IF([test "${rb_cv_architecture_available}" = yes], [
diff -Nuarp ruby-2.7.8.a/configure.ac.orig ruby-2.7.8.b/configure.ac.orig
--- ruby-2.7.8.a/configure.ac.orig	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.8.b/configure.ac.orig	2023-05-20 18:17:16.445071044 -0400
@@ -0,0 +1,4139 @@
+dnl Process this file with autoconf to produce a configure script.
+AC_INIT
+{
+AC_CONFIG_AUX_DIR(tool)
+AC_CONFIG_MACRO_DIRS(tool/m4)
+
+AC_PREREQ(2.67)
+
+dnl   override AC_CHECKING
+dnl   placed here due to aclocal(1)'s
+dnl   ignoring this definition in separate files
+AC_DEFUN([AC_CHECKING],[dnl
+AC_REQUIRE([_COLORIZE_RESULT_PREPARE])dnl
+AS_MESSAGE([checking ${msg_checking}$1${msg_reset}...])])dnl
+
+AC_DISABLE_OPTION_CHECKING
+
+AC_ARG_VAR([cflags], [additional CFLAGS (ignored when CFLAGS is given)])
+AC_ARG_VAR([cppflags], [additional CPPFLAGS (ignored when CPPFLAGS is given)])
+AC_ARG_VAR([cxxflags], [additional CXXFLAGS (ignored when CXXFLAGS is given)])
+
+: "environment section" && {
+HAVE_BASERUBY=yes
+BASERUBY_VERSION=
+AC_ARG_WITH(baseruby,
+	AS_HELP_STRING([--with-baseruby=RUBY], [use RUBY as baseruby; RUBY is the pathname of ruby]),
+	[AS_CASE(["$withval"],
+	    [*ruby*],[BASERUBY=$withval],
+	    [no],[HAVE_BASERUBY=no],
+	    [AC_MSG_ERROR(need ruby)])
+	],
+	[
+		AC_PATH_PROG([BASERUBY], [ruby], [false])
+	])
+AS_IF([test "$HAVE_BASERUBY" = yes -a "`RUBYOPT=- $BASERUBY -e 'print 42' 2>/dev/null`" = 42], [
+    AS_IF([test "`RUBYOPT=- $BASERUBY --disable=gems -e 'print 42' 2>/dev/null`" = 42], [
+	BASERUBY="$BASERUBY --disable=gems"
+        BASERUBY_VERSION=`$BASERUBY -v`
+    ])
+    $BASERUBY -C "$srcdir" tool/downloader.rb -d tool -e gnu config.guess config.sub >&AS_MESSAGE_FD
+], [
+    BASERUBY="echo executable host ruby is required.  use --with-baseruby option.; false"
+    HAVE_BASERUBY=no
+])
+AC_SUBST(BASERUBY)
+AC_SUBST(HAVE_BASERUBY)
+
+: ${GIT=git}
+HAVE_GIT=yes
+AC_ARG_WITH(git,
+	AS_HELP_STRING([--without-git], [never use git]),
+	[AS_CASE([$withval],
+	    [no],  [GIT=never-use HAVE_GIT=no],
+	    [yes], [],
+	    [GIT=$withval])])
+AS_IF([test x"$HAVE_GIT" = xyes], [command -v "$GIT" > /dev/null || HAVE_GIT=no])
+AC_SUBST(GIT)
+AC_SUBST(HAVE_GIT)
+
+eval `sed -n -e ['s/^@%:@define RUBY_[A-Z_]*VERSION_\([A-Z][A-Z][A-Z_0-9]*\) \([0-9][0-9]*\)$/\1=\2/p'] \
+      -e ['s/^@%:@define \(RUBY_PATCHLEVEL\) \(.*\)/\1=\2/p'] \
+     $srcdir/include/ruby/version.h $srcdir/version.h`
+for v in MAJOR MINOR TEENY; do
+    AS_IF([eval "test \"\$$v\" = ''"], [
+	AC_MSG_ERROR(could not determine $v number from version.h)
+    ])
+done
+AC_SUBST(MAJOR)
+AC_SUBST(MINOR)
+AC_SUBST(TEENY)
+AC_SUBST(RUBY_API_VERSION, '$(MAJOR).$(MINOR)')
+AC_SUBST(RUBY_PROGRAM_VERSION, '$(MAJOR).$(MINOR).$(TEENY)')
+
+dnl checks for alternative programs
+AC_CANONICAL_BUILD
+RUBY_RM_RECURSIVE
+AC_ARG_WITH(gcc,
+	AS_HELP_STRING([--without-gcc], [never use gcc]),
+	[
+	AS_CASE([$withval],
+	    [no],  [: ${CC=cc}],
+	    [yes], [: ${CC=gcc}],
+	           [CC=$withval])])
+dnl If the user switches compilers, we can't believe the cache
+AS_IF([test ! -z "$ac_cv_prog_CC" -a ! -z "$CC" -a "$CC" != "$ac_cv_prog_CC"], [
+  AC_MSG_ERROR(cached CC is different -- throw away $cache_file
+(it is also a good idea to do 'make clean' before compiling))
+])
+test -z "$CC" || ac_cv_prog_CC="$CC"
+
+AS_IF([test "$program_prefix" = NONE], [
+  program_prefix=
+])
+AS_IF([test "$prefix" -ef .], [
+  AC_MSG_ERROR(--prefix cannot be the current working directory.)
+])
+RUBY_BASE_NAME=`echo ruby | sed "$program_transform_name"`
+RUBYW_BASE_NAME=`echo rubyw | sed "$program_transform_name"`
+AC_SUBST(RUBY_BASE_NAME)
+AC_SUBST(RUBYW_BASE_NAME)
+AC_SUBST(RUBY_VERSION_NAME, '${RUBY_BASE_NAME}-${ruby_version_dir_name}')
+
+AC_CANONICAL_TARGET
+test x"$target_alias" = x &&
+target_os=`echo $target_os | sed 's/linux-gnu$/linux/;s/linux-gnu/linux-/'`
+ac_install_sh='' # unusable for extension libraries.
+
+AC_ARG_WITH(os-version-style,
+	AS_HELP_STRING([--with-os-version-style=TYPE],
+		       [OS version number for target and target_os [[full]]]
+		       [(full|teeny|minor+0|minor|major+0|major|none)]),
+	[os_version_style=$withval],
+	[os_version_style=full
+	    AS_CASE($target_os, [[*[0-9].*]],
+		[AS_CASE([`/usr/bin/ruby -e 'puts RUBY_PLATFORM' 2>/dev/null`],
+		    [[*-*[0-9].*.0]], [os_version_style=minor+0],
+		    [[*-*[0-9].*.*]], [os_version_style=full],
+		    [[*-*[0-9].0]  ], [os_version_style=major+0],
+		    [[*-*[0-9].*]  ], [os_version_style=minor],
+		    [[*-*[0-9]]    ], [os_version_style=major],
+		)])
+	])
+os_version_style_transform=
+AS_CASE("${os_version_style}",
+	[full|teeny], [],
+	[minor+0], [os_version_style_transform=['s/\([0-9]\.[0-9][0-9]*\)\.[0-9][.0-9]*$/\1.0/']],
+	[minor],   [os_version_style_transform=['s/\([0-9]\.[0-9][0-9]*\)\.[0-9][.0-9]*$/\1/']],
+	[major+0], [os_version_style_transform=['s/\([0-9]\)\.[0-9][.0-9]*$/\1.0/']],
+	[major],   [os_version_style_transform=['s/\([0-9]\)\.[0-9][.0-9]*$/\1/']],
+	[none],    [os_version_style_transform=['s/[0-9]*\.[0-9][.0-9]*$//']],
+	[AC_MSG_ERROR(unknown --with-os-version-style: $withval)])
+AS_IF([test -z "$target_alias" -a -n "$os_version_style_transform"],
+	[
+	target=`echo ${target} | sed "$os_version_style_transform"`
+	target_os=`echo ${target_os} | sed "$os_version_style_transform"`
+	])
+
+AC_ARG_WITH(arch,
+	AS_HELP_STRING([--with-arch=ARCHS],
+		       [build an Apple/NeXT Multi Architecture Binary (MAB);
+                          ARCHS is a comma-delimited list of architectures for
+                          which to build; if this option is disabled or omitted
+			  entirely, then the package will be built only for the
+			  target platform]),
+       [target_archs="$withval"], [unset target_archs])
+
+AC_ARG_ENABLE(load-relative,
+       AS_HELP_STRING([--enable-load-relative], [resolve load paths at run time]),
+       [load_relative=$enableval])
+
+AC_ARG_PROGRAM
+
+# checks for UNIX variants that set C preprocessor variables
+AC_USE_SYSTEM_EXTENSIONS
+
+dnl Checks for programs.
+
+cflagspat=
+test -z "$optflags" ||
+    cflagspat="$cflagspat;s|"`eval echo '"'"${optflags}"'"' | sed 's/[[][|.*]]/\\&/g;s/^ */ /;s/ *$/ /'`'| |g'
+test -z "$debugflags" ||
+    cflagspat="$cflagspat;s|"`eval echo '"'"${debugflags}"'"' | sed 's/[[][|.*]]/\\&/g;s/^ */ /;s/ *$/ /'`'| |g'
+test -z "$warnflags" ||
+    cflagspat="$cflagspat;s|"`eval echo '"'"${warnflags}"'"' | sed 's/[[][|.*]]/\\&/g;s/^ */ /;s/ *$/ /'`'| |g'
+AS_IF([test -z "${CFLAGS+set}"], [
+    cflags=`echo " $cflags " | sed "$cflagspat;s/^ *//;s/ *$//"`
+    orig_cflags="$cflags"
+    cflags="$cflags "'${optflags} ${debugflags} ${warnflags}'
+])
+dnl AS_IF([test -z "${CXXFLAGS+set}"], [
+dnl     cxxflags=`echo " $cxxflags " | sed "$cflagspat;s/^ *//;s/ *$//"`
+dnl     orig_cxxflags="$cxxflags"
+dnl     cxxflags="$cxxflags "'${optflags} ${debugflags} ${warnflags}'
+dnl ])
+
+AS_CASE(["$host_os:$build_os"],
+[darwin*:darwin*], [
+    AC_CHECK_TOOLS(CC, [clang gcc cc])
+    # Following Apple deployed clang are broken
+    # clang version 1.0 (http://llvm.org/svn/llvm-project/cfe/tags/Apple/clang-23 exported)
+    # Apple clang version 2.0 (tags/Apple/clang-137) (based on LLVM 2.9svn)
+    # Apple clang version 2.1 (tags/Apple/clang-163.7.1) (based on LLVM 3.0svn)
+    AC_PREPROC_IFELSE(
+	[AC_LANG_PROGRAM([
+	    @%:@if defined __APPLE_CC__ && defined __clang_major__ && __clang_major__ < 3
+	    @%:@error premature clang
+	    @%:@endif
+	])],
+	[],
+	[AC_MSG_ERROR([clang version 3.0 or later is required])
+    ])],
+[openbsd*:openbsd*], [
+    AC_CHECK_TOOLS(CC, [cc])
+])
+AS_IF([test x"${build}" != x"${host}"], [
+  AC_CHECK_TOOL(CC, gcc)
+])
+
+dnl Seems necessarily in order to add -std=gnu99 option for gcc 4.9.
+m4_version_prereq([2.70], [], [AC_PROG_CC_C99])
+
+AS_CASE([$CC],
+[gcc-*], [
+    gcc_prefix=gcc- gcc_suffix=`echo "$CC" | sed 's/^gcc//'`
+    AC_PROG_CXX(g++${gcc_suffix})],
+[clang-*|clang], [
+    gcc_prefix=clang- gcc_suffix=`echo "$CC" | sed 's/^clang//'`
+    AC_PROG_CXX(clang++${gcc_suffix})],
+[gcc_prefix= gcc_suffix=])
+
+dnl Select the appropriate C++ compiler in OS X
+AS_CASE(["$build_os:${CXX}"],
+    [darwin1*.*:], [
+        AC_MSG_CHECKING([CXX for $CC])
+        AS_CASE(["/$CC "],
+            [*@<:@\ /@:>@"gcc-4.2 "*], [pat='gcc-4\.2' CXX=g++-4.2],
+            [*@<:@\ /@:>@"gcc "*],     [pat=gcc CXX=g++],
+            [*@<:@\ /@:>@"cc "*],      [pat=cc CXX=c++],
+            [*@<:@\ /@:>@"icc "*],     [pat=icc CXX=icpc],
+            [*@<:@\ /@:>@"clang "*],   [pat=clang CXX=clang++])
+        AS_IF([test "${CXX}"], [
+            CXX=`echo "/$CC " | sed ["s:\([ /]\)${pat}:\1$CXX:; s:^/::; s: *$::"]`
+        ])
+        AC_MSG_RESULT([$CXX])],
+    [openbsd*:*], [
+        AC_CHECK_TOOLS(CXX, [c++])
+    ])
+test -z "$CXX" || ac_cv_prog_CXX="$CXX"
+
+AS_CASE(["$target_os"],
+[darwin*], [
+    AC_MSG_CHECKING(if minimum required OS X version is supported)
+    AC_PREPROC_IFELSE([AC_LANG_SOURCE([[@%:@include <AvailabilityMacros.h>
+	@%:@if MAC_OS_X_VERSION_MIN_REQUIRED < __MAC_10_5
+	@%:@error pre OS X 10.5
+	[!<===== pre OS X 10.5 =====>]
+	@%:@endif
+	]])],
+	[macosx_min_required=yes],
+	[AC_MSG_RESULT(no)
+	AC_MSG_ERROR([Unsupported OS X version is required])])
+    AC_MSG_RESULT(${macosx_min_required})
+])
+
+AC_PROG_CXX
+RUBY_MINGW32
+AC_PROG_GCC_TRADITIONAL
+AC_SUBST(GCC)
+AS_CASE(["$target_os"],
+[solaris*], [AC_PATH_TOOL([LD], [ld], [/usr/ccs/bin/ld], [/usr/ccs/bin:$PATH])],
+[AC_CHECK_TOOL([LD], [ld], [ld])])
+AC_SUBST(LD)
+AS_IF([test "$GCC" = yes], [
+    linker_flag=-Wl,
+    : ${optflags=-O3}
+    gcc_major=`echo =__GNUC__ | $CC -E -xc - | sed '/^=/!d;s///'`
+    gcc_minor=`echo =__GNUC_MINOR__ | $CC -E -xc - | sed '/^=/!d;s///'`
+    test -n "$gcc_major" || gcc_major=0
+    test -n "$gcc_minor" || gcc_minor=0
+    icc_version=`echo =__ICC | $CC -E -xc - | sed '/^=/!d;s///;/^__ICC/d'`
+    test -n "$icc_version" || icc_version=0
+    # RUBY_APPEND_OPTIONS(XCFLAGS, ["-include ruby/config.h" "-include ruby/missing.h"])
+], [
+    linker_flag=
+])
+
+AS_IF([test "$GCC" = yes -a "$gcc_major" -lt 3 ], [
+    AC_MSG_ERROR([too old GCC])
+])
+
+RUBY_PROG_GNU_LD
+RUBY_CPPOUTFILE
+
+: ${OUTFLAG='-o '}
+: ${COUTFLAG=${OUTFLAG}}
+: ${CSRCFLAG=''}
+AC_SUBST(OUTFLAG)
+AC_SUBST(COUTFLAG)
+AC_SUBST(CSRCFLAG)
+
+: ${MJIT_CC=$CC}
+AS_IF([test "x$cross_compiling" = xno], [
+    AC_PATH_PROG([MJIT_CC], ${MJIT_CC})
+    AS_CASE([$target_os],
+	[*mingw*], [command -v cygpath > /dev/null && MJIT_CC=`cygpath -ma $MJIT_CC`])
+    shift 2
+    MJIT_CC="$MJIT_CC${1+ }$*"
+])
+
+AS_CASE(["$build_os"],
+  [darwin1*.*], [
+    # Xcode linker warns for deprecated architecture and wrongly
+    # installed TBD files.
+    CC_WRAPPER=""
+    echo 'int main(void) {return 0;}' > conftest.c
+    AS_IF([$CC -framework Foundation -o conftest conftest.c 2>&1 |
+	   grep '^ld: warning: text-based stub file' >/dev/null], [
+	CC_WRAPPER=`cd -P "$srcdir/tool" && pwd`/darwin-cc
+	CC="$CC_WRAPPER $CC"
+    ])
+    rm -fr conftest*
+  ])
+
+cc_version=
+for option in --version -v -V -qversion; do
+    cc_version_message=`$CC $option 2>&1`
+    cc_version_status=$?
+    AS_CASE($cc_version_status, [0], [:], [continue])
+    AS_CASE($cc_version_message, [*Warning*], [continue])
+    cc_version='$(CC) '$option
+    break
+done
+AC_SUBST(CC_VERSION, $cc_version)
+AC_SUBST(CC_VERSION_MESSAGE, $cc_version_message)
+
+: ${DLDFLAGS="$LDFLAGS"}
+
+RUBY_UNIVERSAL_ARCH
+AS_IF([test "$target_cpu" != "$host_cpu" -a "$GCC" = yes -a "$cross_compiling" = no -a "${universal_binary:-no}" = no], [
+    RUBY_DEFAULT_ARCH("$target_cpu")
+])
+host_os=$target_os
+host_vendor=$target_vendor
+host_cpu=$target_cpu
+host=$target
+host_alias=$target_alias
+
+AS_CASE(["$target_os"], [darwin*], [
+if libtool 2>&1 | grep no_warning_for_no_symbols > /dev/null; then
+  ac_cv_prog_ac_ct_RANLIB=:
+  ac_cv_prog_ac_ct_AR='libtool -static'
+  rb_cv_arflags='-no_warning_for_no_symbols -o'
+fi
+])
+AC_CHECK_TOOLS(RANLIB, [${gcc_prefix}ranlib${gcc_suffix} ranlib], :)
+AC_CHECK_TOOLS(AR, [${gcc_prefix}ar${gcc_suffix} ar])
+AS_IF([test -z "$AR"], [
+  AC_CHECK_PROGS(AR, aal, ar)
+])
+AC_CACHE_CHECK([for $AR flags], [rb_cv_arflags], [
+    AS_IF([$AR rcD conftest.a > /dev/null 2>&1 && rm conftest.a],
+	[rb_cv_arflags=rcD], [rb_cv_arflags=rcu])
+])
+AC_SUBST(ARFLAGS, ["$rb_cv_arflags "])
+
+AC_CHECK_TOOL(AS, as)
+ASFLAGS=$ASFLAGS
+AC_SUBST(ASFLAGS)
+
+AS_CASE(["$target_os"],[cygwin*|mingw*], [ac_cv_prog_ac_ct_OBJCOPY=":"])
+
+# BSD's ports and MacPorts prefix GNU binutils with 'g'
+AC_CHECK_TOOLS(OBJDUMP, [objdump gobjdump])
+AC_CHECK_TOOLS(OBJCOPY, [objcopy gobjcopy])
+
+AS_CASE(["$target_os"],
+[cygwin*|mingw*], [
+    AC_CHECK_TOOL(WINDRES, windres)
+    AC_CHECK_TOOL(DLLWRAP, dllwrap)
+    target=`echo $target | sed "s/^$target_cpu-/-/"`
+    target_alias=`echo $target_alias | sed "s/^$target_cpu-/-/"`
+    target_cpu=`echo $target_cpu | sed s/i.86/i386/`
+    AS_CASE(["$target"], [-*], [ target="$target_cpu${target}"])
+    AS_CASE(["$target_alias"], [-*], [ target_alias="$target_cpu${target_alias}"])
+    AS_CASE(["$target_os"],
+    [mingw*], [
+	test "$rb_cv_msvcrt" = "" && unset rb_cv_msvcrt
+	AC_CACHE_CHECK(for mingw32 runtime DLL, rb_cv_msvcrt, [
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[@%:@include <stdio.h>]],
+		    [[FILE* volatile f = stdin; return 0;]])],
+		    [rb_cv_msvcrt=`$OBJDUMP -p conftest$ac_exeext |
+				   tr A-Z a-z |
+				   sed -n '/^[[ 	]]*dll name: \(msvc.*\)\.dll$/{s//\1/p;q;}'`],
+		    [rb_cv_msvcrt=msvcrt])
+	test "$rb_cv_msvcrt" = "" && rb_cv_msvcrt=msvcrt])
+	RT_VER=`echo "$rb_cv_msvcrt" | tr -cd [0-9]`
+	test "$RT_VER" = "" && RT_VER=60
+	AC_DEFINE_UNQUOTED(RUBY_MSVCRT_VERSION, $RT_VER)
+	sysconfdir=
+    ])
+    : ${enable_shared=yes}
+    ],
+[aix*],     [AC_CHECK_TOOL(NM, nm, /usr/ccs/bin/nm, /usr/ccs/bin:$PATH)],
+[hiuxmpp*], [AC_DEFINE(__HIUX_MPP__)])    # by TOYODA Eizi <toyoda@npd.kishou.go.jp>
+AC_CHECK_TOOLS(NM, [${gcc_prefix}nm${gcc_suffix} nm])
+
+AC_PROG_LN_S
+AC_PROG_MAKE_SET
+AC_PROG_INSTALL
+AC_PROG_MKDIR_P
+AS_IF([test "x$MKDIR_P" = "x -d"], [
+  AS_IF([test x"$as_mkdir_p" != xfalse], [
+    MKDIR_P='mkdir -p'
+    echo "use 'mkdir -p' as MKDIR_P"
+  ], [
+    AC_MSG_ERROR([mkdir -p is required])
+  ])
+])
+MAKEDIRS="$MKDIR_P"
+AC_SUBST(MAKEDIRS)
+
+AC_CHECK_PROG([DTRACE], [${ac_tool_prefix}dtrace], [${ac_tool_prefix}dtrace])
+AS_IF([test "$cross_compiling:$ac_cv_prog_DTRACE" = no: -a -n "$ac_tool_prefix"], [
+    AC_CHECK_PROG([DTRACE], [dtrace], [dtrace])
+])
+
+AC_CHECK_PROGS(DOT, dot)
+AC_CHECK_PROGS(DOXYGEN, doxygen)
+
+AC_CHECK_PROG(PKG_CONFIG, pkg-config, [pkg-config], [], [],
+    [`"$as_dir/$ac_word$ac_exec_ext" --print-errors --version > /dev/null 2>&1 || echo "$as_dir/$ac_word$ac_exec_ext"`])
+
+AC_SUBST(RM, ['rm -f'])
+AC_SUBST(CP, ['cp'])
+RMDIRS='$(top_srcdir)/tool/rmdirs'
+RMDIR=rmdir
+mkdir "rmdirs_$$_test" "rmdirs_$$_test/a"
+rmdir --ignore-fail-on-non-empty "rmdirs_$$_test" 2>/dev/null &&
+RMDIR='rmdir --ignore-fail-on-non-empty'
+$RMDIR -p "rmdirs_$$_test/a" 2>/dev/null &&
+{ test -d "rmdirs_$$_test" || RMDIRS="$RMDIR -p"; }
+rmdir "rmdirs_$$_test/a" "rmdirs_$$_test" 2>/dev/null
+AC_SUBST(RMDIR)
+AC_SUBST(RMDIRS)
+AC_SUBST(RMALL, ['rm -fr'])
+
+AC_MSG_CHECKING([for cd using physical directory])
+rm -fr conf$$.dir
+mkdir conf$$.dir &&
+(cd conf$$.dir && mkdir src build && cd src &&
+$as_ln_s ../build . > /dev/null 2>&1 && cd build &&
+for chdir in 'cd -P' 'PWD= cd'; do
+    /bin/sh -c "$chdir ../src && echo '$chdir' > cdcmd" 2> /dev/null && break
+done)
+AS_IF([test -f conf$$.dir/src/cdcmd], [
+    read CHDIR < conf$$.dir/src/cdcmd 2> /dev/null
+], [
+    CHDIR=cd
+])
+rm -fr conf$$.dir
+AC_MSG_RESULT([$CHDIR])
+AC_SUBST(CHDIR)
+}
+
+: "compiler section" && {
+RUBY_WERROR_FLAG([
+    AC_MSG_CHECKING([whether CFLAGS is valid])
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]], [[]])],
+	[AC_MSG_RESULT(yes)],
+	[
+	AC_MSG_RESULT(no)
+	AC_MSG_ERROR([something wrong with CFLAGS="$CFLAGS"])
+	]
+    )
+
+    AC_MSG_CHECKING([whether LDFLAGS is valid])
+    {
+	mkdir tmp.$$.try_link &&
+	cd tmp.$$.try_link &&
+	cp ../confdefs.h . &&
+	echo '<?xml?><plist><dict><key>CFBundleIdentifier</key><string></string></dict></plist>' > Info.plist &&
+	:
+    } || AC_MSG_ERROR([failed to make temporary directory])
+    AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],
+	[AC_MSG_RESULT(yes)],
+	[
+	cd .. && rm -fr tmp.$$.try_link
+	AC_MSG_RESULT(no)
+	AC_MSG_ERROR([something wrong with LDFLAGS="$LDFLAGS"])
+	]
+    )
+    cd .. && rm -fr tmp.$$.try_link
+])
+
+: ${RPATHFLAG=''}
+rpathflag=''
+AS_IF([test x"${RPATHFLAG}" = x], [
+    AS_CASE(["$target_os"],
+	[hpux*], [AS_IF([test "$rb_cv_prog_gnu_ld" = no], [rpathflag='+b '])],
+	[aix*], [rpathflag='-blibpath:'],
+	[for rpathflag in -R "-rpath "; do
+	    AS_CASE("$rpathflag",
+		    [*" "], [AS_CASE(["${linker_flag}"],
+				     [*,], [rpathflag=`echo "$rpathflag" | tr ' ' ,`])])
+	    rpathflag="${linker_flag}${rpathflag}"
+	    RUBY_TRY_LDFLAGS([${rpathflag}.], [], [rpathflag=])
+	    AS_IF([test "x${rpathflag}" != x], [])
+        done])
+], [
+    rpathflag=`echo "$RPATHFLAG" | sed 's/%.*//'`
+])
+
+AS_CASE([$RUBY_PATCHLEVEL], [-*],
+	[RUBY_DEVEL=yes], [RUBY_DEVEL=no])
+particular_werror_flags=$RUBY_DEVEL
+AC_ARG_ENABLE(werror,
+	AS_HELP_STRING([--disable-werror],
+		       [don't make warnings into errors
+		       even if a compiler support -Werror feature
+		       [[disabled by default unless development version]]]),
+	[particular_werror_flags=$enableval])
+
+rb_cv_warnflags="$warnflags"
+AS_CASE(["$GCC:${warnflags+set}:${extra_warnflags:+set}:"],
+[yes::*|yes:*:set:], [# GCC && (!warnflags || extra_warnflags)
+    AS_IF([test $gcc_major -ge 4], [
+	extra_warnflags="$extra_warnflags -Werror=extra-tokens"
+    ])
+    AS_IF([test $gcc_major -ge 5 -a $gcc_major -le 6], [
+	extra_warnflags="$extra_warnflags -Wno-maybe-uninitialized"
+    ])
+    # ICC doesn't support -Werror=
+    AS_IF([test $icc_version -gt 0], [
+	particular_werror_flags=no
+    ])
+    for wflag in \
+		 -Werror=deprecated-declarations \
+		 -Werror=division-by-zero \
+		 -Werror=duplicated-cond \
+		 -Werror=implicit-function-declaration \
+		 -Werror=implicit-int \
+		 -Werror=misleading-indentation \
+		 -Werror=pointer-arith \
+		 -Werror=shorten-64-to-32 \
+		 -Werror=write-strings \
+		 -Wimplicit-fallthrough=0 \
+		 -Wmissing-noreturn \
+		 -Wno-cast-function-type \
+		 -Wno-constant-logical-operand \
+		 -Wno-long-long \
+		 -Wno-missing-field-initializers \
+		 -Wno-overlength-strings \
+		 -Wno-packed-bitfield-compat \
+		 -Wno-parentheses-equality \
+		 -Wno-self-assign \
+		 -Wno-tautological-compare \
+		 -Wno-unused-parameter \
+		 -Wno-unused-value \
+		 -Wsuggest-attribute=format \
+		 -Wsuggest-attribute=noreturn \
+		 -Wunused-variable \
+		 -diag-disable=175,188,1684,2259,2312 \
+		 $extra_warnflags \
+		 ; do
+	AS_IF([test "$particular_werror_flags" != yes], [
+	    wflag=`echo x$wflag | sed 's/^x-Werror=/-W/;s/^x//'`
+	])
+	ok=no
+	RUBY_TRY_CFLAGS($wflag, [
+	    RUBY_APPEND_OPTIONS(warnflags, $wflag)
+	    ok=yes
+	])
+	AS_CASE([$ok:$wflag], [no:-Werror=*], [
+	    wflag=`echo x$wflag | sed 's/^x-Werror=/-W/'`
+	    RUBY_TRY_CFLAGS($wflag, [
+		RUBY_APPEND_OPTIONS(warnflags, $wflag)
+		particular_werror_flags=no
+	    ])
+	])
+    done
+    AS_CASE([" $warnflags "],[*" -Wno-missing-field-initializers "*], [wflag="-Wall -Wextra"],
+                             [wflag=-Wall])
+    RUBY_TRY_CFLAGS($wflag, [warnflags="$wflag${warnflags+ $warnflags}"])
+    # Disable warnflags while conftest. -Werror=* flags might make bad OS capability guess.
+    rb_cv_warnflags="$warnflags"
+    warnflags=
+])
+RUBY_TRY_CFLAGS(-Qunused-arguments, [RUBY_APPEND_OPTIONS(rb_cv_wsuppress_flags, -Qunused-arguments)])
+
+AC_ARG_WITH(compress-debug-sections,
+	AS_HELP_STRING([--with-compress-debug-sections=type],
+	    [enable debug section compression]),
+	[compress_debug_sections=$withval], [compress_debug_sections=])
+
+AS_IF([test "$GCC" = yes], [
+    # -D_FORTIFY_SOURCE
+    # When defined _FORTIFY_SOURCE, glibc enables some additional sanity
+    # argument check. The performance drop is very little and Ubuntu enables
+    # _FORTIFY_SOURCE=2 by default. So, let's support it for protecting us from
+    # a mistake of silly C extensions.
+
+    # TODO: check if link succeeds with _FORTIFY_SOURCE=2.
+    AS_CASE(["$target_os"],
+    [mingw*], [
+	fortify_source=no
+    ])
+    AC_ARG_ENABLE(fortify_source,
+		  AS_HELP_STRING([--disable-fortify-source],
+				 [disable -D_FORTIFY_SOURCE=2 option, which causes link error on mingw]),
+		  [fortify_source=$enableval])
+    AS_IF([test "x$fortify_source" != xno], [
+    RUBY_TRY_CFLAGS(-D_FORTIFY_SOURCE=2, [RUBY_APPEND_OPTION(XCFLAGS, -D_FORTIFY_SOURCE=2)])
+    ])
+
+    : ${MJIT_HEADER_FLAGS='-P -dD'}
+
+    # -fstack-protector
+    AS_CASE(["$target_os"],
+    [mingw*], [
+	stack_protector=no
+    ])
+    AS_IF([test -z "${stack_protector+set}"], [
+	AS_FOR(option, opt, [-fstack-protector-strong -fstack-protector], [
+	    RUBY_TRY_CFLAGS(option, [stack_protector=yes])
+	    AS_IF([test "x$stack_protector" = xyes], [
+		RUBY_TRY_LDFLAGS(option, [], [stack_protector=])
+	    ])
+	    AS_IF([test "x$stack_protector" = xyes], [stack_protector=option; break])
+	])
+    ])
+    AS_CASE(["$stack_protector"], [-*], [
+	RUBY_APPEND_OPTION(XCFLAGS, $stack_protector)
+	RUBY_APPEND_OPTION(XLDFLAGS, $stack_protector)
+	RUBY_APPEND_OPTION(LDFLAGS, $stack_protector)
+    ])
+
+    AS_CASE("${compress_debug_sections:-zlib}",
+    [none|no], [], [
+    RUBY_TRY_LDFLAGS(${linker_flag}--compress-debug-sections=${compress_debug_sections:-zlib},
+		     [compress_debug_sections=${compress_debug_sections:-zlib}],
+		     [compress_debug_sections=no])
+    ])
+    AS_IF([test "x$compress_debug_sections" != xno], [
+	RUBY_APPEND_OPTION(DLDFLAGS, ${linker_flag}--compress-debug-sections=$compress_debug_sections)
+    ])
+
+    AS_CASE(["$target_os"],[mingw*], [
+      # On  Windows  platforms,   system  provided  headers  are  VC++
+      # optimized.  That  is, C++  habits are often  contaminated into
+      # various  headers.  Most frequent  situation is  the use  of //
+      # comments.   We  bypass  ANSI   C  mode  for  them.   Otherwise
+      # extension libs cannot include those headers.
+
+      # Since math.h in some mingw64 wrongly declares frexp and modf
+      # to be pure, the variables pointed by the second arguments are
+      # considered uninitialized unexpectedly.
+      AC_CACHE_CHECK([whether frexp and modf are broken],
+	rb_cv_mingw64_broken_frexp_modf,
+	[
+	  save_CFLAGS="$CFLAGS"
+	  AS_IF([test "$particular_werror_flags" = "yes"], [
+	    CFLAGS="$CFLAGS -Werror=uninitialized"
+	  ], [
+	    CFLAGS="$CFLAGS -Werror -Wuninitialized"
+	  ])
+	  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <math.h>
+	    int foo(double x)
+	    {
+	      int exp;
+	      frexp(x, &exp);
+	      return exp;
+	    }]], [[if (foo(0.0)) return 1;]])],
+	    [rb_cv_mingw64_broken_frexp_modf=no],
+	    [rb_cv_mingw64_broken_frexp_modf=yes])
+	  CFLAGS="$save_CFLAGS"
+	])
+      AS_IF([test "$rb_cv_mingw64_broken_frexp_modf" = yes], [
+	AC_DEFINE(RUBY_MINGW64_BROKEN_FREXP_MODF)
+      ])
+    ],
+    [cygwin*|darwin*|netbsd*], [
+      # need lgamma_r(), finite()
+    ])
+
+    # ANSI (no XCFLAGS because this is C only)
+    AS_CASE(["$target_os"],
+    [solaris*], [
+      # Because "-std=gnu99" affects existence of functions on Solaris,
+      # "-std=gnu99" will be appended to CPPFLAGS.
+	for ansi_options in -std=gnu99; do
+	    RUBY_TRY_CFLAGS(${ansi_options}, [
+		RUBY_APPEND_OPTIONS(CPPFLAGS, ${ansi_options})
+	    ], [ansi_options=])
+	    test "x${ansi_options}" = x || break
+	done
+    ],
+    [
+      # ANSI (no XCFLAGS because this is C only)
+      rb_tmp_std_check=`echo $CC $CFLAGS $optflags $warnflags $debugflags | fgrep std= | tr -d  '\015'`
+      AS_IF([test "x$rb_tmp_std_check" = "x"],
+      [
+	for ansi_options in -std=gnu99; do
+	    RUBY_TRY_CFLAGS(${ansi_options}, [
+		RUBY_APPEND_OPTIONS(warnflags, ${ansi_options})
+		RUBY_APPEND_OPTIONS(strict_warnflags, ${ansi_options})
+	    ], [ansi_options=])
+	    test "x${ansi_options}" = x || break
+	done
+      ])
+    ])
+
+    # suppress annoying -Wstrict-overflow warnings
+    RUBY_TRY_CFLAGS(-fno-strict-overflow, [RUBY_APPEND_OPTION(XCFLAGS, -fno-strict-overflow)])
+
+    test "${debugflags+set}" || {RUBY_TRY_CFLAGS(-ggdb3, [debugflags=-ggdb3])}
+    test "${debugflags+set}" || {RUBY_TRY_CFLAGS(-ggdb, [debugflags=-ggdb])}
+    test "${debugflags+set}" || {RUBY_TRY_CFLAGS(-g3, [debugflags=-g3])}
+])
+test $ac_cv_prog_cc_g = yes && : ${debugflags=-g}
+AS_IF([test "x$RUBY_DEVEL" = xyes], [RUBY_APPEND_OPTION(XCFLAGS, -DRUBY_DEVEL=1)])
+
+AS_IF([test "$GCC" = ""], [
+    AS_CASE(["$target_os"],[aix*],[warnflags="$warnflags -qinfo=por" rb_cv_warnflags="$rb_cv_warnflags -qinfo=por"])
+])
+AS_IF([test "$GCC" = yes], [
+    AS_IF([test "$gcc_major" -ge 4], [
+	RUBY_TRY_CFLAGS(-fvisibility=hidden, [visibility_option=yes], [visibility_option=no])
+    ])
+    AC_SUBST(WERRORFLAG, "-Werror")
+    AS_IF([test "$visibility_option" = yes], [
+	RUBY_APPEND_OPTION(XCFLAGS, -fvisibility=hidden)
+	AC_DEFINE(RUBY_SYMBOL_EXPORT_BEGIN, [_Pragma("GCC visibility push(default)")])
+	AC_DEFINE(RUBY_SYMBOL_EXPORT_END,   [_Pragma("GCC visibility pop")])
+    ], [
+	RUBY_TRY_LDFLAGS([-Wl,-unexported_symbol,_Init_*], [visibility_option=ld], [visibility_option=no])
+    ])
+    test "$visibility_option" = no || OBJCOPY=:
+])
+
+AS_IF([test "$GCC" = yes], [
+    # optflags
+
+    AS_CASE(["$target_os"], [mingw*], [
+	RUBY_TRY_CFLAGS(-fno-omit-frame-pointer, [optflags="${optflags+$optflags }-fno-omit-frame-pointer"])
+	RUBY_TRY_CFLAGS(-static-libgcc, [static_libgcc=yes], [static_libgcc=no])
+	AS_IF([test "$static_libgcc" = yes], [
+	    RUBY_APPEND_OPTION(EXTLDFLAGS, -static-libgcc)
+	])
+    ])
+
+    # disable fast-math
+    for oflag in -fno-fast-math; do
+	RUBY_TRY_CFLAGS($oflag, [RUBY_APPEND_OPTION(CFLAGS, $oflag)])
+    done
+    for oflag in -fexcess-precision=standard -fp-model\ precise; do
+	RUBY_TRY_CFLAGS($oflag, [RUBY_APPEND_OPTION(XCFLAGS, $oflag)])
+    done
+])
+
+AS_CASE(["$target_cpu"], [[i[3-6]86*]], [
+    AC_CACHE_CHECK([for __sync_val_compare_and_swap], [rb_cv_gcc_compiler_cas], [
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[unsigned long atomic_var;]],
+	    [[__sync_val_compare_and_swap(&atomic_var, 0, 1);]])],
+	    [rb_cv_gcc_compiler_cas=yes],
+	    [
+	    save_CFLAGS="$CFLAGS" CFLAGS="$CFLAGS -march=i486"
+	    AC_LINK_IFELSE([AC_LANG_PROGRAM([[unsigned long atomic_var;]],
+		[[__sync_val_compare_and_swap(&atomic_var, 0, 1);]])],
+		[rb_cv_gcc_compiler_cas=i486],
+		[rb_cv_gcc_compiler_cas=no])
+	    CFLAGS="$save_CFLAGS"
+	    ])
+    ])
+    AS_IF([test "$rb_cv_gcc_compiler_cas" = i486], [ARCH_FLAG="-march=i486"])
+])
+
+AC_ARG_WITH(opt-dir,
+	AS_HELP_STRING([--with-opt-dir=DIR-LIST],
+		       [add optional headers and libraries directories separated by $PATH_SEPARATOR]),
+	[
+		val=`echo "$PATH_SEPARATOR$withval" | sed "s|$PATH_SEPARATOR\([[^$PATH_SEPARATOR]*]\)| -I\1/include|g;s/^ //"`
+		CPPFLAGS="$CPPFLAGS $val"
+		val=`echo "$PATH_SEPARATOR$withval" | sed "s|$PATH_SEPARATOR\([[^$PATH_SEPARATOR]*]\)| -L\1/lib${rpathflag:+ $rpathflag\\\\1/lib}|g;s/^ //"`
+		LDFLAGS="$LDFLAGS $val"
+		LDFLAGS_OPTDIR="$val"
+		OPT_DIR="$withval"
+	], [OPT_DIR=])
+
+test -z "${ac_env_CFLAGS_set}" -a -n "${cflags+set}" && eval CFLAGS="\"$cflags $ARCH_FLAG\""
+test -z "${ac_env_CXXFLAGS_set}" -a -n "${cxxflags+set}" && eval CXXFLAGS="\"$cxxflags $ARCH_FLAG\""
+}
+
+AC_CACHE_CHECK([whether compiler has statement and declarations in expressions],
+  rb_cv_have_stmt_and_decl_in_expr,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[]],[[ __extension__ ({ int a = 0; a; }); ]])],
+  [rb_cv_have_stmt_and_decl_in_expr=yes],
+  [rb_cv_have_stmt_and_decl_in_expr=no])])
+AS_IF([test "$rb_cv_have_stmt_and_decl_in_expr" = yes], [
+  AC_DEFINE(HAVE_STMT_AND_DECL_IN_EXPR)
+])
+
+: "header and library section" && {
+AC_ARG_WITH(winnt-ver,
+  AS_HELP_STRING([--with-winnt-ver=0xXXXX], [target Windows NT version (default to 0x0600)]),
+  [with_winnt_ver="$withval"], [with_winnt_ver="0x0600"])
+AS_CASE(["$target_os"],
+[mingw*], [
+  RUBY_APPEND_OPTION(CPPFLAGS, -D_WIN32_WINNT=$with_winnt_ver)
+  RUBY_APPEND_OPTION(CPPFLAGS, -D__MINGW_USE_VC2005_COMPAT)
+])
+
+AS_CASE(["$target_os"],
+[freebsd*], [
+  AC_CACHE_CHECK([whether pthread should be enabled by default],
+    rb_cv_enable_pthread_default,
+    [AC_PREPROC_IFELSE([AC_LANG_SOURCE([[
+#include <osreldate.h>
+#if __FreeBSD_version < 502102
+#error pthread should be disabled on this platform
+#endif
+      ]])],
+      rb_cv_enable_pthread_default=yes,
+      rb_cv_enable_pthread_default=no)])
+  enable_pthread=$rb_cv_enable_pthread_default
+  ],
+[mingw*], [
+  enable_pthread=no
+  ],
+[
+  enable_pthread=yes
+  ])
+
+dnl Checks for libraries.
+AS_CASE(["$target_os"],[*bsd*|dragonfly*],[],[ac_cv_func_daemon=no])
+
+AS_UNSET(ORIG_LIBS)
+POSTLINK=:
+AC_SUBST(POSTLINK)
+AS_CASE(["$target_os"],
+[nextstep*], [	],
+[openstep*], [	],
+[rhapsody*], [	],
+[darwin*], [
+		ORIG_LIBS="$LIBS"
+		RUBY_PREPEND_OPTION(LIBS, -lobjc)
+		RUBY_APPEND_OPTIONS(CPPFLAGS, -D_XOPEN_SOURCE -D_DARWIN_C_SOURCE -D_DARWIN_UNLIMITED_SELECT -D_REENTRANT)
+		AC_CACHE_CHECK([whether syscall(2) is deprecated], rb_cv_syscall_deprecated,
+		    [RUBY_WERROR_FLAG([
+			AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <unistd.h>]],
+							   [[if (syscall(0)) return 1;]])],
+			    [rb_cv_syscall_deprecated=no],
+			    [rb_cv_syscall_deprecated=yes])])])
+		AS_IF([test $rb_cv_syscall_deprecated = yes], [
+		    ac_cv_func___syscall=no
+		    ac_cv_func_syscall=no
+		    ac_cv_header_sys_syscall_h=no
+		    ac_cv_header_syscall_h=no
+		])
+		ac_cv_func_getcontext=no
+		ac_cv_func_setcontext=no
+		incs=`$CC -v -E -xc - < /dev/null 2>&1 | sed ['1,/^@%:@include </d;s/^ *//;s|[^./][^/]*/\.\./||g;/\/include$/!d;s||/lib|;/\/usr\/lib/d']`
+		for d in `$CC -print-search-dirs | sed -e '/^libraries: */!d;s///' | tr : '\012' | fgrep -v /../ | sed -n 's|^\(/.*/lib\)/$|\1|p'`; do
+		    incs=`echo "$incs" | fgrep -v "$d"`
+		done
+		for d in $incs; do
+		    test -d "$d" && RUBY_APPEND_OPTIONS(LDFLAGS, "-L$d")
+		done
+		ac_cv_type_getgroups=gid_t # getgroups() on Rosetta fills garbage
+		ac_cv_lib_crypt_crypt=no
+		ac_cv_func_fdatasync=no # Mac OS X wrongly reports it has fdatasync()
+		ac_cv_func_vfork=no
+		AS_IF([test $gcc_major -lt 4 -o \( $gcc_major -eq 4 -a $gcc_minor -lt 3 \)], [
+		    ac_cv_func___builtin_setjmp=no
+		])
+		with_setjmp_type=sigsetjmp # to hijack SIGCHLD handler
+		AC_CACHE_CHECK(for broken crypt with 8bit chars, rb_cv_broken_crypt,
+		    [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+
+void
+broken_crypt(const char *salt, const char *buf1, const char *buf2)
+{
+#if 0
+    printf("%.2x%.2x: %s -> %s\n", (unsigned char)salt[0], (unsigned char)salt[1],
+	   buf1+2, buf2+2);
+#endif
+}
+
+int
+main()
+{
+    int i;
+    char salt[2], buf[256], *s;
+    for (i = 0; i < 128*128; i++) {
+	salt[0] = 0x80 | (i & 0x7f);
+	salt[1] = 0x80 | (i >> 7);
+	strcpy(buf, crypt("", salt));
+	if (strcmp(buf, s = crypt("", salt))) {
+	    broken_crypt(salt, buf, s);
+	    return 1;
+	}
+    }
+    salt[0] = salt[1] = ' ';
+    strcpy(buf, crypt("", salt));
+    salt[0] = salt[1] = 0x80 | ' ';
+    if (strcmp(buf, s = crypt("", salt))) {
+	broken_crypt(salt, buf, s);
+	return 1;
+    }
+    return 0;
+}
+]])],
+		    rb_cv_broken_crypt=no,
+		    rb_cv_broken_crypt=yes,
+		    rb_cv_broken_crypt=yes)])
+		AS_IF([test "$rb_cv_broken_crypt" = yes], [
+		   AC_DEFINE(BROKEN_CRYPT, 1)
+		])
+		POSTLINK=""
+		AC_CHECK_PROGS(codesign, codesign)
+		AC_CHECK_PROGS(dsymutil, dsymutil)
+		AS_IF([test -n "$codesign"], [
+		    POSTLINK="{ test -z '\$(RUBY_CODESIGN)' || $codesign -s '\$(RUBY_CODESIGN)' -f \$@; }${POSTLINK:+; $POSTLINK}"
+		])
+		AS_IF([test -n "$dsymutil"], [
+		    POSTLINK="$dsymutil \$@${POSTLINK:+; $POSTLINK}"
+		])
+		AS_IF([test -n "${POSTLINK}"], [
+		    LINK_SO="$LINK_SO
+\$(POSTLINK)"
+		])
+		AC_CHECK_HEADERS(crt_externs.h, [], [], [
+		    #include <crt_externs.h>
+		])
+		],
+[hpux*], [	LIBS="-lm $LIBS"
+		ac_cv_c_inline=no],
+[solaris*], [	LIBS="-lm $LIBS"
+		ac_cv_func_vfork=no
+		AC_MSG_CHECKING(whether _XOPEN_SOURCE is already given)
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <unistd.h>
+			#ifndef _XOPEN_SOURCE
+			#error _XOPEN_SOURCE is not defined
+			#endif
+			]], [[]])],
+		        [given_xopen_source=yes], [given_xopen_source=no])
+		AC_MSG_RESULT($given_xopen_source)
+		AS_IF([test $given_xopen_source = no], [
+		  AC_MSG_CHECKING(appropriate _XOPEN_SOURCE value to define)
+		  define_xopen_source=""
+		  for tmp_xpg in 7 6 5; do
+		    AS_IF([test x"$define_xopen_source" != x], [
+		      break
+		    ])
+		    RUBY_WERROR_FLAG([AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+			#define _XOPEN_SOURCE ${tmp_xpg}00
+			#include <unistd.h>
+			#ifndef _XPG${tmp_xpg}
+			#error _XPG${tmp_xpg} should be defined by _XOPEN_SOURCE=${tmp_xpg}00
+			#endif
+			]], [[]])],
+			[define_xopen_source=${tmp_xpg}00], [])
+			])
+		  done
+		  AS_IF([test x"$define_xopen_source" = x], [
+		    define_xopen_source=no
+		  ])
+		  AC_MSG_RESULT($define_xopen_source)
+		  AS_IF([test x"$define_xopen_source" != xno], [
+		    RUBY_APPEND_OPTIONS(CPPFLAGS, -D_XOPEN_SOURCE=$define_xopen_source)
+		  ])
+		])
+		],
+[haiku*], [
+		LIBS="$LIBS" # m lib is include in root
+		],
+[cygwin*], [	ac_cv_header_langinfo_h=yes
+		RUBY_APPEND_OPTIONS(CPPFLAGS, -D_XOPEN_SOURCE -D_GNU_SOURCE)
+		AC_CHECK_FUNCS(cygwin_conv_path)
+		AC_LIBOBJ([langinfo])
+		],
+[mingw*], [	LIBS="-lshell32 -lws2_32 -liphlpapi -limagehlp -lshlwapi $LIBS"
+		ac_cv_header_a_out_h=no
+		ac_cv_header_pwd_h=no
+		ac_cv_header_utime_h=no
+		ac_cv_header_sys_ioctl_h=no
+		ac_cv_header_sys_param_h=no
+		ac_cv_header_sys_resource_h=no
+		ac_cv_header_sys_select_h=no
+		ac_cv_header_sys_time_h=no
+		ac_cv_header_sys_times_h=no
+		ac_cv_header_sys_socket_h=no
+		ac_cv_func_lstat=yes
+		ac_cv_func_times=yes
+		ac_cv_func_waitpid=yes
+		ac_cv_func_fsync=yes
+		ac_cv_func_seekdir=yes
+		ac_cv_func_telldir=yes
+		ac_cv_func_lchown=yes
+		ac_cv_func_link=yes
+		ac_cv_func_readlink=yes
+		ac_cv_func_symlink=yes
+		ac_cv_lib_crypt_crypt=no
+		ac_cv_func_getpgrp_void=no
+		ac_cv_func_memcmp_working=yes
+		ac_cv_lib_dl_dlopen=no
+		rb_cv_binary_elf=no
+		rb_cv_negative_time_t=no
+		ac_cv_func_fcntl=yes
+		ac_cv_func_flock=yes
+		ac_cv_func_gmtime_r=yes
+		rb_cv_large_fd_select=yes
+		ac_cv_type_struct_timeval=yes
+                ac_cv_func_clock_gettime=yes
+                ac_cv_func_clock_getres=yes
+		ac_cv_func_malloc_usable_size=no
+		ac_cv_type_off_t=yes
+		ac_cv_sizeof_off_t=8
+		AS_IF([test "$target_cpu" = x64], [
+		    ac_cv_func___builtin_setjmp=yes
+		    ac_cv_func_round=no
+		    rb_cv_coroutine=yes
+		])
+		ac_cv_func_tgamma=no
+		rb_cv_negative_time_t=yes
+		AC_CHECK_TYPE([NET_LUID], [], [],
+			      [@%:@include <winsock2.h>
+			      @%:@include <iphlpapi.h>])
+		AS_IF([test x"$ac_cv_type_NET_LUID" = xyes], [
+		    AC_DEFINE(HAVE_TYPE_NET_LUID, 1)
+		])
+		AC_CHECK_FUNCS(_gmtime64_s)
+		AC_CHECK_FUNCS(_wfreopen_s)
+		AC_LIBOBJ([langinfo])
+		],
+[bsdi*], [	LIBS="-lm $LIBS"
+		AC_DEFINE(BROKEN_SETREUID, 1)
+		AC_DEFINE(BROKEN_SETREGID, 1)
+                ac_cv_sizeof_rlim_t=8],
+[freebsd*], [	LIBS="-lm $LIBS"
+		ac_cv_func_getpeername=no
+		ac_cv_func_getsockname=no
+		ac_cv_func_shutdown=no
+		ac_cv_func_close=no
+		],
+[netbsd*], [	LIBS="-lm $LIBS"
+		],
+[dragonfly*], [	LIBS="-lm $LIBS"
+		],
+[aix*],[	LIBS="-lm $LIBS"
+		ac_cv_func_round=no
+		ac_cv_func___builtin_setjmp=no
+		],
+[linux*],[	LIBS="-lm $LIBS"
+		# __builtin_longjmp in ppc64* Linux does not restore
+		# the TOC register (r2), which is problematic
+		# when a global exit happens from JITted .so code.
+		AS_CASE(["$target_cpu"], [powerpc64*], [
+			ac_cv_func___builtin_setjmp=no
+		])
+		# With gcc-8's -fcf-protection, MJIT's __builtin_longjmp fails.
+		AS_CASE(["$CC $CFLAGS "], [*" -fcf-protection "*], [cf_protection=yes], [cf_protection=no])
+		AS_IF([test "$cf_protection" = yes], [
+			ac_cv_func___builtin_setjmp=no
+		])
+		],
+[	LIBS="-lm $LIBS"])
+: ${ORIG_LIBS=$LIBS}
+
+AC_CHECK_LIB(crypt, crypt)      # glibc (GNU/Linux, GNU/Hurd, GNU/kFreeBSD)
+AC_CHECK_LIB(dl, dlopen)	# Dynamic linking for SunOS/Solaris and SYSV
+AC_CHECK_LIB(dld, shl_load)	# Dynamic linking for HP-UX
+AC_CHECK_LIB(socket, shutdown)  # SunOS/Solaris
+
+dnl Checks for header files.
+AC_HEADER_DIRENT
+dnl AC_HEADER_STDC has been checked in AC_USE_SYSTEM_EXTENSIONS
+AC_HEADER_STDBOOL
+AC_HEADER_SYS_WAIT
+
+AC_CHECK_HEADERS(a.out.h)
+AC_CHECK_HEADERS(atomic.h)
+AC_CHECK_HEADERS(copyfile.h)
+AC_CHECK_HEADERS(direct.h)
+AC_CHECK_HEADERS(grp.h)
+AC_CHECK_HEADERS(fcntl.h)
+AC_CHECK_HEADERS(float.h)
+AC_CHECK_HEADERS(ieeefp.h)
+AC_CHECK_HEADERS(intrinsics.h)
+AC_CHECK_HEADERS(langinfo.h)
+AC_CHECK_HEADERS(limits.h)
+AC_CHECK_HEADERS(locale.h)
+AC_CHECK_HEADERS(malloc.h)
+AC_CHECK_HEADERS(malloc/malloc.h)
+AC_CHECK_HEADERS(malloc_np.h)
+AC_CHECK_HEADERS(net/socket.h)
+AC_CHECK_HEADERS(process.h)
+AC_CHECK_HEADERS(pwd.h)
+AC_CHECK_HEADERS(sanitizer/asan_interface.h)
+AC_CHECK_HEADERS(sanitizer/msan_interface.h)
+AC_CHECK_HEADERS(setjmpex.h)
+AC_CHECK_HEADERS(stdalign.h)
+AC_CHECK_HEADERS(sys/attr.h)
+AC_CHECK_HEADERS(sys/eventfd.h)
+AC_CHECK_HEADERS(sys/fcntl.h)
+AC_CHECK_HEADERS(sys/file.h)
+AC_CHECK_HEADERS(sys/id.h)
+AC_CHECK_HEADERS(sys/ioctl.h)
+AC_CHECK_HEADERS(sys/mkdev.h)
+AC_CHECK_HEADERS(sys/param.h)
+AC_CHECK_HEADERS(sys/prctl.h)
+AC_CHECK_HEADERS(sys/resource.h)
+AC_CHECK_HEADERS(sys/select.h)
+AC_CHECK_HEADERS(sys/sendfile.h)
+AC_CHECK_HEADERS(sys/socket.h)
+AC_CHECK_HEADERS(sys/syscall.h)
+AC_CHECK_HEADERS(sys/sysmacros.h)
+AC_CHECK_HEADERS(sys/time.h)
+AC_CHECK_HEADERS(sys/times.h)
+AC_CHECK_HEADERS(sys/uio.h)
+AC_CHECK_HEADERS(sys/utime.h)
+AC_CHECK_HEADERS(syscall.h)
+AC_CHECK_HEADERS(time.h)
+AC_CHECK_HEADERS(ucontext.h)
+AC_CHECK_HEADERS(utime.h)
+
+AC_ARG_WITH([gmp],
+  [AS_HELP_STRING([--without-gmp],
+    [disable GNU GMP to accelerate Bignum operations])],
+  [],
+  [with_gmp=yes])
+AS_IF([test "x$with_gmp" != xno],
+  [AC_CHECK_HEADERS(gmp.h)
+   AS_IF([test "x$ac_cv_header_gmp_h" != xno],
+     AC_SEARCH_LIBS([__gmpz_init], [gmp],
+       [AC_DEFINE(HAVE_LIBGMP, 1)]))])
+
+AC_ARG_WITH([jemalloc],
+  [AS_HELP_STRING([--with-jemalloc],[use jemalloc allocator])],
+  [with_jemalloc=$withval], [with_jemalloc=no])
+AS_IF([test "x$with_jemalloc" != xno],[
+  AC_SEARCH_LIBS([malloc_conf], [jemalloc],
+    [
+      AC_DEFINE(HAVE_LIBJEMALLOC, 1)
+      with_jemalloc=yes
+    ],
+    [test x$with_jemalloc = xyes && with_jemalloc=no])
+  AC_CHECK_HEADER(jemalloc/jemalloc.h, [
+    AC_DEFINE(RUBY_ALTERNATIVE_MALLOC_HEADER, [<jemalloc/jemalloc.h>])
+  ],
+  [test x$with_jemalloc = xyes && with_jemalloc=no])
+  AS_IF([test "x$with_jemalloc" != xyes], [
+    AC_CACHE_CHECK([for jemalloc with JEMALLOC_MANGLE], rb_cv_jemalloc_demangle,
+      [AC_LINK_IFELSE([AC_LANG_PROGRAM([@%:@define JEMALLOC_MANGLE 1
+      @%:@ifdef RUBY_ALTERNATIVE_MALLOC_HEADER
+      @%:@include RUBY_ALTERNATIVE_MALLOC_HEADER
+      @%:@else
+      @%:@include <jemalloc.h>
+      @%:@endif], [return !&malloc_conf])],
+      [rb_cv_jemalloc_demangle=yes],
+      [rb_cv_jemalloc_demangle=no])
+    ])
+  ])
+  AS_IF([test "x$rb_cv_jemalloc_demangle" = xyes], [
+    AC_DEFINE(JEMALLOC_MANGLE)
+    with_jemalloc=yes
+  ])
+  AS_CASE(["$with_jemalloc"],
+    [yes],
+    [
+      AC_DEFINE(HAVE_MALLOC_CONF)
+      ac_cv_func_malloc_usable_size=yes
+    ],
+    [no],
+    [AC_MSG_ERROR([jemalloc requested but not found])
+  ])
+])
+
+dnl check for large file stuff
+mv confdefs.h confdefs1.h
+: > confdefs.h
+AC_SYS_LARGEFILE
+# On 32-bit Solaris, it is safe to define _LARGEFILE_SOURCE
+# which is not added by AC_SYS_LARGEFILE.
+AS_IF([test x"$enable_largefile" != xno], [
+  AS_CASE(["$target_os"], [solaris*], [
+    AC_MSG_CHECKING([wheather _LARGEFILE_SOURCE should be defined])
+    AS_CASE(["${ac_cv_sys_file_offset_bits}:${ac_cv_sys_large_files}"],
+      ["64:"|"64:no"|"64:unknown"], [
+	# insert _LARGEFILE_SOURCE before _FILE_OFFSET_BITS line
+	# that is the same order as "getconf LFS_CFLAGS" output
+	mv confdefs.h largefile0.h
+	: > confdefs.h
+	AC_DEFINE(_LARGEFILE_SOURCE)
+	cat largefile0.h >> confdefs.h
+	rm largefile0.h
+	AC_MSG_RESULT([yes])
+      ], [AC_MSG_RESULT([no])])
+  ])
+])
+mv confdefs.h largefile.h
+mv confdefs1.h confdefs.h
+cat largefile.h >> confdefs.h
+
+AS_CASE(["$target_os"],
+    [aix*], [
+    AS_CASE(["$target_cpu:$ac_cv_sys_large_files"],
+	[ppc64:*|powerpc64:*], [],
+	[*:no|*:unknown], [],
+	[
+	    # AIX currently does not support a 32-bit call to posix_fadvise()
+	    # if _LARGE_FILES is defined.
+	    ac_cv_func_posix_fadvise=no
+	])
+    ])
+
+AC_C_BIGENDIAN
+AC_C_CONST
+AC_C_CHAR_UNSIGNED
+AC_C_INLINE
+AC_C_VOLATILE
+AC_C_TYPEOF
+AC_C_RESTRICT
+
+AS_CASE(":$ac_cv_c_const:$ac_cv_c_volatile:",
+    [*:no:*], [AC_MSG_ERROR(ANSI C-conforming const and volatile are mandatory)])
+
+AC_CHECK_TYPES([long long, off_t])
+
+AC_CACHE_CHECK([char bit], [rb_cv_char_bit],
+    [test "$universal_binary" = yes && cross_compiling=yes
+    AC_COMPUTE_INT([rb_cv_char_bit], [CHAR_BIT],
+	[AC_INCLUDES_DEFAULT([@%:@include <limits.h>])], [rb_cv_char_bit=8])
+    test "$universal_binary" = yes && cross_compiling=$real_cross_compiling])
+
+RUBY_CHECK_SIZEOF(int, [], [ILP])
+RUBY_CHECK_SIZEOF(short)
+RUBY_CHECK_SIZEOF(long, [int], [ILP LP])
+RUBY_CHECK_SIZEOF(long long)
+RUBY_CHECK_SIZEOF(__int64, [8], [ILP LP])
+RUBY_CHECK_SIZEOF(__int128, [16], [ILP LP])
+RUBY_CHECK_SIZEOF(off_t)
+RUBY_CHECK_SIZEOF(void*, [int long "long long"], [ILP LP LLP])
+RUBY_CHECK_SIZEOF(float)
+RUBY_CHECK_SIZEOF(double)
+RUBY_CHECK_SIZEOF(time_t, [long "long long"], [], [@%:@include <time.h>])
+RUBY_CHECK_SIZEOF(clock_t, [], [], [@%:@include <time.h>])
+
+AC_CACHE_CHECK(packed struct attribute, rb_cv_packed_struct,
+    [rb_cv_packed_struct=no
+    for mac in \
+	"__pragma(pack(push, 1)) x __pragma(pack(pop))" \
+	"x __attribute__((packed))" \
+	; do
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@define PACKED_STRUCT(x) $mac
+			PACKED_STRUCT(struct { int a; });]], [[]])],
+		[rb_cv_packed_struct=$mac; break])
+    done])
+AS_IF([test "$rb_cv_packed_struct" != no], [
+    AC_DEFINE_UNQUOTED([PACKED_STRUCT(x)], [$rb_cv_packed_struct])
+    RUBY_TRY_CFLAGS(-Wno-address-of-packed-member, [AC_DEFINE(USE_UNALIGNED_MEMBER_ACCESS)])
+], [
+    AC_DEFINE_UNQUOTED([PACKED_STRUCT(x)], x)
+])
+
+AS_IF([test "x$ac_cv_type_long_long" = xyes], [
+    RUBY_CHECK_PRINTF_PREFIX(long long, ll I64, LL)
+], [test "x$ac_cv_type___int64" = xyes], [
+    RUBY_CHECK_PRINTF_PREFIX(__int64, ll I64, LL)
+])
+
+RUBY_REPLACE_TYPE(pid_t, int, PIDT)
+RUBY_REPLACE_TYPE(uid_t, int, UIDT)
+RUBY_REPLACE_TYPE(gid_t, int, GIDT)
+RUBY_REPLACE_TYPE(time_t, [], TIMET, [@%:@include <time.h>])
+RUBY_REPLACE_TYPE(dev_t, [int long "long long"], DEVT)
+RUBY_REPLACE_TYPE(mode_t, ["unsigned short" "unsigned int" long], MODET, [@%:@include <sys/stat.h>])
+RUBY_REPLACE_TYPE(rlim_t, [int long "long long"], RLIM, [
+@%:@ifdef HAVE_SYS_TYPES_H
+@%:@include <sys/types.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TYPES_H
+@%:@include <sys/time.h>
+@%:@endif
+@%:@include <sys/resource.h>
+])
+RUBY_REPLACE_TYPE(off_t, [], OFFT)
+RUBY_REPLACE_TYPE(clockid_t, [], CLOCKID, [@%:@ifdef HAVE_TIME_H
+@%:@ include <time.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TIME_H
+@%:@ include <sys/time.h>
+@%:@endif])
+
+AC_CACHE_CHECK(for prototypes, rb_cv_have_prototypes,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[int foo(int x) { return 0; }]], [[return foo(10);]])],
+	rb_cv_have_prototypes=yes,
+	rb_cv_have_prototypes=no)])
+AS_IF([test "$rb_cv_have_prototypes" = yes], [
+  AC_DEFINE(HAVE_PROTOTYPES)
+])
+
+AC_CACHE_CHECK(token paste string, rb_cv_tokenpaste,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@define paste(a,b) a@%:@@%:@b]],
+		  [[int xy = 1; return paste(x,y);]])],
+		  rb_cv_tokenpaste=ansi,
+		  rb_cv_tokenpaste=knr)])
+AS_IF([test "$rb_cv_tokenpaste" = ansi], [
+  AC_DEFINE(TOKEN_PASTE(x,y),[x@%:@@%:@y])
+], [
+  AC_DEFINE(TOKEN_PASTE(x,y),[x/**/y])
+])
+
+AC_CACHE_CHECK(stringization, rb_cv_stringization, [
+  rb_cv_stringization=no
+  for string in "#expr" '"expr"'; do
+    AC_COMPILE_IFELSE([
+      AC_LANG_BOOL_COMPILE_TRY([
+#define STRINGIZE0(expr) $string
+#define STRINGIZE(expr) STRINGIZE0(expr)
+#undef real_test_for_stringization
+#define test_for_stringization -.real_test_for_stringization.-
+const char stringized[[]] = STRINGIZE(test_for_stringization);
+], [sizeof(stringized) == 32])],
+      [rb_cv_stringization="$string"; break],
+      [rb_cv_stringization=no])
+  done]
+)
+AC_DEFINE(STRINGIZE(expr),STRINGIZE0(expr))
+AS_IF([test x"$rb_cv_stringization" != xno -a "$rb_cv_stringization" != "#expr"], [
+  AC_DEFINE_UNQUOTED(STRINGIZE0(expr),$rb_cv_stringization)
+  AC_DEFINE(OLD_FASHIONED_STRINGIZATION,1)
+])
+
+AC_CACHE_CHECK([string literal concatenation],
+  rb_cv_string_literal_concatenation, [
+  AC_COMPILE_IFELSE([
+    AC_LANG_BOOL_COMPILE_TRY([
+const char concatenated_literal[[]] = "literals" "to"
+  "be" "concatenated.";
+], [sizeof(concatenated_literal) == 26])],
+    [rb_cv_string_literal_concatenation=yes],
+    [rb_cv_string_literal_concatenation=no])]
+)
+AS_IF([test "$rb_cv_string_literal_concatenation" = no], [
+  AC_MSG_ERROR([No string literal concatenation])
+])
+
+AC_CACHE_CHECK(for variable length prototypes and stdarg.h, rb_cv_stdarg,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <stdarg.h>
+int foo(int x, ...) {
+	va_list va;
+	va_start(va, x);
+	va_arg(va, int);
+	va_arg(va, char *);
+	va_arg(va, double);
+	return 0;
+}
+]], [[return foo(10, "", 3.14);]])],
+	rb_cv_stdarg=yes,
+	rb_cv_stdarg=no)])
+AS_IF([test "$rb_cv_stdarg" = yes], [
+  AC_DEFINE(HAVE_STDARG_PROTOTYPES)
+])
+
+AC_CACHE_CHECK(for variable length macro, rb_cv_va_args_macro,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+int foo(int x, ...);
+@%:@define FOO(a, ...) foo(a, @%:@@%:@__VA_ARGS__)
+]], [[FOO(1);FOO(1,2);FOO(1,2,3);]])],
+  rb_cv_va_args_macro=yes,
+  rb_cv_va_args_macro=no)])
+AS_IF([test "$rb_cv_va_args_macro" = yes], [
+  AC_DEFINE(HAVE_VA_ARGS_MACRO)
+])
+
+AC_CACHE_CHECK([for alignas() syntax], rb_cv_have_alignas, [
+rb_cv_have_alignas=no
+RUBY_WERROR_FLAG([
+for attr in \
+    "_Alignas(x)" \
+    "alignas(x)" \
+    "@<:@@<:@alignas(x)@:>@@:>@" \
+    "__declspec(aligned(x))" \
+    "__attribute__((__aligned__(x)))" \
+;
+do
+    # C11 _Alignas and GCC __attribute__((__aligned__)) behave
+    # slightly differently.  What we want is GCC's.  Check that
+    # here by something C11 does not allow (`struct ALIGNAS ...`)
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([
+	[@%:@define ALIGNAS(x) $attr
+	struct ALIGNAS(128) conftest_tag { int foo; } foo; ]], [[]])],
+        [rb_cv_have_alignas="$attr"; break], [])
+done
+])])
+AS_IF([test "$rb_cv_have_alignas" != no], [
+    AC_DEFINE_UNQUOTED([RUBY_ALIGNAS(x)], $rb_cv_have_alignas)
+])
+
+AC_CACHE_CHECK([for alignof() syntax], rb_cv_have_alignof,[
+rb_cv_have_alignof=no
+RUBY_WERROR_FLAG([
+for expr in \
+    "alignof" \
+    "_Alignof" \
+    "__alignof" \
+    "__alignof__" \
+;
+do
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+    @%:@ifdef HAVE_STDALIGN_H
+    @%:@include <stdalign.h>
+    @%:@endif]],[[return (int)$expr(int);]])],
+        [rb_cv_have_alignof="$expr"; break], [])
+done
+])])
+AS_IF([test "$rb_cv_have_alignof" != no], [
+    AC_DEFINE_UNQUOTED(RUBY_ALIGNOF, $rb_cv_have_alignof)
+])
+
+RUBY_FUNC_ATTRIBUTE(__const__, CONSTFUNC)
+RUBY_FUNC_ATTRIBUTE(__pure__, PUREFUNC)
+RUBY_FUNC_ATTRIBUTE(__noreturn__, NORETURN)
+RUBY_FUNC_ATTRIBUTE(__deprecated__, DEPRECATED)
+RUBY_FUNC_ATTRIBUTE(__deprecated__("by "@%:@n), DEPRECATED_BY(n,x), rb_cv_func_deprecated_by)
+RUBY_TYPE_ATTRIBUTE(__deprecated__ mesg, DEPRECATED_TYPE(mesg,x), rb_cv_type_deprecated)
+RUBY_FUNC_ATTRIBUTE(__noinline__, NOINLINE)
+RUBY_FUNC_ATTRIBUTE(__always_inline__, ALWAYS_INLINE)
+RUBY_FUNC_ATTRIBUTE(__no_sanitize__(san), NO_SANITIZE(san, x), rb_cv_func_no_sanitize)
+RUBY_FUNC_ATTRIBUTE(__no_sanitize_address__, NO_SANITIZE_ADDRESS)
+RUBY_FUNC_ATTRIBUTE(__no_address_safety_analysis__, NO_ADDRESS_SAFETY_ANALYSIS)
+RUBY_FUNC_ATTRIBUTE(__warn_unused_result__, WARN_UNUSED_RESULT)
+RUBY_FUNC_ATTRIBUTE(__unused__, MAYBE_UNUSED)
+RUBY_FUNC_ATTRIBUTE(__error__ mesg, ERRORFUNC(mesg,x), rb_cv_func___error__)
+RUBY_FUNC_ATTRIBUTE(__warning__ mesg, WARNINGFUNC(mesg,x), rb_cv_func___warning__)
+RUBY_FUNC_ATTRIBUTE(__weak__, WEAK, rb_cv_func_weak)
+AS_IF([test "$rb_cv_func_weak" != x], [
+   AC_DEFINE(HAVE_FUNC_WEAK)
+])
+
+AC_CACHE_CHECK([for __attribute__((__depreacted__(msg))) in C++],
+  rb_cv_CentOS6_CXX_workaround,
+  RUBY_WERROR_FLAG([
+    AC_LANG_PUSH([C++])
+    AC_COMPILE_IFELSE(
+      [AC_LANG_PROGRAM(
+        [],
+        [__attribute__((__deprecated__("message"))) int conftest(...);])],
+      [rb_cv_CentOS6_CXX_workaround=yes],
+      [rb_cv_CentOS6_CXX_workaround=no])
+    AC_LANG_POP()]))
+AS_IF([test "$rb_cv_CentOS6_CXX_workaround" != no],[
+  AC_DEFINE([RUBY_CXX_DEPRECATED(msg)],
+    [__attribute__((__deprecated__(msg)))])])
+
+if_i386=${universal_binary+[defined __i386__]}
+RUBY_FUNC_ATTRIBUTE(__stdcall__,  FUNC_STDCALL,  rb_cv_func_stdcall,  ${if_i386})
+RUBY_FUNC_ATTRIBUTE(__cdecl__,    FUNC_CDECL,    rb_cv_func_cdecl,    ${if_i386})
+RUBY_FUNC_ATTRIBUTE(__fastcall__, FUNC_FASTCALL, rb_cv_func_fastcall, ${if_i386})
+RUBY_FUNC_ATTRIBUTE(__optimize__("O0"), FUNC_UNOPTIMIZED, rb_cv_func_unoptimized)
+RUBY_FUNC_ATTRIBUTE(__optimize__("-Os","-fomit-frame-pointer"), FUNC_MINIMIZED, rb_cv_func_minimized)
+
+AS_IF([test "$GCC" = yes], [
+    AC_CACHE_CHECK([for function alias], [rb_cv_gcc_function_alias],
+	[rb_cv_gcc_function_alias=no
+	for a in alias weak,alias; do
+	    AC_LINK_IFELSE([AC_LANG_PROGRAM([[void foo(void) {}
+		void bar(void) __attribute__(($a("foo")));]], [[bar()]])],
+		[rb_cv_gcc_function_alias=$a; break])
+	done])
+    AS_IF([test "$rb_cv_gcc_function_alias" != no], [
+	AC_DEFINE(HAVE_ATTRIBUTE_FUNCTION_ALIAS)
+	AC_DEFINE_UNQUOTED([RUBY_ALIAS_FUNCTION_TYPE(type, prot, name, args)],
+			   [type prot __attribute__(($rb_cv_gcc_function_alias(@%:@name)));])
+	AC_DEFINE_UNQUOTED([RUBY_ALIAS_FUNCTION_VOID(prot, name, args)],
+			   [RUBY_ALIAS_FUNCTION_TYPE(void, prot, name, args)])
+    ])
+
+    AC_CACHE_CHECK([for __atomic builtins], [rb_cv_gcc_atomic_builtins], [
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[unsigned int atomic_var;]],
+		    [[
+			__atomic_exchange_n(&atomic_var, 0, __ATOMIC_SEQ_CST);
+			__atomic_exchange_n(&atomic_var, 1, __ATOMIC_SEQ_CST);
+			__atomic_fetch_add(&atomic_var, 1, __ATOMIC_SEQ_CST);
+			__atomic_fetch_sub(&atomic_var, 1, __ATOMIC_SEQ_CST);
+			__atomic_or_fetch(&atomic_var, 1, __ATOMIC_SEQ_CST);
+		    ]])],
+		    [rb_cv_gcc_atomic_builtins=yes],
+		    [rb_cv_gcc_atomic_builtins=no])])
+    AS_IF([test "$rb_cv_gcc_atomic_builtins" = yes], [
+	AC_DEFINE(HAVE_GCC_ATOMIC_BUILTINS)
+    ])
+
+    AC_CACHE_CHECK([for __sync builtins], [rb_cv_gcc_sync_builtins], [
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[unsigned int atomic_var;]],
+		    [[
+			__sync_lock_test_and_set(&atomic_var, 0);
+			__sync_lock_test_and_set(&atomic_var, 1);
+			__sync_fetch_and_add(&atomic_var, 1);
+			__sync_fetch_and_sub(&atomic_var, 1);
+			__sync_or_and_fetch(&atomic_var, 1);
+			__sync_val_compare_and_swap(&atomic_var, 0, 1);
+		    ]])],
+		    [rb_cv_gcc_sync_builtins=yes],
+		    [rb_cv_gcc_sync_builtins=no])])
+    AS_IF([test "$rb_cv_gcc_sync_builtins" = yes], [
+	AC_DEFINE(HAVE_GCC_SYNC_BUILTINS)
+    ])
+
+    AC_CACHE_CHECK(for __builtin_unreachable, rb_cv_func___builtin_unreachable,
+    [RUBY_WERROR_FLAG(
+    [AC_LINK_IFELSE([AC_LANG_PROGRAM([[volatile int zero;]],
+	[[if (zero) __builtin_unreachable();]])],
+	[rb_cv_func___builtin_unreachable=yes],
+	[rb_cv_func___builtin_unreachable=no])
+    ])
+    ])
+    AS_IF([test "$rb_cv_func___builtin_unreachable" = yes], [
+	AC_DEFINE_UNQUOTED(UNREACHABLE, [__builtin_unreachable()])
+    ])
+])
+
+AC_CACHE_CHECK(for exported function attribute, rb_cv_func_exported, [
+rb_cv_func_exported=no
+RUBY_WERROR_FLAG([
+for mac in '__attribute__ ((__visibility__("default")))' '__declspec(dllexport)'; do
+  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@define RUBY_FUNC_EXPORTED $mac extern
+    RUBY_FUNC_EXPORTED void conftest_attribute_check(void);]], [[]])],
+    [rb_cv_func_exported="$mac"; break])
+done
+])])
+AS_IF([test "$rb_cv_func_exported" != no], [
+    AC_DEFINE_UNQUOTED(RUBY_FUNC_EXPORTED, [$rb_cv_func_exported extern])
+])
+RUBY_DECL_ATTRIBUTE([__nonnull__(n)], [RUBY_FUNC_NONNULL(n,x)], [rb_cv_func_nonnull],
+                    [], [function], [
+@%:@define x int conftest_attribute_check(void *p)
+@%:@define n 1
+])
+
+RUBY_APPEND_OPTION(XCFLAGS, -DRUBY_EXPORT)
+
+AC_ARG_ENABLE(mathn,
+    AS_HELP_STRING([--disable-mathn], [disable canonicalization for mathn]),
+    [mathn=$enableval], [mathn=yes])
+test "x$mathn" = xyes || mathn=
+AC_SUBST(MATHN, $mathn)
+
+AC_CACHE_CHECK(for function name string predefined identifier,
+    rb_cv_function_name_string,
+    [AS_CASE(["$target_os"],[openbsd*],[
+      rb_cv_function_name_string=__func__
+     ],[
+     rb_cv_function_name_string=no
+      RUBY_WERROR_FLAG([
+        for func in __func__ __FUNCTION__; do
+            AC_LINK_IFELSE([AC_LANG_PROGRAM([[@%:@include <stdio.h>]],
+			 		    [[puts($func);]])],
+            [rb_cv_function_name_string=$func
+            break])
+        done
+      ])])]
+)
+AS_IF([test "$rb_cv_function_name_string" != no], [
+    AC_DEFINE_UNQUOTED(RUBY_FUNCTION_NAME_STRING, [$rb_cv_function_name_string])
+])
+
+AC_CACHE_CHECK(if enum over int is allowed, rb_cv_enum_over_int, [
+    rb_cv_enum_over_int=no
+    AS_IF([test "x$ac_cv_type_long_long" = xyes], [
+	type="unsigned long long" max="ULLONG_MAX"
+    ], [
+	type="unsigned long" max="ULONG_MAX"
+    ])
+    RUBY_WERROR_FLAG([
+        AC_COMPILE_IFELSE([
+            AC_LANG_BOOL_COMPILE_TRY([
+                    @%:@include <limits.h>
+                    enum {conftest_max = $max};
+                ], [
+                    (conftest_max == $max) &&
+                    (sizeof(conftest_max) == sizeof($type))
+                ]
+	    )],
+	    [rb_cv_enum_over_int=yes],
+	    [rb_cv_enum_over_int=no]
+	)
+    ])
+])
+AS_IF([test $rb_cv_enum_over_int = yes], [
+    AC_DEFINE(ENUM_OVER_INT, 1)
+])
+
+dnl Check whether we need to define sys_nerr locally
+AC_CHECK_DECLS([sys_nerr], [], [], [$ac_includes_default
+@%:@include <errno.h>])
+
+AC_CHECK_DECLS([getenv])
+
+AS_CASE(["$target_cpu"],
+[alpha*|sh4|sh4el|sh4eb], [AS_CASE(["$target_os"::"$GCC"],
+		[*::yes],  # gcc
+			[CFLAGS="-mieee $CFLAGS"],
+		[osf*],    # ccc
+			[CFLAGS="-ieee $CFLAGS"],
+		)],
+[sparc*], [AC_LIBOBJ([sparc])])
+
+ac_cv_header_net_socket_h=${ac_cv_header_net_socket_h=no}
+AS_IF([test "$ac_cv_header_net_socket_h" = yes], [
+    ac_cv_header_sys_socket_h=${ac_cv_header_sys_socket_h=no}
+], [
+    ac_cv_header_sys_socket_h=${ac_cv_header_sys_socket_h=yes}
+])
+
+
+AC_TYPE_SIZE_T
+RUBY_CHECK_SIGNEDNESS(size_t, [AC_MSG_ERROR(size_t is signed)], [],
+		      [@%:@include <sys/types.h>])
+RUBY_CHECK_SIZEOF(size_t, [int long void*], [], [@%:@include <sys/types.h>])
+RUBY_CHECK_SIZEOF(ptrdiff_t, size_t, [], [@%:@include <stddef.h>])
+RUBY_CHECK_PRINTF_PREFIX(size_t, z)
+RUBY_CHECK_PRINTF_PREFIX(ptrdiff_t, t)
+AC_CHECK_MEMBERS([struct stat.st_blksize])
+AC_CHECK_MEMBERS([struct stat.st_blocks])
+AC_CHECK_MEMBERS([struct stat.st_rdev])
+RUBY_CHECK_SIZEOF([struct stat.st_size], [off_t int long "long long"], [], [@%:@include <sys/stat.h>])
+AS_IF([test "$ac_cv_member_struct_stat_st_blocks" = yes], [
+    RUBY_CHECK_SIZEOF([struct stat.st_blocks], [off_t int long "long long"], [], [@%:@include <sys/stat.h>])
+])
+RUBY_CHECK_SIZEOF([struct stat.st_ino], [long "long long"], [], [@%:@include <sys/stat.h>])
+AC_CHECK_MEMBERS([struct stat.st_atim])
+AC_CHECK_MEMBERS([struct stat.st_atimespec])
+AC_CHECK_MEMBERS([struct stat.st_atimensec])
+AC_CHECK_MEMBERS([struct stat.st_mtim])
+AC_CHECK_MEMBERS([struct stat.st_mtimespec])
+AC_CHECK_MEMBERS([struct stat.st_mtimensec])
+AC_CHECK_MEMBERS([struct stat.st_ctim])
+AC_CHECK_MEMBERS([struct stat.st_ctimespec])
+AC_CHECK_MEMBERS([struct stat.st_ctimensec])
+AC_CHECK_MEMBERS([struct stat.st_birthtimespec])
+AS_IF([test "x$ac_cv_member_struct_stat_st_birthtimespec" != xyes],
+    [AC_CHECK_MEMBERS([struct statx.stx_btime])])
+
+AC_CHECK_TYPES([struct timeval], [], [], [@%:@ifdef HAVE_TIME_H
+@%:@include <time.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TIME_H
+@%:@include <sys/time.h>
+@%:@endif])
+
+AS_IF([test "${ac_cv_type_struct_timeval}" = yes], [
+    RUBY_CHECK_SIZEOF([struct timeval.tv_sec], [time_t long "long long"], [],
+		      [@%:@ifdef HAVE_TIME_H
+@%:@include <time.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TIME_H
+@%:@include <sys/time.h>
+@%:@endif])
+    AS_CASE(${ac_cv_sizeof_struct_timeval_tv_sec},
+	    [SIZEOF_INT], [t=int],
+	    [SIZEOF_LONG], [t=long],
+	    [SIZEOF_LONG_LONG], [t=LONG_LONG],
+	    [t=])
+    AS_IF([test "${t}" != ""], [
+	AC_DEFINE_UNQUOTED(TYPEOF_TIMEVAL_TV_SEC, [$t])
+    ])
+])
+
+AC_CHECK_TYPES([struct timespec], [], [], [@%:@ifdef HAVE_TIME_H
+@%:@include <time.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TIME_H
+@%:@include <sys/time.h>
+@%:@endif])
+
+AC_CHECK_TYPES([struct timezone], [], [], [@%:@ifdef HAVE_TIME_H
+@%:@ include <time.h>
+@%:@endif
+@%:@ifdef HAVE_SYS_TIME_H
+@%:@ include <sys/time.h>
+@%:@endif])
+
+AC_CACHE_VAL([rb_cv_large_fd_select],
+    [AC_CHECK_TYPE(fd_mask, [rb_cv_large_fd_select=yes], [rb_cv_large_fd_select=no], [AC_INCLUDES_DEFAULT([])
+@%:@ifdef HAVE_SYS_SELECT_H
+@%:@ include <sys/select.h>
+@%:@endif])])
+AS_IF([test "$rb_cv_large_fd_select" = yes], [
+    AC_DEFINE(HAVE_RB_FD_INIT, 1)
+])
+
+RUBY_DEFINT(int8_t, 1)
+RUBY_DEFINT(uint8_t, 1, unsigned)
+RUBY_DEFINT(int16_t, 2)
+RUBY_DEFINT(uint16_t, 2, unsigned)
+RUBY_DEFINT(int32_t, 4)
+RUBY_DEFINT(uint32_t, 4, unsigned)
+RUBY_DEFINT(int64_t, 8)
+RUBY_DEFINT(uint64_t, 8, unsigned)
+RUBY_DEFINT(int128_t, 16)
+RUBY_DEFINT(uint128_t, 16, unsigned)
+RUBY_DEFINT(intptr_t, void*)
+RUBY_DEFINT(uintptr_t, void*, unsigned)
+AS_IF([test "x$rb_cv_type_intptr_t" != xno], [
+    RUBY_CHECK_PRINTF_PREFIX(intptr_t, '' ll I64 l, PTR)
+])
+RUBY_DEFINT(ssize_t, size_t, [], [@%:@include <sys/types.h>])	dnl may differ from int, so not use AC_TYPE_SSIZE_T.
+AS_IF([test "x$rb_cv_type_int64_t" != xno], [
+    RUBY_CHECK_PRINTF_PREFIX(int64_t, ll I64 l, 64)
+])
+
+AC_CACHE_CHECK(for stack end address, rb_cv_stack_end_address,
+[rb_cv_stack_end_address=no
+  AC_LINK_IFELSE([AC_LANG_PROGRAM(
+      [[extern void *__libc_stack_end;]],
+      [[if (!__libc_stack_end) return 1;]])],
+    [rb_cv_stack_end_address="__libc_stack_end"])
+])
+AS_IF([test $rb_cv_stack_end_address != no], [
+  AC_DEFINE_UNQUOTED(STACK_END_ADDRESS, $rb_cv_stack_end_address)
+])
+
+dnl Checks for library functions.
+AC_TYPE_GETGROUPS
+AC_DEFINE(RETSIGTYPE, void)
+AS_CASE(["${target_cpu}-${target_os}:${target_archs}"],
+[powerpc-darwin*], [
+  AC_LIBSOURCES(alloca.c)
+  AC_SUBST([ALLOCA], [\${LIBOBJDIR}alloca.${ac_objext}])
+  AC_DEFINE(C_ALLOCA)
+  AC_DEFINE_UNQUOTED(alloca, alloca)
+  ],
+[universal-darwin*:*ppc*], [
+  AC_LIBSOURCES(alloca.c)
+  AC_SUBST([ALLOCA], [\${LIBOBJDIR}alloca.${ac_objext}])
+  RUBY_DEFINE_IF([defined __powerpc__], C_ALLOCA, 1)
+  RUBY_DEFINE_IF([defined __powerpc__], alloca, alloca)
+  ],
+[
+  AC_FUNC_ALLOCA
+  ])
+AS_IF([test "x$ALLOCA" = "x"], [
+    AC_CACHE_CHECK([for dynamic size alloca], rb_cv_dynamic_alloca, [
+    for chk in ok __chkstk; do
+	AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+	    @%:@ifdef HAVE_ALLOCA_H
+	    @%:@include <alloca.h>
+	    @%:@endif
+	    void $chk() {}
+	    int dynamic_alloca_test;
+	    int dynamic_alloca_result;]],
+	    [[dynamic_alloca_result = alloca(dynamic_alloca_test) != 0;]])],
+	    [rb_cv_dynamic_alloca=$chk; break])
+    done])
+    AS_IF([test "x$rb_cv_dynamic_alloca" = "x__chkstk"], [
+	AC_DEFINE_UNQUOTED(RUBY_ALLOCA_CHKSTK, _$rb_cv_dynamic_alloca)
+	AS_CASE("$target_cpu",
+	[x64|x86_64], [
+	    AC_SUBST([ALLOCA], [\${LIBOBJDIR}x86_64-chkstk.${ac_objext}])
+	],)
+    ])
+])
+AC_FUNC_MEMCMP
+
+AS_CASE(["$target_os"],[freebsd*],[
+	 AC_DEFINE(BROKEN_CLOSE)
+	 AC_REPLACE_FUNCS(close)
+	 ])
+
+AC_REPLACE_FUNCS(acosh)
+AC_REPLACE_FUNCS(cbrt)
+AC_REPLACE_FUNCS(crypt)
+AC_REPLACE_FUNCS(dup2)
+AC_REPLACE_FUNCS(erf)
+AC_REPLACE_FUNCS(explicit_bzero)
+AC_REPLACE_FUNCS(ffs)
+AC_REPLACE_FUNCS(flock)
+AC_REPLACE_FUNCS(hypot)
+AC_REPLACE_FUNCS(lgamma_r)
+AC_REPLACE_FUNCS(memmove)
+AC_REPLACE_FUNCS(nan)
+AC_REPLACE_FUNCS(nextafter)
+AC_REPLACE_FUNCS(setproctitle)
+AC_REPLACE_FUNCS(strchr)
+AC_REPLACE_FUNCS(strerror)
+AC_REPLACE_FUNCS(strlcat)
+AC_REPLACE_FUNCS(strlcpy)
+AC_REPLACE_FUNCS(strstr)
+AC_REPLACE_FUNCS(tgamma)
+
+RUBY_REPLACE_FUNC([finite], [@%:@include <math.h>])
+RUBY_REPLACE_FUNC([isinf], [@%:@include <math.h>])
+RUBY_REPLACE_FUNC([isnan], [@%:@include <math.h>])
+
+# for missing/setproctitle.c
+AS_CASE(["$target_os"],
+[aix* | k*bsd*-gnu | kopensolaris*-gnu | linux* | darwin*], [AC_DEFINE(SPT_TYPE,SPT_REUSEARGV)],
+[hpux*], [AC_DEFINE(SPT_TYPE,SPT_PSTAT) ],
+[])
+AC_CHECK_HEADERS(sys/pstat.h)
+
+
+AC_CACHE_CHECK(for signbit, rb_cv_have_signbit,
+  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[
+#include <math.h>
+]], [[int v = signbit(-0.0);]])],
+	rb_cv_have_signbit=yes,
+	rb_cv_have_signbit=no)])
+AS_IF([test "$rb_cv_have_signbit" = yes], [
+  AC_DEFINE(HAVE_SIGNBIT)
+], [
+  AC_LIBOBJ([signbit])
+])
+
+AC_FUNC_FORK
+
+AC_CHECK_FUNCS(__syscall)
+AC_CHECK_FUNCS(_longjmp)		# used for AC_ARG_WITH(setjmp-type)
+# we don't use _setjmp if _longjmp doesn't exist.
+test x$ac_cv_func__longjmp = xno && ac_cv_func__setjmp=no
+AC_CHECK_FUNCS(arc4random_buf)
+AC_CHECK_FUNCS(atan2l atan2f)
+AC_CHECK_FUNCS(chroot)
+AC_CHECK_FUNCS(chsize)
+AC_CHECK_FUNCS(clock_gettime)
+AC_CHECK_FUNCS(copy_file_range)
+AC_CHECK_FUNCS(cosh)
+AC_CHECK_FUNCS(crypt_r)
+AC_CHECK_FUNCS(daemon)
+AC_CHECK_FUNCS(dirfd)
+AC_CHECK_FUNCS(dl_iterate_phdr)
+AC_CHECK_FUNCS(dlopen)
+AC_CHECK_FUNCS(dladdr)
+AC_CHECK_FUNCS(dup)
+AC_CHECK_FUNCS(dup3)
+AC_CHECK_FUNCS(eaccess)
+AC_CHECK_FUNCS(endgrent)
+AC_CHECK_FUNCS(eventfd)
+AC_CHECK_FUNCS(explicit_memset)
+AC_CHECK_FUNCS(fcopyfile)
+AC_CHECK_FUNCS(fchmod)
+AC_CHECK_FUNCS(fchown)
+AC_CHECK_FUNCS(fcntl)
+AC_CHECK_FUNCS(fdatasync)
+AC_CHECK_FUNCS(fdopendir)
+AC_CHECK_FUNCS(fgetattrlist)
+AC_CHECK_FUNCS(fmod)
+AC_CHECK_FUNCS(fstatat)
+AC_CHECK_FUNCS(fsync)
+AC_CHECK_FUNCS(ftruncate)
+AC_CHECK_FUNCS(ftruncate64)		# used for Win32 platform
+AC_CHECK_FUNCS(getattrlist)
+AC_CHECK_FUNCS(getcwd)
+AC_CHECK_FUNCS(getgidx)
+AC_CHECK_FUNCS(getgrnam)
+AC_CHECK_FUNCS(getgrnam_r)
+AC_CHECK_FUNCS(getgroups)
+AC_CHECK_FUNCS(getlogin)
+AC_CHECK_FUNCS(getlogin_r)
+AC_CHECK_FUNCS(getpgid)
+AC_CHECK_FUNCS(getpgrp)
+AC_CHECK_FUNCS(getpriority)
+AC_CHECK_FUNCS(getpwnam)
+AC_CHECK_FUNCS(getpwnam_r)
+AC_CHECK_FUNCS(getpwuid)
+AC_CHECK_FUNCS(getpwuid_r)
+AC_CHECK_FUNCS(getrandom)
+AC_CHECK_FUNCS(getresgid)
+AC_CHECK_FUNCS(getresuid)
+AC_CHECK_FUNCS(getrlimit)
+AC_CHECK_FUNCS(getsid)
+AC_CHECK_FUNCS(gettimeofday)		# for making ac_cv_func_gettimeofday
+AC_CHECK_FUNCS(getuidx)
+AC_CHECK_FUNCS(gmtime_r)
+AC_CHECK_FUNCS(grantpt)
+AC_CHECK_FUNCS(initgroups)
+AC_CHECK_FUNCS(ioctl)
+AC_CHECK_FUNCS(isfinite)
+AC_CHECK_FUNCS(issetugid)
+AC_CHECK_FUNCS(killpg)
+AC_CHECK_FUNCS(lchmod)
+AC_CHECK_FUNCS(lchown)
+AC_CHECK_FUNCS(link)
+AC_CHECK_FUNCS(llabs)
+AC_CHECK_FUNCS(lockf)
+AC_CHECK_FUNCS(log2)
+AC_CHECK_FUNCS(lstat)
+AC_CHECK_FUNCS(lutimes)
+AC_CHECK_FUNCS(malloc_usable_size)
+AC_CHECK_FUNCS(malloc_size)
+AC_CHECK_FUNCS(mblen)
+AC_CHECK_FUNCS(memalign)
+AC_CHECK_FUNCS(memset_s)
+AC_CHECK_FUNCS(writev)
+AC_CHECK_FUNCS(memrchr)
+AC_CHECK_FUNCS(memmem)
+AC_CHECK_FUNCS(mkfifo)
+AC_CHECK_FUNCS(mknod)
+AC_CHECK_FUNCS(mktime)
+AC_CHECK_FUNCS(openat)
+AC_CHECK_FUNCS(pipe2)
+AC_CHECK_FUNCS(poll)
+AC_CHECK_FUNCS(posix_fadvise)
+AC_CHECK_FUNCS(posix_memalign)
+AC_CHECK_FUNCS(ppoll)
+AC_CHECK_FUNCS(pread)
+AC_CHECK_FUNCS(pwrite)
+AC_CHECK_FUNCS(qsort_r)
+AC_CHECK_FUNCS(qsort_s)
+AC_CHECK_FUNCS(readlink)
+AC_CHECK_FUNCS(realpath)
+AC_CHECK_FUNCS(round)
+AC_CHECK_FUNCS(sched_getaffinity)
+AC_CHECK_FUNCS(seekdir)
+AC_CHECK_FUNCS(select_large_fdset)
+AC_CHECK_FUNCS(sendfile)
+AC_CHECK_FUNCS(setegid)
+AC_CHECK_FUNCS(setenv)
+AC_CHECK_FUNCS(seteuid)
+AC_CHECK_FUNCS(setgid)
+AC_CHECK_FUNCS(setgroups)
+AC_CHECK_FUNCS(setpgid)
+AC_CHECK_FUNCS(setpgrp)
+AC_CHECK_FUNCS(setregid)
+AC_CHECK_FUNCS(setresgid)
+AC_CHECK_FUNCS(setresuid)
+AC_CHECK_FUNCS(setreuid)
+AC_CHECK_FUNCS(setrgid)
+AC_CHECK_FUNCS(setrlimit)
+AC_CHECK_FUNCS(setruid)
+AC_CHECK_FUNCS(setsid)
+AC_CHECK_FUNCS(setuid)
+AC_CHECK_FUNCS(shutdown)
+AC_CHECK_FUNCS(sigaction)
+AC_CHECK_FUNCS(sigaltstack)
+AC_CHECK_FUNCS(sigprocmask)
+AC_CHECK_FUNCS(sinh)
+AC_CHECK_FUNCS(spawnv)
+AC_CHECK_FUNCS(symlink)
+AC_CHECK_FUNCS(syscall)
+AC_CHECK_FUNCS(sysconf)
+AC_CHECK_FUNCS(tanh)
+AC_CHECK_FUNCS(telldir)
+AC_CHECK_FUNCS(timegm)
+AC_CHECK_FUNCS(times)
+AC_CHECK_FUNCS(truncate)
+AC_CHECK_FUNCS(truncate64)		# used for Win32
+AC_CHECK_FUNCS(unsetenv)
+AC_CHECK_FUNCS(utimensat)
+AC_CHECK_FUNCS(utimes)
+AC_CHECK_FUNCS(wait4)
+AC_CHECK_FUNCS(waitpid)
+
+AS_IF([test "x$ac_cv_member_struct_statx_stx_btime" = xyes],
+    [AC_CHECK_FUNCS(statx)])
+
+AS_CASE(["$ac_cv_func_memset_s:$ac_cv_func_qsort_s"], [*yes*],
+    [RUBY_DEFINE_IF([!defined __STDC_WANT_LIB_EXT1__], [__STDC_WANT_LIB_EXT1__], 1)])
+
+AS_IF([test "$ac_cv_func_getcwd" = yes], [
+    AC_CACHE_CHECK(if getcwd allocates buffer if NULL is given, [rb_cv_getcwd_malloc],
+	[AC_RUN_IFELSE([AC_LANG_SOURCE([[
+@%:@include <stddef.h>
+@%:@include <stdio.h>
+@%:@ifdef HAVE_UNISTD_H
+@%:@include <unistd.h>
+@%:@endif
+@%:@ifndef EXIT_SUCCESS
+@%:@define EXIT_SUCCESS 0
+@%:@endif
+@%:@ifndef EXIT_FAILURE
+@%:@define EXIT_FAILURE 1
+@%:@endif
+
+int
+main(int argc, char **argv)
+{
+    if (!getcwd(NULL, 0)) return EXIT_FAILURE;
+    return EXIT_SUCCESS;
+}
+]])],
+	    rb_cv_getcwd_malloc=yes,
+	    rb_cv_getcwd_malloc=no,
+	    AS_CASE($target_os,
+		[linux*|darwin*|*bsd|cygwin*|mingw*|mswin*],
+		[rb_cv_getcwd_malloc=yes],
+		[rb_cv_getcwd_malloc=no]))])
+    AS_IF([test "$rb_cv_getcwd_malloc" = no], [AC_DEFINE(NO_GETCWD_MALLOC, 1)])
+])
+
+AS_IF([test "$ac_cv_func_crypt_r" = yes],
+    [AC_CHECK_HEADERS(crypt.h)])
+AS_IF([test "$ac_cv_func_crypt_r:$ac_cv_header_crypt_h" = yes:yes],
+    [AC_CHECK_MEMBERS([struct crypt_data.initialized], [], [],
+		      [AC_INCLUDES_DEFAULT([@%:@include <crypt.h>])])])
+
+RUBY_CHECK_BUILTIN_FUNC(__builtin_alloca_with_align, [__builtin_alloca_with_align(1, 4096)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_assume_aligned, [__builtin_assume_aligned((void*)32, 32)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_bswap16, [__builtin_bswap16(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_bswap32, [__builtin_bswap32(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_bswap64, [__builtin_bswap64(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_popcount, [__builtin_popcount(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_popcountll, [__builtin_popcountll(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_clz, [__builtin_clz(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_clzl, [__builtin_clzl(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_clzll, [__builtin_clzll(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_ctz, [__builtin_ctz(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_ctzll, [__builtin_ctzll(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_add_overflow, [int x;__builtin_add_overflow(0,0,&x)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_sub_overflow, [int x;__builtin_sub_overflow(0,0,&x)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_mul_overflow, [int x;__builtin_mul_overflow(0,0,&x)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_mul_overflow_p, [__builtin_mul_overflow_p(0,0,(int)0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_constant_p, [__builtin_constant_p(0)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_choose_expr, [
+    [int x[__extension__(__builtin_choose_expr(1, 1, -1))]];
+    [int y[__extension__(__builtin_choose_expr(0, -1, 1))]];
+    ])
+AS_IF([test x$rb_cv_builtin___builtin_choose_expr = xyes], [
+    RUBY_CHECK_BUILTIN_FUNC(__builtin_choose_expr_constant_p, [
+    [int x[__extension__(__builtin_choose_expr(__builtin_constant_p(1), 1, -1))]];
+    [int y[__extension__(__builtin_choose_expr(__builtin_constant_p(foo), -1, 1))]];
+    ])
+])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_types_compatible_p, [__builtin_types_compatible_p(int, int)])
+RUBY_CHECK_BUILTIN_FUNC(__builtin_trap, [__builtin_trap()])
+
+AS_IF([test "$ac_cv_func_qsort_r" != no], [
+  AC_CACHE_CHECK(whether qsort_r is GNU version, rb_cv_gnu_qsort_r,
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+@%:@include <stdlib.h>
+void (qsort_r)(void *base, size_t nmemb, size_t size,
+	    int (*compar)(const void *, const void *, void *),
+	    void *arg);
+]], [[ ]])],
+      [rb_cv_gnu_qsort_r=yes],
+      [rb_cv_gnu_qsort_r=no])
+  ])
+  AC_CACHE_CHECK(whether qsort_r is BSD version, rb_cv_bsd_qsort_r,
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+@%:@include <stdlib.h>
+void (qsort_r)(void *base, size_t nmemb, size_t size,
+	     void *arg, int (*compar)(void *, const void *, const void *));
+]], [[ ]])],
+      [rb_cv_bsd_qsort_r=yes],
+      [rb_cv_bsd_qsort_r=no])
+  ])
+  AS_CASE("$rb_cv_gnu_qsort_r:$rb_cv_bsd_qsort_r",
+  [yes:no], [
+    AC_DEFINE(HAVE_GNU_QSORT_R, 1)
+  ],
+  [no:yes], [
+    AC_DEFINE(HAVE_BSD_QSORT_R, 1)
+  ])
+])
+
+AC_CACHE_CHECK(whether atan2 handles Inf as C99, rb_cv_atan2_inf_c99, [
+    AS_IF([test $ac_cv_func_atan2f:$ac_cv_func_atan2l = yes:yes], [
+	AC_RUN_IFELSE([AC_LANG_SOURCE([[
+@%:@include <math.h>
+@%:@ifdef HAVE_UNISTD_H
+@%:@include <unistd.h>
+@%:@endif
+@%:@ifndef EXIT_SUCCESS
+@%:@define EXIT_SUCCESS 0
+@%:@endif
+@%:@ifndef EXIT_FAILURE
+@%:@define EXIT_FAILURE 1
+@%:@endif
+
+int
+main(int argc, char **argv)
+{
+    if (fabs(atan2(INFINITY, INFINITY) - M_PI_4) <= 0.01) return EXIT_SUCCESS;
+    return EXIT_FAILURE;
+}
+]])],
+	[rb_cv_atan2_inf_c99=yes],
+	[rb_cv_atan2_inf_c99=no],
+	[AS_CASE($target_os, [mingw*|mswin*], [rb_cv_atan2_inf_c99=no], [rb_cv_atan2_inf_c99=yes])]
+	)
+    ], [rb_cv_atan2_inf_c99=no])
+])
+AS_IF([test "x$rb_cv_atan2_inf_c99" = xyes], [AC_DEFINE(ATAN2_INF_C99)])
+
+# Some platform need -lrt for clock_gettime, but the other don't.
+AS_IF([test x"$ac_cv_func_clock_gettime" != xyes], [
+    # glibc 2.17 moves clock_* functions from librt to the main C library.
+    # http://sourceware.org/ml/libc-announce/2012/msg00001.html
+    AC_CHECK_LIB(rt, clock_gettime)
+    AS_IF([test x"$ac_cv_lib_rt_clock_gettime" = xyes], [
+	AC_DEFINE(HAVE_CLOCK_GETTIME, 1)
+    ])
+])
+AC_CHECK_FUNCS(clock_getres) # clock_getres should be tested after clock_gettime test including librt test.
+AC_CHECK_LIB([rt], [timer_create])
+AC_CHECK_LIB([rt], [timer_settime])
+AS_IF([test x"$ac_cv_lib_rt_timer_create" = xyes], [
+    AC_DEFINE(HAVE_TIMER_CREATE, 1)
+])
+AS_IF([test x"$ac_cv_lib_rt_timer_settime" = xyes], [
+    AC_DEFINE(HAVE_TIMER_SETTIME, 1)
+])
+
+AC_CACHE_CHECK(for unsetenv returns a value, rb_cv_unsetenv_return_value,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#include <stdlib.h>
+]], [[int v = unsetenv("foo");]])],
+	rb_cv_unsetenv_return_value=yes,
+	rb_cv_unsetenv_return_value=no)])
+AS_IF([test "$rb_cv_unsetenv_return_value" = no], [
+  AC_DEFINE(VOID_UNSETENV)
+])
+
+# End of setjmp check.
+
+AC_ARG_ENABLE(setreuid,
+       AS_HELP_STRING([--enable-setreuid], [use setreuid()/setregid() according to need even if obsolete]),
+       [use_setreuid=$enableval])
+AS_IF([test "$use_setreuid" = yes], [
+    AC_DEFINE(USE_SETREUID)
+    AC_DEFINE(USE_SETREGID)
+])
+AC_STRUCT_TIMEZONE
+AC_CACHE_CHECK(for struct tm.tm_gmtoff, rb_cv_member_struct_tm_tm_gmtoff,
+  [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+@%:@define _BSD_SOURCE
+@%:@define _DEFAULT_SOURCE
+@%:@include <time.h>
+    ]],
+    [[struct tm t; t.tm_gmtoff = 3600;]])],
+  [rb_cv_member_struct_tm_tm_gmtoff=yes],
+  [rb_cv_member_struct_tm_tm_gmtoff=no])])
+AS_IF([test "$rb_cv_member_struct_tm_tm_gmtoff" = yes], [
+  AC_DEFINE(HAVE_STRUCT_TM_TM_GMTOFF)
+])
+AC_CACHE_CHECK(for external int daylight, rb_cv_have_daylight,
+  [AC_LINK_IFELSE([AC_LANG_PROGRAM([[#include <time.h>
+  int i;]],
+	[[i = daylight;]])],
+	rb_cv_have_daylight=yes,
+	rb_cv_have_daylight=no)])
+AS_IF([test "$rb_cv_have_daylight" = yes], [
+  AC_DEFINE(HAVE_DAYLIGHT)
+])
+
+AC_CACHE_CHECK(for negative time_t for gmtime(3), rb_cv_negative_time_t,
+  [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdlib.h>
+#include <time.h>
+
+void
+check(tm, y, m, d, h, s)
+    struct tm *tm;
+    int y, m, d, h, s;
+{
+    if (!tm ||
+	tm->tm_year != y ||
+	tm->tm_mon  != m-1 ||
+	tm->tm_mday != d ||
+	tm->tm_hour != h ||
+	tm->tm_sec  != s) {
+	exit(1);
+    }
+}
+
+int
+main()
+{
+   time_t t = -1;
+   struct tm *tm;
+
+   check(gmtime(&t), 69, 12, 31, 23, 59);
+   t = ~(time_t)0 << 31;
+   check(gmtime(&t), 1, 12, 13, 20, 52);
+   return 0;
+}
+]])],
+	rb_cv_negative_time_t=yes,
+	rb_cv_negative_time_t=no,
+	rb_cv_negative_time_t=yes)])
+AS_IF([test "$rb_cv_negative_time_t" = yes], [
+  AC_DEFINE(NEGATIVE_TIME_T)
+])
+
+# [ruby-dev:40910] overflow of time on FreeBSD
+# http://www.freebsd.org/cgi/query-pr.cgi?pr=145341
+AC_CACHE_CHECK(for localtime(3) overflow correctly, rb_cv_localtime_overflow,
+  [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdlib.h>
+#include <time.h>
+
+void
+check(time_t t1)
+{
+    struct tm *tm;
+    time_t t2;
+    tm = localtime(&t1);
+    if (!tm)
+	return; /* overflow detected.  ok. */
+    t2 = mktime(tm);
+    if (t1 == t2)
+        return; /* round-trip.  ok. */
+    exit(1);
+}
+
+int
+main()
+{
+    time_t t;
+    if (~(time_t)0 <= 0) {
+        t = (((time_t)1) << (sizeof(time_t) * 8 - 2));
+        t |= t - 1;
+    }
+    else {
+        t = ~(time_t)0;
+    }
+    check(t);
+    return 0;
+}
+]])],
+	rb_cv_localtime_overflow=yes,
+	rb_cv_localtime_overflow=no,
+	rb_cv_localtime_overflow=no)])
+AS_IF([test "$rb_cv_localtime_overflow" = no], [
+  AC_DEFINE(LOCALTIME_OVERFLOW_PROBLEM)
+])
+
+AS_IF([test "$ac_cv_func_sigprocmask" = yes && test "$ac_cv_func_sigaction" = yes], [
+   AC_DEFINE(POSIX_SIGNAL)
+], [
+  AC_CHECK_FUNCS(sigsetmask)
+  AC_CACHE_CHECK(for BSD signal semantics, rb_cv_bsd_signal,
+    [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdio.h>
+#include <signal.h>
+
+void
+sig_handler(dummy)
+     int dummy;
+{
+}
+
+int
+main()
+{
+  signal(SIGINT, sig_handler);
+  kill(getpid(), SIGINT);
+  kill(getpid(), SIGINT);
+  return 0;
+}
+]])],
+	rb_cv_bsd_signal=yes,
+	rb_cv_bsd_signal=no,
+	rb_cv_bsd_signal=$ac_cv_func_sigsetmask)])
+  AS_IF([test "$rb_cv_bsd_signal" = yes], [
+    AC_DEFINE(BSD_SIGNAL)
+  ])
+])
+
+AC_CHECK_TYPES([sig_t],[],[],[@%:@include <signal.h>])
+
+AS_IF([test "$ac_cv_func_getpgid" = no], [
+  # AC_FUNC_GETPGRP fails when cross-compiling with old autoconf.
+  # autoconf is changed between 2.52d and 2.52f?
+  # http://lists.gnu.org/archive/html/bug-gnu-utils/2001-09/msg00181.html
+  # "autoconf cleanup for AC_FUNC_GETPGRP and GETPGRP_VOID"
+AC_FUNC_GETPGRP
+])
+AS_IF([test "$ac_cv_func_setpgid:$ac_cv_func_setpgrp" = no:yes], [
+  # AC_FUNC_SETPGRP fails when cross-compiling.  (until autoconf 2.69?)
+  # https://lists.gnu.org/archive/html/bug-autoconf/2013-02/msg00002.html
+  # "AC_FUNC_SETPGRP fails to work properly when cross-compiling"
+AC_FUNC_SETPGRP
+])
+
+AS_IF([test x"$ac_cv_func_dirfd" = xno], [
+  AS_CASE(["$target_os"],[solaris*],
+          [AC_CHECK_MEMBERS([DIR.d_fd, DIR.dd_fd],,,[
+#include <sys/types.h>
+#include <dirent.h>
+])])
+])
+
+AC_CACHE_CHECK(whether right shift preserve sign bit, rb_cv_rshift_sign,
+    [AC_COMPILE_IFELSE([AC_LANG_BOOL_COMPILE_TRY([], [(-1==(-1>>1))])],
+	rb_cv_rshift_sign=yes,
+	rb_cv_rshift_sign=no)])
+AS_IF([test "$rb_cv_rshift_sign" = yes], [
+  AC_DEFINE(RSHIFT(x,y), ((x)>>(int)(y)))
+], [
+  AC_DEFINE(RSHIFT(x,y), (((x)<0) ? ~((~(x))>>(int)(y)) : (x)>>(int)(y)))
+])
+
+AS_CASE(["$ac_cv_func_gettimeofday:$ac_cv_func_clock_gettime"],
+[*yes*], [],
+[
+    AC_MSG_ERROR(clock_gettime() or gettimeofday() must exist)
+])
+
+AS_IF([test "$ac_cv_func_sysconf" = yes], [
+  RUBY_CHECK_SYSCONF(CLK_TCK)
+])
+
+AS_IF([test "${universal_binary-no}" = yes ], [
+    archflagpat=`eval echo '"'"${ARCH_FLAG}"'"' | sed 's/[[][|.*]]/\\&/g'`
+    save_CFLAGS="$CFLAGS" new_cflags=`echo "$CFLAGS" | sed "s|$archflagpat"'||'`
+    save_LDFLAGS="$LDFLAGS" new_ldflags=`echo "$LDFLAGS" | sed "s|$archflagpat"'||'`
+    stack_dir=
+    for archs in ${universal_archnames}; do
+	archs=`echo $archs | sed 's/=.*//'`
+	CFLAGS="$new_cflags -arch $archs"
+	LDFLAGS="$new_ldflags -arch $archs"
+	RUBY_STACK_GROW_DIRECTION($archs, dir)
+	AS_IF([test x$stack_dir = x], [
+	    stack_dir=$dir
+	], [test x$stack_dir != x$dir], [
+	    stack_dir=no
+	])
+    done
+    CFLAGS="$save_CFLAGS" LDFLAGS="$save_LDFLAGS"
+    AS_IF([test x$stack_dir = xno], [
+	for archs in ${universal_archnames}; do
+	    archs=`echo $archs | sed 's/=.*//'`
+	    eval dir=\$[rb_cv_stack_grow_dir_]AS_TR_SH([$archs])
+	    RUBY_DEFINE_IF([defined __${archs}__], STACK_GROW_DIRECTION, $dir)
+	done
+    ], [
+	AC_DEFINE_UNQUOTED(STACK_GROW_DIRECTION, $stack_dir)
+    ])
+], [
+    RUBY_STACK_GROW_DIRECTION($target_cpu, dir)
+    AC_DEFINE_UNQUOTED(STACK_GROW_DIRECTION, $dir)
+])
+
+AC_ARG_WITH(coroutine,
+    AS_HELP_STRING([--with-coroutine=IMPLEMENTATION], [specify the coroutine implementation to use]),
+    [rb_cv_coroutine=$withval])
+AS_CASE([$rb_cv_coroutine], [yes|''], [
+    AC_MSG_CHECKING(native coroutine implementation for ${target_cpu}-${target_os})
+    AS_CASE(["$target_cpu-$target_os"],
+        [x*64-darwin*], [
+            rb_cv_coroutine=amd64
+        ],
+        [arm64-darwin*], [
+            rb_cv_coroutine=arm64
+        ],
+        [x*64-linux*], [
+            AS_CASE(["$ac_cv_sizeof_voidp"],
+                [8], [ rb_cv_coroutine=amd64 ],
+                [4], [ rb_cv_coroutine=x86 ],
+                [*], [ rb_cv_coroutine= ]
+            )
+        ],
+        [*86-linux*], [
+            rb_cv_coroutine=x86
+        ],
+        [x64-mingw32], [
+            rb_cv_coroutine=win64
+        ],
+        [*86-mingw32], [
+            rb_cv_coroutine=win32
+        ],
+        [armv7*-linux*], [
+            rb_cv_coroutine=ucontext
+        ],
+        [aarch64-linux*], [
+            rb_cv_coroutine=arm64
+        ],
+        [powerpc64le-linux*], [
+            rb_cv_coroutine=ppc64le
+        ],
+        [x86_64-openbsd*], [
+            rb_cv_coroutine=amd64
+        ],
+        [i386-openbsd*], [
+            rb_cv_coroutine=x86
+        ],
+        [*-openbsd*], [
+            rb_cv_coroutine=copy
+        ],
+        [*], [
+            rb_cv_coroutine=ucontext
+        ]
+    )
+    AC_MSG_RESULT(${rb_cv_coroutine})
+])
+COROUTINE_H=coroutine/$rb_cv_coroutine/Context.h
+AS_CASE([$rb_cv_coroutine],
+    [copy|ucontext], [
+        COROUTINE_SRC=coroutine/$rb_cv_coroutine/Context.c
+    ],
+    [*], [
+        COROUTINE_SRC=coroutine/$rb_cv_coroutine/Context.'$(ASMEXT)'
+    ],
+)
+AC_DEFINE_UNQUOTED(COROUTINE_H, ["$COROUTINE_H"])
+AC_SUBST(X_COROUTINE_H, [$COROUTINE_H])
+AC_SUBST(X_COROUTINE_SRC, [$COROUTINE_SRC])
+
+AS_IF([test x"$enable_pthread" = xyes], [
+    for pthread_lib in thr pthread pthreads c c_r root; do
+	AC_CHECK_LIB($pthread_lib, pthread_create,
+		     rb_with_pthread=yes, rb_with_pthread=no)
+	AS_IF([test "$rb_with_pthread" = "yes"], [break])
+    done
+    AS_IF([test x"$rb_with_pthread" = xyes], [
+	AC_DEFINE(_REENTRANT)
+	AC_DEFINE(_THREAD_SAFE)
+	AC_DEFINE(HAVE_LIBPTHREAD)
+	AC_CHECK_HEADERS(pthread_np.h, [], [], [@%:@include <pthread.h>])
+	AS_CASE(["$pthread_lib:$target_os"],
+		[c:*], [],
+		[root:*], [],
+		[c_r:*|*:openbsd*|*:mirbsd*],  [LIBS="-pthread $LIBS"],
+		[LIBS="-l$pthread_lib $LIBS"])
+    ], [
+	AC_MSG_WARN("Don't know how to find pthread library on your system -- thread support disabled")
+    ])
+    AC_CACHE_CHECK([whether pthread_t is scalar type], [rb_cv_scalar_pthread_t], [
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	    @%:@include <pthread.h>
+	    ]], [[
+	    pthread_t thread_id;
+	    thread_id = 0;
+	    if (!thread_id) return 0;
+	    ]])],[rb_cv_scalar_pthread_t=yes],[rb_cv_scalar_pthread_t=no])
+    ])
+    AS_IF([test x"$rb_cv_scalar_pthread_t" = xyes], [
+	: # RUBY_CHECK_SIZEOF(pthread_t, [void* int long], [], [@%:@include <pthread.h>])
+    ], [
+	AC_DEFINE(NON_SCALAR_THREAD_ID)
+    ])
+    AC_CHECK_FUNCS(sched_yield pthread_attr_setinheritsched \
+	pthread_attr_get_np pthread_attr_getstack pthread_attr_getguardsize \
+	pthread_get_stackaddr_np pthread_get_stacksize_np \
+	thr_stksegment pthread_stackseg_np pthread_getthrds_np \
+	pthread_condattr_setclock \
+	pthread_sigmask pthread_setname_np pthread_set_name_np)
+    AS_CASE(["$target_os"],[aix*],[ac_cv_func_pthread_getattr_np=no],[AC_CHECK_FUNCS(pthread_getattr_np)])
+    set_current_thread_name=
+    AS_IF([test "$ac_cv_func_pthread_setname_np" = yes], [
+	AC_CACHE_CHECK([arguments of pthread_setname_np], [rb_cv_func_pthread_setname_np_arguments],
+	    [rb_cv_func_pthread_setname_np_arguments=
+	    # Linux,AIX,  (pthread_self(), name)
+	    # NetBSD (pthread_self(), \"%s\", name)
+	    # Darwin (name)
+	    for mac in \
+		"(pthread_self(), name)" \
+		"(pthread_self(), \"%s\", name)" \
+		"(name)" \
+		; do
+		AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+		    @%:@include <pthread.h>
+		    @%:@ifdef HAVE_PTHREAD_NP_H
+		    @%:@include <pthread_np.h>
+		    @%:@endif
+		    @%:@define SET_THREAD_NAME(name) pthread_setname_np${mac}
+		    ]],
+		    [[if (SET_THREAD_NAME("conftest")) return 1;]])],
+		    [rb_cv_func_pthread_setname_np_arguments="${mac}"
+		    break])
+	    done
+	    ]
+	)
+	AS_IF([test -n "${rb_cv_func_pthread_setname_np_arguments}"], [
+	    set_current_thread_name="pthread_setname_np${rb_cv_func_pthread_setname_np_arguments}"
+	])
+    ], [test "$ac_cv_func_pthread_set_name_np" = yes], [
+	set_current_thread_name="pthread_set_name_np(pthread_self(), name)"
+    ])
+    AS_IF([test -n "$set_current_thread_name"], [
+	AC_DEFINE_UNQUOTED(SET_CURRENT_THREAD_NAME(name), $set_current_thread_name)
+	AS_CASE([$set_current_thread_name],
+	    [*'pthread_self()'*], [
+		set_another_thread_name=`echo "$set_current_thread_name" | sed 's/pthread_self()/thid/'`
+		AC_DEFINE_UNQUOTED(SET_ANOTHER_THREAD_NAME(thid,name), $set_another_thread_name)
+	    ])
+    ])
+])
+
+AS_IF([test x"$ac_cv_header_ucontext_h" = xno], [
+    AC_CACHE_CHECK([if signal.h defines ucontext_t], [rb_cv_ucontext_in_signal_h],
+	[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <signal.h>]],
+					    [[size_t size = sizeof(ucontext_t);]])],
+	[rb_cv_ucontext_in_signal_h=yes], [rb_cv_ucontext_in_signal_h=no])])
+    AS_IF([test x"$rb_cv_ucontext_in_signal_h" = xyes], [
+	    AC_DEFINE_UNQUOTED(UCONTEXT_IN_SIGNAL_H, 1)
+    ])
+])
+AS_IF([test x"$ac_cv_header_ucontext_h" = xyes -o x"$rb_cv_ucontext_in_signal_h" = xyes], [
+    AC_CACHE_CHECK([if mcontext_t is a pointer], [rb_cv_mcontext_t_ptr],
+	[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+	    @%:@include <signal.h>
+	    @%:@ifdef HAVE_UCONTEXT_H
+	    @%:@include <ucontext.h>
+	    @%:@endif
+        mcontext_t test(mcontext_t mc) {return mc+1;}
+	  ]],
+	  [[test(0);]])],
+	[rb_cv_mcontext_t_ptr=yes], [rb_cv_mcontext_t_ptr=no])])
+    AS_IF([test x"$rb_cv_mcontext_t_ptr" = xyes], [
+	AC_DEFINE_UNQUOTED(DEFINE_MCONTEXT_PTR(mc, uc), mcontext_t mc = (uc)->uc_mcontext)
+    ], [
+	AC_DEFINE_UNQUOTED(DEFINE_MCONTEXT_PTR(mc, uc), mcontext_t *mc = &(uc)->uc_mcontext)
+    ])
+    AS_IF([test x"$rb_with_pthread" = xyes], [
+	AC_CHECK_FUNCS(getcontext setcontext)
+    ])
+])
+
+AS_IF([test "$ac_cv_func_fork_works" = "yes" -a "$rb_with_pthread" = "yes"], [
+    AC_CACHE_CHECK([if fork works with pthread], rb_cv_fork_with_pthread,
+	[AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <stdlib.h>
+#include <unistd.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <signal.h>
+#ifndef EXIT_SUCCESS
+#define EXIT_SUCCESS 0
+#endif
+#ifndef EXIT_FAILURE
+#define EXIT_FAILURE 1
+#endif
+
+void *
+thread_func(void *dmy)
+{
+    return dmy;
+}
+
+int
+use_threads(void)
+{
+    pthread_t tid;
+    if (pthread_create(&tid, 0, thread_func, 0) != 0) {
+	return -1;
+    }
+    if (pthread_join(tid, 0) != 0) {
+	return -1;
+    }
+    return 0;
+}
+
+int
+main(int argc, char *argv[])
+{
+    pid_t pid;
+    if (use_threads()) return EXIT_FAILURE;
+    pid = fork();
+
+    if (pid) {
+	int loc;
+	sleep(1);
+	if (waitpid(pid, &loc, WNOHANG) == 0) {
+	    kill(pid, SIGKILL);
+	    return EXIT_FAILURE;
+	}
+        if (!WIFEXITED(loc) || WEXITSTATUS(loc) != EXIT_SUCCESS)
+           return EXIT_FAILURE;
+    }
+    else {
+	if (use_threads()) return EXIT_FAILURE;
+    }
+
+    return EXIT_SUCCESS;
+}]])],
+	rb_cv_fork_with_pthread=yes,
+	rb_cv_fork_with_pthread=no,
+	rb_cv_fork_with_pthread=yes)])
+    test x$rb_cv_fork_with_pthread = xyes || AC_DEFINE(CANNOT_FORK_WITH_PTHREAD)
+])
+}
+
+: "runtime section" && {
+dnl wheather use dln_a_out or not
+AC_ARG_WITH(dln-a-out,
+	AS_HELP_STRING([--with-dln-a-out], [use dln_a_out if possible]),
+	[
+	AS_CASE([$withval],
+	[yes], [
+	    AS_IF([test "$enable_shared" = yes], [
+		AC_MSG_ERROR(dln_a_out can not make shared library)
+	    ])
+	    with_dln_a_out=yes],
+	[
+	    with_dln_a_out=no])], [with_dln_a_out=no])
+
+AC_CACHE_CHECK(whether ELF binaries are produced, rb_cv_binary_elf,
+[AC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],[
+AS_CASE(["`head -1 conftest$EXEEXT | tr -dc '\177ELF' | tr '\177' .`"],
+[.ELF*], [rb_cv_binary_elf=yes], [rb_cv_binary_elf=no])],
+rb_cv_binary_elf=no)])
+
+AS_IF([test "$rb_cv_binary_elf" = yes], [
+  AC_DEFINE(USE_ELF)
+  AS_IF([test "$with_dln_a_out" = yes], [
+    AC_MSG_ERROR(dln_a_out does not work with ELF)
+  ])
+  AC_CHECK_HEADERS([elf.h elf_abi.h])
+  AS_IF([test $ac_cv_header_elf_h = yes -o $ac_cv_header_elf_abi_h = yes], [
+    AC_LIBOBJ([addr2line])
+    AS_IF([test "x$compress_debug_sections" = xzlib], [
+      AC_CHECK_LIB([z], [uncompress])
+    ])
+  ])
+])
+
+AC_CHECK_HEADERS([mach-o/loader.h])
+AS_IF([test "$ac_cv_header_mach_o_loader_h" = yes], [
+  AC_LIBOBJ([addr2line])
+])
+
+AS_CASE(["$target_os"],
+[linux* | gnu* | k*bsd*-gnu | bsdi* | kopensolaris*-gnu], [
+    AS_IF([test "$rb_cv_binary_elf" = no], [
+	with_dln_a_out=yes
+    ], [
+	LDFLAGS="$LDFLAGS -rdynamic"
+    ])])
+LIBEXT=a
+
+AC_SUBST(DLDFLAGS)dnl
+AC_SUBST(ARCH_FLAG)dnl
+AC_SUBST(MJIT_HEADER_FLAGS)dnl
+AC_SUBST(MJIT_HEADER_INSTALL_DIR)dnl
+AC_SUBST(MJIT_CC)dnl
+AS_IF([test "$GCC" = "yes"], [
+    AS_CASE(["$target_os"],[aix*],[mjit_std_cflag="-std=gnu99"])
+])
+AC_SUBST(MJIT_CFLAGS, [${MJIT_CFLAGS-"-w ${mjit_std_cflag} ${orig_cflags}"}])dnl
+AC_SUBST(MJIT_OPTFLAGS, [${MJIT_OPTFLAGS-'$(optflags)'}])dnl
+AC_SUBST(MJIT_DEBUGFLAGS, [${MJIT_DEBUGFLAGS-'$(debugflags)'}])dnl
+AC_SUBST(MJIT_LDSHARED)dnl
+
+AC_SUBST(STATIC)dnl
+AC_SUBST(CCDLFLAGS)dnl
+AC_SUBST(LDSHARED)dnl
+AC_SUBST(LDSHAREDXX)dnl
+AC_SUBST(DLEXT)dnl
+AC_SUBST(DLEXT2)dnl
+AC_SUBST(LIBEXT)dnl
+AC_SUBST(ASMEXT, S)dnl
+
+STATIC=
+
+AS_IF([test "$with_dln_a_out" != yes], [
+  rb_cv_dlopen=unknown
+  AC_MSG_CHECKING(whether OS depend dynamic link works)
+  AS_IF([test "$GCC" = yes], [
+    AS_CASE(["$target_os"],
+    [darwin*], [
+      # The -fno-common is needed if we wish to embed the Ruby interpreter
+      # into a plugin module of some project (as opposed to embedding it
+      # within the project's application).  The -I/usr/local/include is
+      # needed because CPP as discovered by configure (cc -E -traditional)
+      # fails to consult /usr/local/include by default.  This causes
+      # mkmf.rb's have_header() to fail if the desired resource happens to be
+      # installed in the /usr/local tree.
+      RUBY_APPEND_OPTION(CCDLFLAGS, -fno-common)],
+    [bsdi*|cygwin*|mingw*|aix*|interix*], [ ],
+    [
+      RUBY_APPEND_OPTION(CCDLFLAGS, -fPIC)])
+  ], [
+    AS_CASE(["$target_os"],
+	[hpux*],          [CCDLFLAGS="$CCDLFLAGS +Z"],
+	[solaris*|irix*], [CCDLFLAGS="$CCDLFLAGS -KPIC"],
+	[sunos*],         [CCDLFLAGS="$CCDLFLAGS -PIC"],
+	[esix*|uxpds*],   [CCDLFLAGS="$CCDLFLAGS -KPIC"],
+	                  [: ${CCDLFLAGS=""}])
+  ])
+
+
+  AC_ARG_ENABLE(rpath,
+       AS_HELP_STRING([--enable-rpath], [embed run path into extension libraries.
+       enabled by default on ELF platforms]),
+       [enable_rpath=$enableval], [enable_rpath="$rb_cv_binary_elf"])
+
+  AS_CASE(["$target_os"],
+	[hpux*], [	DLDFLAGS="$DLDFLAGS -E"
+			: ${LDSHARED='$(LD) -b'}
+			XLDFLAGS="$XLDFLAGS -Wl,-E"
+			: ${LIBPATHENV=SHLIB_PATH}
+			rb_cv_dlopen=yes],
+	[solaris*], [	AS_IF([test "$GCC" = yes], [
+			    : ${LDSHARED='$(CC) -shared'}
+			    AS_IF([test "$rb_cv_prog_gnu_ld" = yes], [
+				LDFLAGS="$LDFLAGS -Wl,-E"
+			    ])
+			], [
+			    : ${LDSHARED='$(CC) -G'}
+			])
+			AS_IF([test "$ac_cv_sizeof_voidp" = 8], [
+			    : ${LIBPATHENV=LD_LIBRARY_PATH_64}
+			    : ${PRELOADENV=LD_PRELOAD_64}
+			], [
+			    : ${LIBPATHENV=LD_LIBRARY_PATH_32}
+			    : ${PRELOADENV=LD_PRELOAD_32}
+			])
+			rb_cv_dlopen=yes],
+	[sunos*], [	: ${LDSHARED='$(LD) -assert nodefinitions'}
+			rb_cv_dlopen=yes],
+	[irix*], [	: ${LDSHARED='$(LD) -shared'}
+			rb_cv_dlopen=yes],
+	[sysv4*], [	: ${LDSHARED='$(LD) -G'}
+			rb_cv_dlopen=yes],
+	[nto-qnx*], [	: ${LDSHARED='$(CC) -shared'}
+			rb_cv_dlopen=yes],
+	[esix*|uxpds*], [ : ${LDSHARED='$(LD) -G'}
+			rb_cv_dlopen=yes],
+	[osf*], [	: ${LDSHARED='$(LD) -shared -expect_unresolved "*"'}
+			rb_cv_dlopen=yes],
+	[bsdi3*], [	AS_CASE(["$CC"],
+			[*shlicc*], [	: ${LDSHARED='$(CC) -r'}
+					rb_cv_dlopen=yes])],
+	[linux* | gnu* | k*bsd*-gnu | netbsd* | bsdi* | kopensolaris*-gnu | haiku*], [
+			: ${LDSHARED='$(CC) -shared'}
+			AS_IF([test "$rb_cv_binary_elf" = yes], [
+			    LDFLAGS="$LDFLAGS -Wl,-export-dynamic"
+			])
+			rb_cv_dlopen=yes],
+	[interix*], [	: ${LDSHARED='$(CC) -shared'}
+			XLDFLAGS="$XLDFLAGS -Wl,-E"
+			LIBPATHFLAG=" -L%1\$-s"
+			rb_cv_dlopen=yes],
+	[freebsd*|dragonfly*], [
+			: ${LDSHARED='$(CC) -shared'}
+			AS_IF([test "$rb_cv_binary_elf" = yes], [
+			    LDFLAGS="$LDFLAGS -rdynamic"
+			    DLDFLAGS="$DLDFLAGS "'-Wl,-soname,$@'
+			], [
+			  test "$GCC" = yes && test "$rb_cv_prog_gnu_ld" = yes || LDSHARED='$(LD) -Bshareable'
+			])
+			rb_cv_dlopen=yes],
+	[openbsd*|mirbsd*], [	: ${LDSHARED='$(CC) -shared ${CCDLFLAGS}'}
+			AS_IF([test "$rb_cv_binary_elf" = yes], [
+			    LDFLAGS="$LDFLAGS -Wl,-E"
+			])
+			rb_cv_dlopen=yes],
+	[darwin*], [	: ${LDSHARED='$(CC) -dynamic -bundle'}
+			: ${DLDSHARED='$(CC) -dynamiclib'}
+			: ${LDFLAGS=""}
+			: ${LIBPATHENV=DYLD_FALLBACK_LIBRARY_PATH}
+			: ${PRELOADENV=DYLD_INSERT_LIBRARIES}
+                        AS_IF([test x"$enable_shared" = xyes], [
+                            # Resolve symbols from libruby.dylib when --enable-shared
+                            EXTDLDFLAGS='$(LIBRUBYARG_SHARED)'
+                        ], [test "x$EXTSTATIC" = x], [
+                            # When building exts as bundles, a mach-o bundle needs to know its loader
+                            # program to bind symbols from the ruby executable
+                            EXTDLDFLAGS="-bundle_loader '\$(BUILTRUBY)'"
+			])
+			rb_cv_dlopen=yes],
+        [aix*], [	: ${LDSHARED='$(CC)'}
+			AS_IF([test "$GCC" = yes], [
+			    LDSHARED="$LDSHARED ${linker_flag}-G -shared"
+			], [
+			    LDSHARED="$LDSHARED ${linker_flag}-G"
+			])
+			EXTDLDFLAGS='-e$(TARGET_ENTRY)'
+			XLDFLAGS="${linker_flag}"'-bE:$(ARCHFILE)'" ${linker_flag}-brtl"
+			XLDFLAGS="$XLDFLAGS ${linker_flag}-blibpath:${prefix}/lib:${LIBPATH:-/usr/lib:/lib}"
+			: ${ARCHFILE="ruby.imp"}
+                        TRY_LINK='$(CC) -oconftest $(INCFLAGS) -I$(hdrdir) $(CPPFLAGS)'
+                        TRY_LINK="$TRY_LINK"' $(CFLAGS) $(src) $(LIBPATH) $(LDFLAGS) $(LOCAL_LIBS) $(LIBS)'
+			: ${LIBPATHENV=LIBPATH}
+			: ${PRELOADENV=LDR_PRELOAD}
+			rb_cv_dlopen=yes],
+	[nto-qnx*], [	DLDFLAGS="$DLDFLAGS -L/lib -L/usr/lib -L/usr/local/lib"
+			: ${LDSHARED='$(LD) -Bshareable -x'}
+			LDFLAGS="$LDFLAGS -L/lib -L/usr/lib -L/usr/local/lib"
+			rb_cv_dlopen=yes],
+	[cygwin*|mingw*], [
+			: ${LDSHARED='$(CC) -shared'}
+			XLDFLAGS="$XLDFLAGS -Wl,--stack,0x00200000,--enable-auto-import"
+			DLDFLAGS="${DLDFLAGS} -Wl,--enable-auto-image-base,--enable-auto-import"
+			: ${LIBPATHENV=PATH}
+			: ${PRELOADENV=""}
+			rb_cv_dlopen=yes],
+	[hiuxmpp], [	: ${LDSHARED='$(LD) -r'}],
+	[atheos*], [	: ${LDSHARED='$(CC) -shared'}
+			rb_cv_dlopen=yes],
+	[	: ${LDSHARED='$(LD)'}])
+  AC_MSG_RESULT($rb_cv_dlopen)
+
+  AS_IF([test "$rb_cv_dlopen" = yes], [
+    AS_CASE(["$target_os"],
+      [darwin*], [
+        AC_SUBST(ADDITIONAL_DLDFLAGS, "")
+	for flag in \
+	  "-multiply_defined suppress" \
+	  "-undefined dynamic_lookup" \
+	  ; do
+      test "x${linker_flag}" = x || flag="${linker_flag}`echo ${flag} | tr ' ' ,`"
+      RUBY_TRY_LDFLAGS([$flag], [], [$flag=])
+      AS_IF([test x"$flag" = x], [continue])
+
+      AC_MSG_CHECKING([whether $flag is accepted for bundle])
+      : > conftest.c
+      AS_IF([${LDSHARED/'$(CC)'/$CC} -o conftest.bundle $flag conftest.c >/dev/null 2>conftest.err &&
+          test ! -s conftest.err], [
+          AC_MSG_RESULT([yes])
+          RUBY_APPEND_OPTIONS(DLDFLAGS, [$flag])
+      ], [
+          AC_MSG_RESULT([no])
+          RUBY_APPEND_OPTIONS(ADDITIONAL_DLDFLAGS, [$flag])
+      ])
+      rm -fr conftest.*
+	done
+      ])
+  ])
+
+  AS_IF([test "$enable_rpath:${RPATHFLAG}" = yes:], [
+      AS_IF([test "x$rpathflag" != x], [
+	  RPATHFLAG=" ${rpathflag}%1\$-s"
+      ])
+  ])
+])
+AS_IF([test "${LDSHAREDXX}" = ""], [
+    AS_CASE(["${LDSHARED}"],
+	[*'$(CC)'*], [
+	    LDSHAREDXX=`echo "${LDSHARED}" | sed 's/\$(CC)/$(CXX)/'`
+	    ],
+	[*'${CC}'*], [
+	    LDSHAREDXX=`echo "${LDSHARED}" | sed 's/\${CC}/${CXX}/'`
+	    ],
+	[*$CC*], [
+	    LDSHAREDXX=`echo "${LDSHARED}" | sed "s|$CC|$CXX|"`
+	    ],
+	[ld" "*], [
+	    ])
+])
+AS_CASE([${RPATHFLAG}],[*'%1$'*],[: ${LIBPATHFLAG=' -L%1$-s'}],[: ${LIBPATHFLAG=' -L%s'}])
+
+AC_SUBST(LINK_SO)
+AC_SUBST(LIBPATHFLAG)
+AC_SUBST(RPATHFLAG)
+AC_SUBST(LIBPATHENV, "${LIBPATHENV-LD_LIBRARY_PATH}")
+AC_SUBST(PRELOADENV, "${PRELOADENV-LD_PRELOAD}")
+AC_SUBST(TRY_LINK)
+
+AS_IF([test "x$OPT_DIR" != x], [
+    pat=`echo "${LDFLAGS_OPTDIR}" | sed ['s/[][\\.*|]/\\\\&/']`
+    LDFLAGS=`echo "${LDFLAGS}" | sed "s| ${pat}||"`
+    val=`IFS="$PATH_SEPARATOR"
+        for dir in $OPT_DIR; do
+            echo x ${LIBPATHFLAG} ${RPATHFLAG} |
+            sed "s/^x *//;s${IFS}"'%1\\$-s'"${IFS}${dir}/lib${IFS}g;s${IFS}%s${IFS}${dir}/lib${IFS}g"
+        done | tr '\012' ' ' | sed 's/ *$//'`
+    AS_IF([test x"$val" != x], [
+	test x"${LDFLAGS}" = x || LDFLAGS="$LDFLAGS "
+	LDFLAGS="$LDFLAGS$val"
+	test x"${DLDFLAGS}" = x || DLDFLAGS="$DLDFLAGS "
+	DLDFLAGS="$DLDFLAGS$val"
+    ])
+    LDFLAGS_OPTDIR="$val"
+])
+
+AS_CASE(["$target_os"],
+[freebsd*], [
+    AC_CHECK_LIB([procstat], [procstat_open_sysctl])
+    AS_IF([test "x$ac_cv_lib_procstat_procstat_open_sysctl" = xyes], [
+	AC_CHECK_FUNCS(procstat_getvmmap)
+    ])
+    ])
+AS_CASE(["$target_cpu-$target_os"],
+[*-darwin*], [
+    AC_CHECK_HEADERS([libproc.h])
+    AC_CHECK_HEADERS([execinfo.h])
+    AS_IF([test "x$ac_cv_header_execinfo_h" = xyes], [
+	AC_CHECK_LIB([execinfo], [backtrace])
+	AC_CHECK_HEADERS([libunwind.h])
+    ])],
+[*-freebsd*|x86_64-netbsd*], [
+    AC_CHECK_HEADERS([execinfo.h])
+    AS_IF([test "x$ac_cv_header_execinfo_h" = xyes], [
+	AC_CHECK_LIB([execinfo], [backtrace])
+	AC_CHECK_LIB([unwind], [unw_backtrace])
+    ])])
+AC_CHECK_FUNCS(backtrace)
+
+AS_IF([test "x$ac_cv_func_backtrace" = xyes], [
+  AC_CACHE_CHECK(for broken backtrace, rb_cv_broken_backtrace,
+    [AC_RUN_IFELSE([AC_LANG_SOURCE([[
+#include <unistd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <signal.h>
+#include <execinfo.h>
+
+#define TRACE_SIZE 256
+
+void sigsegv(int signum, siginfo_t *info, void *ctx){
+    void *trace[TRACE_SIZE];
+    int n = backtrace(trace, TRACE_SIZE);
+    if (n > 0) {
+	/*fprintf(stdout, "backtrace:%d\n",n);*/
+    } else {
+	_exit(EXIT_FAILURE);
+    }
+    _exit(EXIT_SUCCESS);
+}
+int
+main(void)
+{
+    volatile int *a = NULL;
+    stack_t ss;
+    struct sigaction sa;
+
+    ss.ss_sp = malloc(16*1024);
+    if (ss.ss_sp == NULL) {
+	fprintf(stderr, "cannot allocate memory for sigaltstack\n");
+	return EXIT_FAILURE;
+    }
+    ss.ss_size = 16*1024;
+    ss.ss_flags = 0;
+    if (sigaltstack(&ss, NULL) == -1) {
+	fprintf(stderr, "sigaltstack failed\n");
+	return EXIT_FAILURE;
+    }
+    memset(&sa, 0, sizeof(struct sigaction));
+    sigemptyset(&sa.sa_mask);
+    sa.sa_sigaction = sigsegv;
+    sa.sa_flags |= SA_SIGINFO;
+    sa.sa_flags |= SA_ONSTACK;
+    sigaction(SIGSEGV, &sa, NULL);
+    a[0] = 1;
+    return EXIT_SUCCESS;
+}
+]])],
+	rb_cv_broken_backtrace=no,
+	rb_cv_broken_backtrace=yes,
+	rb_cv_broken_backtrace=no)])
+  AS_IF([test "$rb_cv_broken_backtrace" = yes], [
+    AC_DEFINE(BROKEN_BACKTRACE, 1)
+  ])
+])
+
+AC_ARG_WITH(valgrind,
+        AS_HELP_STRING([--without-valgrind],[disable valgrind memcheck support]),
+        [], with_valgrind=yes)
+AS_IF([test x$with_valgrind != xno],
+        [AC_CHECK_HEADERS(valgrind/memcheck.h)])
+
+dln_a_out_works=no
+AS_IF([test "$ac_cv_header_a_out_h" = yes], [
+  AS_IF([test "$with_dln_a_out" = yes || test "$rb_cv_dlopen" = unknown], [
+    cat confdefs.h > config.h
+    AC_CACHE_CHECK(whether matz's dln works, rb_cv_dln_a_out,
+    [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
+#define USE_DLN_A_OUT
+#include "dln.c"
+]], [[]])],
+	rb_cv_dln_a_out=yes,
+	rb_cv_dln_a_out=no)])
+    AS_IF([test "$rb_cv_dln_a_out" = yes], [
+      dln_a_out_works=yes
+      AC_DEFINE(USE_DLN_A_OUT)
+    ])
+  ])
+])
+
+AS_IF([test "$dln_a_out_works" = yes], [
+  AS_IF([test "$GCC" = yes], [
+    STATIC=-static
+  ], [
+    STATIC=-Bstatic
+  ])
+  DLEXT=so
+  CCDLFLAGS=
+], [
+  AS_CASE(["$target_os"],
+    [hpux*], [
+	DLEXT=sl],
+    [darwin*], [
+	SOEXT=dylib
+	DLEXT=bundle],
+    [cygwin*|mingw*|*djgpp*], [
+	LOAD_RELATIVE=1
+	SOEXT=dll
+	DLEXT=so],
+    [
+	DLEXT=so])
+])
+: ${SOEXT="${DLEXT}"}
+AC_SUBST(SOEXT)
+AS_IF([test "$rb_cv_dlopen:$load_relative" = yes:yes], [
+    AS_IF([test "$ac_cv_func_dladdr" = yes], [
+	LOAD_RELATIVE=1
+    ])
+])
+AS_IF([test x"$LOAD_RELATIVE" = x1], [
+    load_relative=yes
+], [
+    unset load_relative
+])
+
+len=2 # .rb
+n=`expr "$DLEXT"  : '.*'`; test "$n" -gt "$len" && len=$n
+n=`expr "$DLEXT2" : '.*'`; test "$n" -gt "$len" && len=$n
+AC_DEFINE_UNQUOTED(DLEXT_MAXLEN, `expr $len + 1`)
+test ".$DLEXT"  = "." || AC_DEFINE_UNQUOTED(DLEXT,  ".$DLEXT")
+test ".$DLEXT2" = "." || AC_DEFINE_UNQUOTED(DLEXT2, ".$DLEXT2")
+AC_SUBST(DLEXT)
+
+AS_IF([test "$with_dln_a_out" = yes], [
+  STRIP=true
+], [
+  AC_CHECK_TOOL(STRIP, strip, :)dnl
+])
+
+AS_CASE(["$target_os"],
+  [linux* | gnu* | k*bsd*-gnu | kopensolaris*-gnu], [
+	STRIP="$STRIP -S -x"],
+  [darwin*], [
+	STRIP="$STRIP -A -n"])
+
+AC_ARG_WITH(ext,
+            AS_HELP_STRING([--with-ext=EXTS],
+                           [pass to --with-ext option of extmk.rb]))
+AC_ARG_WITH(out-ext,
+            AS_HELP_STRING([--with-out-ext=EXTS],
+                           [pass to --without-ext option of extmk.rb]))
+EXTSTATIC=
+AC_SUBST(EXTSTATIC)dnl
+AC_ARG_WITH(static-linked-ext,
+	    AS_HELP_STRING([--with-static-linked-ext], [link external modules statically]),
+            [AS_CASE([$withval],[yes],[STATIC=;EXTSTATIC=static],[no],[],[EXTSTATIC="$withval"])])
+AS_CASE([",$EXTSTATIC,"], [,static,|*,enc,*], [
+  ENCOBJS='enc/encinit.$(OBJEXT) enc/libenc.$(LIBEXT) enc/libtrans.$(LIBEXT)'
+  EXTOBJS='ext/extinit.$(OBJEXT)'
+  AC_DEFINE_UNQUOTED(EXTSTATIC, 1)
+  AC_SUBST(ENCSTATIC, static)
+], [
+  ENCOBJS='dmyenc.$(OBJEXT)'
+  EXTOBJS='dmyext.$(OBJEXT)'
+])
+AC_SUBST(ENCOBJS)
+AC_SUBST(EXTOBJS)
+
+AC_ARG_WITH(setup,
+	    AS_HELP_STRING([--with-setup=SETUP], [use extension libraries setup]),
+	    [setup=$withval])
+AS_IF([test -n "$setup"], [
+    AS_IF([! test -f "ext/$setup" -o -f "$srcdir/ext/$setup"], [
+	AC_MSG_ERROR(Setup file $setup not found under ext or $srcdir/ext)
+    ])
+], [test -f "$srcdir/ext/Setup.$target_os"], [
+    setup="Setup.$target_os"
+], [
+    setup=
+    for file in "$srcdir"/ext/Setup.*; do
+	AS_CASE(["$file"], [*~|*.bak|*.orig|*.rej|*.tmp], [continue])
+	setup=`basename "$file"`
+	AS_CASE(["$target_os"], [`expr "$setup" : 'Setup.\(.*\)'`*], [break])
+	platform=`sed '/^option  *platform  */!d;s///;s/|/*|/g;q' "$file"`
+	AS_IF([test "x$platform" != x], [
+	    eval "AS_CASE([\"\$target_os\"], [$platform*], [break])"
+	])
+	setup=
+    done
+    : ${setup:=Setup}
+])
+AC_SUBST(setup)
+
+rubylibprefix='${libdir}/${RUBY_BASE_NAME}'
+AC_ARG_WITH(rubylibprefix,
+	    AS_HELP_STRING([--with-rubylibprefix=DIR], [prefix for ruby libraries [[LIBDIR/RUBY_BASE_NAME]]]),
+	    [AS_IF([test "x$withval" = xno], [
+		AC_MSG_ERROR([No ruby, No libprefix])
+	    ])
+	    rubylibprefix="$withval"])
+AC_SUBST(rubylibprefix)
+
+AS_IF([test x"${exec_prefix}" != xNONE], [
+    RUBY_EXEC_PREFIX="$exec_prefix"
+], [test x"$prefix" != xNONE], [
+    RUBY_EXEC_PREFIX="$prefix"
+], [
+    RUBY_EXEC_PREFIX=$ac_default_prefix
+])
+pat=`echo "${RUBY_EXEC_PREFIX}" | tr -c '\012' .`'\(.*\)'
+for var in bindir libdir rubylibprefix; do
+    eval val='"$'$var'"'
+    AS_CASE(["$val"], ["${RUBY_EXEC_PREFIX}"*], [val='${exec_prefix}'"`expr \"$val\" : \"$pat\"`"])
+    eval $var='"$val"'
+done
+
+BTESTRUBY='$(MINIRUBY)'
+BOOTSTRAPRUBY='$(BASERUBY)'
+AS_IF([test x"$cross_compiling" = xyes], [
+  test x"$MINIRUBY" = x && MINIRUBY="${RUBY-$BASERUBY} -I`$CHDIR .; pwd` "-r'$(arch)-fake'
+  XRUBY_LIBDIR=`${RUBY-$BASERUBY} -rrbconfig -e ['puts RbConfig::CONFIG["libdir"]']`
+  XRUBY_RUBYLIBDIR=`${RUBY-$BASERUBY} -rrbconfig -e ['puts RbConfig::CONFIG["rubylibdir"]']`
+  XRUBY_RUBYHDRDIR=`${RUBY-$BASERUBY} -rrbconfig -e ['puts RbConfig::CONFIG["rubyhdrdir"]']`
+  AC_SUBST(XRUBY_LIBDIR)
+  AC_SUBST(XRUBY_RUBYLIBDIR)
+  AC_SUBST(XRUBY_RUBYHDRDIR)
+  PREP='$(arch)-fake.rb'
+  RUNRUBY_COMMAND='$(MINIRUBY) -I`cd $(srcdir)/lib; pwd`'
+  RUNRUBY='$(RUNRUBY_COMMAND)'
+  XRUBY='$(MINIRUBY)'
+  TEST_RUNNABLE=no
+  CROSS_COMPILING=yes
+  AC_DEFINE(CROSS_COMPILING, 1)
+], [
+  MINIRUBY='./miniruby$(EXEEXT) -I$(srcdir)/lib -I.'
+  MINIRUBY="$MINIRUBY"' -I$(EXTOUT)/common'
+  PREP='miniruby$(EXEEXT)'
+  RUNRUBY_COMMAND='$(MINIRUBY) $(srcdir)/tool/runruby.rb --extout=$(EXTOUT) $(RUNRUBYOPT)'
+  RUNRUBY='$(RUNRUBY_COMMAND) --'
+  XRUBY='$(RUNRUBY)'
+  AS_CASE(["$HAVE_BASERUBY:$build_os"], [no:*|*:mingw*], [BOOTSTRAPRUBY='$(MINIRUBY)'])
+  TEST_RUNNABLE=yes
+  CROSS_COMPILING=no
+])
+AC_SUBST(TEST_RUNNABLE)
+AC_SUBST(CROSS_COMPILING)
+AC_SUBST(MINIRUBY)
+AC_SUBST(BTESTRUBY)
+AC_SUBST(PREP)
+AC_SUBST(RUNRUBY_COMMAND)
+AC_SUBST(RUNRUBY)
+AC_SUBST(XRUBY)
+AC_SUBST(BOOTSTRAPRUBY)
+AC_SUBST(EXTOUT, [${EXTOUT=.ext}])
+
+FIRSTMAKEFILE=""
+LIBRUBY_A='lib$(RUBY_SO_NAME)-static.a'
+LIBRUBY='$(LIBRUBY_A)'
+LIBRUBYARG_STATIC='-l$(RUBY_SO_NAME)-static'
+LIBRUBYARG='$(LIBRUBYARG_STATIC)'
+SOLIBS='$(MAINLIBS)'
+
+AS_CASE(["$target_os"],
+  [cygwin*|mingw*|haiku*|darwin*], [
+    : ${DLDLIBS=""}
+    ],
+  [
+    DLDLIBS="$DLDLIBS -lc"
+    ])
+
+AC_ARG_ENABLE(multiarch,
+	      AS_HELP_STRING([--enable-multiarch], [enable multiarch compatible directories]),
+	      [multiarch=], [unset multiarch])
+AS_IF([test ${multiarch+set}], [
+   AC_DEFINE(ENABLE_MULTIARCH)
+   MJIT_HEADER_INSTALL_DIR=include/'${arch}/${RUBY_VERSION_NAME}'
+], [
+   MJIT_HEADER_INSTALL_DIR=include/'${RUBY_VERSION_NAME}/${arch}'
+])
+
+archlibdir='${libdir}/${arch}'
+AC_ARG_WITH(archlibdir,
+	    AS_HELP_STRING([--with-archlibdir=DIR],
+			   [prefix for libruby [[LIBDIR/ARCH]]]),
+	    [archlibdir="$withval"])
+
+sitearchlibdir='${libdir}/${sitearch}'
+archincludedir='${includedir}/${arch}'
+sitearchincludedir='${includedir}/${sitearch}'
+
+AC_ARG_WITH(soname,
+	AS_HELP_STRING([--with-soname=SONAME], [base name of shared library]),
+	[RUBY_SO_NAME=$withval],
+	[
+	    AS_CASE(["$target_os"],
+	    [darwin*], [
+	        RUBY_SO_NAME='$(RUBY_BASE_NAME).$(RUBY_API_VERSION)'
+	    ],
+	    [cygwin*], [
+	        RUBY_SO_NAME='$(RUBY_BASE_NAME)$(MAJOR)$(MINOR)0'
+	    ],
+	    [mingw*], [
+		RUBY_SO_NAME="${rb_cv_msvcrt}"'-$(RUBY_BASE_NAME)$(MAJOR)$(MINOR)0'
+		AS_IF([test x"${target_cpu}" != xi386], [
+		    RUBY_SO_NAME="${target_cpu}-${RUBY_SO_NAME}"
+		])
+	    ],
+	    [RUBY_SO_NAME='$(RUBY_BASE_NAME)'])
+	])
+
+LIBRUBY_LDSHARED=${DLDSHARED=${LDSHARED}}
+LIBRUBY_DLDFLAGS=$DLDFLAGS
+LIBRUBY_SO='lib$(RUBY_SO_NAME).$(SOEXT).$(RUBY_PROGRAM_VERSION)'
+LIBRUBY_SONAME='lib$(RUBY_SO_NAME).$(SOEXT).$(RUBY_API_VERSION)'
+LIBRUBY_ALIASES='lib$(RUBY_SO_NAME).$(SOEXT)'
+ENABLE_SHARED=no
+
+AC_ARG_ENABLE(shared,
+       AS_HELP_STRING([--enable-shared], [build a shared library for Ruby]),
+       [enable_shared=$enableval])
+libprefix=${multiarch+'$(archlibdir)'}${multiarch-'$(libdir)'}
+LIBRUBY_RELATIVE=${load_relative-no}
+AS_CASE("$enable_shared", [yes], [
+  LIBRUBY='$(LIBRUBY_SO)'
+  LIBRUBYARG_SHARED='-l$(RUBY_SO_NAME)'
+  LIBRUBYARG='$(LIBRUBYARG_SHARED)'
+  LIBRUBY_RELATIVE=no
+  test -z "$CCDLFLAGS" || CFLAGS="$CFLAGS $CCDLFLAGS"
+  ENABLE_SHARED=yes
+
+  # libdir can be overridden in config.site file (on OpenSUSE at least).
+  libdir_basename=lib
+  AS_IF([test "$bindir" = '${exec_prefix}/bin'], [
+    AS_CASE(["$libdir"], ['${exec_prefix}/'*], [libdir_basename=`basename "$libdir"`])
+  ])
+  AC_DEFINE_UNQUOTED(LIBDIR_BASENAME, ["${libdir_basename}"])
+  libdir_basename="${libdir_basename}"${multiarch+'/${arch}'}
+
+  AS_CASE(["$target_os"],
+    [freebsd*|dragonfly*], [],
+    [
+     AS_IF([test "$GCC" = yes], [
+       RUBY_TRY_LDFLAGS([${linker_flag}--no-undefined], [no_undefined=yes], [no_undefined=no])
+       AS_IF([test "no_undefined" = yes], [
+	  RUBY_APPEND_OPTION(EXTLDFLAGS, [${linker_flag}--no-undefined])
+       ])
+     ])
+    ])
+
+  AS_CASE(["$target_os"],
+    [sunos4*], [
+	LIBRUBY_ALIASES='$(LIBRUBY_SONAME) lib$(RUBY_SO_NAME).$(SOEXT)'
+	],
+    [linux* | gnu* | k*bsd*-gnu | atheos* | kopensolaris*-gnu | haiku*], [
+	RUBY_APPEND_OPTIONS(LIBRUBY_DLDFLAGS, ['-Wl,-soname,$(LIBRUBY_SONAME)' "$LDFLAGS_OPTDIR"])
+	LIBRUBY_ALIASES='$(LIBRUBY_SONAME) lib$(RUBY_SO_NAME).$(SOEXT)'
+	AS_IF([test "$load_relative" = yes], [
+	    libprefix="'\$\${ORIGIN}/../${libdir_basename}'"
+	    LIBRUBY_RPATHFLAGS="-Wl,-rpath,${libprefix}"
+	    LIBRUBY_RELATIVE=yes
+	])
+	],
+    [freebsd*|dragonfly*], [
+	LIBRUBY_SO='lib$(RUBY_SO_NAME).$(SOEXT).$(MAJOR)$(MINOR)'
+	LIBRUBY_SONAME='$(LIBRUBY_SO)'
+	AS_IF([test "$rb_cv_binary_elf" != "yes" ], [
+	    LIBRUBY_SO="$LIBRUBY_SO.\$(TEENY)"
+	    LIBRUBY_ALIASES=''
+	])
+	],
+    [netbsd*], [
+	LIBRUBY_SONAME='lib$(RUBY_SO_NAME).$(SOEXT).$(MAJOR)$(MINOR)'
+	LIBRUBY_SO="${LIBRUBY_SONAME}"'.$(TEENY)'
+	RUBY_APPEND_OPTIONS(LIBRUBY_DLDFLAGS, ['-Wl,-soname,$(LIBRUBY_SONAME)' "$LDFLAGS_OPTDIR"])
+	AS_IF([test "$rb_cv_binary_elf" = yes], [ # ELF platforms
+	   LIBRUBY_ALIASES='$(LIBRUBY_SONAME) lib$(RUBY_SO_NAME).$(SOEXT)'
+	], [	# a.out platforms
+	   LIBRUBY_ALIASES=""
+	])
+	],
+    [openbsd*|mirbsd*], [
+	LIBRUBY_SO='lib$(RUBY_SO_NAME).$(SOEXT).$(MAJOR).'`expr ${MINOR} \* 10 + ${TEENY}`
+	],
+    [solaris*], [
+	LIBRUBY_SO='lib$(RUBY_SO_NAME).$(SOEXT).$(MAJOR)'
+	LIBRUBY_SONAME='lib$(RUBY_SO_NAME).$(SOEXT).$(RUBY_PROGRAM_VERSION)'
+	LIBRUBY_ALIASES='$(LIBRUBY_SONAME) lib$(RUBY_SO_NAME).$(SOEXT)'
+	RUBY_APPEND_OPTIONS(LIBRUBY_DLDFLAGS, ["${linker_flag}-h${linker_flag:+,}"'$(@F)'])
+	XLDFLAGS="$XLDFLAGS "'-R${libdir}'
+	],
+    [hpux*], [
+	XLDFLAGS="$XLDFLAGS "'-Wl,+s,+b,$(libdir)'
+	LIBRUBY_ALIASES='$(LIBRUBY_SONAME) lib$(RUBY_SO_NAME).$(SOEXT)'
+	],
+    [aix*], [
+	RUBY_APPEND_OPTIONS(LIBRUBY_DLDFLAGS, ["${linker_flag}-bnoentry" "$XLDFLAGS" "$LDFLAGS_OPTDIR"])
+	LIBRUBYARG_SHARED='-L${libdir} -l${RUBY_SO_NAME}'
+	LIBS="$LIBS -lm -lc"
+	],
+    [darwin*], [
+	LIBRUBY_SO='lib$(RUBY_SO_NAME).$(SOEXT)'
+	LIBRUBY_SONAME='$(LIBRUBY_SO)'
+	LIBRUBY_ALIASES='lib$(RUBY_INSTALL_NAME).$(SOEXT)'
+	AS_IF([test "$load_relative" = yes], [
+	    libprefix="@executable_path/../${libdir_basename}"
+	    LIBRUBY_RELATIVE=yes
+	])
+	LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS -install_name ${libprefix}"'/$(LIBRUBY_SONAME)'
+	LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "'-compatibility_version $(RUBY_API_VERSION)'
+	LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "'-current_version $(RUBY_PROGRAM_VERSION)'
+	AS_IF([test "$visibility_option" = ld], [
+	    LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "'-Wl,-unexported_symbol,_Init_*'
+	    LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "'-Wl,-unexported_symbol,_ruby_static_id_*'
+	    LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "'-Wl,-unexported_symbol,*_threadptr_*'
+	])
+	LIBRUBY_DLDFLAGS="$LIBRUBY_DLDFLAGS "' $(XLDFLAGS)'
+	],
+    [interix*], [
+	LIBRUBYARG_SHARED='-L. -L${libdir} -l$(RUBY_SO_NAME)'
+	],
+    [mingw*|cygwin*|mswin*], [
+	LIBRUBY_RELATIVE=yes
+	])
+], [
+  LIBRUBYARG_SHARED=
+
+  # enable PIE if possible
+  AC_ARG_ENABLE(pie,
+          AS_HELP_STRING([--disable-pie], [disable PIE feature]),
+          [pie=$enableval], [pie=])
+  AS_IF([test "$GCC" = yes -a -z "$EXTSTATIC" -a "x$pie" != xno], [
+    RUBY_TRY_CFLAGS(-fPIE, [pie=yes], [pie=no])
+    AS_IF([test "$pie" = yes], [
+      # Use -fPIE when testing -pie.  RUBY_TRY_LDFLAGS sets
+      # $save_CFLAGS internally, so set other name here.
+      save_CFLAGS_before_pie="$CFLAGS"
+      CFLAGS="$CFLAGS -fPIE"
+
+      # gcc need -pie but clang need -Wl,-pie.
+      for pie in -pie -Wl,-pie; do
+	RUBY_TRY_LDFLAGS([$pie], [], [pie=])
+	AS_IF([test "x$pie" != x], [
+	  RUBY_APPEND_OPTION(XCFLAGS, -fPIE)
+	  RUBY_APPEND_OPTION(XLDFLAGS, $pie)
+	  break
+	])
+      done
+      CFLAGS="$save_CFLAGS_before_pie"
+    ])
+  ])
+])
+AS_IF([test "$enable_rpath" = yes], [
+    test -z "$LIBRUBY_RPATHFLAGS" || LIBRUBY_RPATHFLAGS="$LIBRUBY_RPATHFLAGS "
+    rpathflag="${RPATHFLAG}"
+    AS_CASE(["${cross_compiling}${load_relative}"], [*yes*], [], [rpathflag="$RPATHFLAG$LIBPATHFLAG"])
+    rpathflag=`IFS="$PATH_SEPARATOR"
+        echo x "$rpathflag" |
+        sed "s/^x *//;s${IFS}"'%1\\$-s'"${IFS}${libprefix}${IFS}g;s${IFS}%s${IFS}${libprefix}${IFS}g"
+    `
+    LIBRUBY_RPATHFLAGS="$LIBRUBY_RPATHFLAGS${rpathflag}"
+    LIBRUBYARG_SHARED="$LIBRUBY_RPATHFLAGS $LIBRUBYARG_SHARED"
+    LIBRUBYARG_STATIC="$LIBRUBY_RPATHFLAGS $LIBRUBYARG_STATIC"
+])
+AC_SUBST(LIBRUBY_RELATIVE)
+
+LDFLAGS="-L. $LDFLAGS"
+AC_SUBST(ARCHFILE)
+
+AS_IF([test "$EXEEXT" = .exe], [
+    EXECUTABLE_EXTS='".exe",".com",".cmd",".bat"'
+    AC_DEFINE_UNQUOTED(EXECUTABLE_EXTS, $EXECUTABLE_EXTS)
+    EXECUTABLE_EXTS=`echo $EXECUTABLE_EXTS | tr -d '"' | tr , ' '`
+    AC_SUBST(EXECUTABLE_EXTS)
+])
+
+AS_CASE("$cross_compiling:${LIBPATHENV}", [yes:* | no:], [], [
+    AC_MSG_CHECKING(whether wrapper for $LIBPATHENV is needed)
+    AS_IF([env ${LIBPATHENV}=/lib /bin/sh -c ': ${'${LIBPATHENV}'?}' 2>/dev/null],
+	[AC_MSG_RESULT(no)],
+	[PREP="$PREP"' exe/$(PROGRAM)'
+	AC_MSG_RESULT(yes)]
+    )
+])
+
+AC_ARG_ENABLE(dtrace,
+        AS_HELP_STRING([--enable-dtrace],
+        [enable DTrace for tracing inside ruby. enabled by default on systems having dtrace]),
+        [enable_dtrace=$enableval], [enable_dtrace=auto])
+
+LIBRUBY_A_OBJS='$(OBJS)'
+DTRACE_REBUILD=
+AS_CASE(["${enable_dtrace}"],
+[yes|auto], [
+    RUBY_DTRACE_AVAILABLE()
+], [
+    rb_cv_dtrace_available=no
+])
+AS_IF([test "${enable_dtrace}" = yes], [dnl
+    AS_IF([test -z "$DTRACE"], [dnl
+	AC_MSG_ERROR([dtrace(1) is missing])
+    ], [test "$cross_compiling" = yes], [dnl
+	AC_MSG_ERROR([--enable-dtrace, however, cross compiling])
+    ], [test "${rb_cv_dtrace_available}" = "no"], [dnl
+       AC_MSG_ERROR([--enable-dtrace, however, USDT is not available])
+    ])
+])
+AS_CASE([$rb_cv_dtrace_available],
+[yes*], [dnl
+    RUBY_DTRACE_POSTPROCESS()
+    AS_IF([test "$rb_cv_prog_dtrace_g" != no], [dnl
+	DTRACE_OBJ='probes.$(OBJEXT)'
+    ])
+    AS_IF([test "$rb_cv_prog_dtrace_g" = rebuild], [dnl
+	DTRACE_REBUILD=yes
+	LIBRUBY_A_OBJS='$(DTRACE_GLOMMED_OBJ)'
+    ])
+    AS_CASE("${target_os}", [freebsd*], [dnl
+        # FreeBSD's dtrace requires libelf
+        LIBS="-lelf $LIBS"
+    ])
+    DTRACE_EXT=d
+], [dnl
+    enable_dtrace=no
+    DTRACE_EXT=dmyh
+])
+AC_SUBST(DTRACE_EXT)
+AC_SUBST(DTRACE_OBJ)
+AC_SUBST(DTRACE_REBUILD)
+AC_SUBST(DTRACE_OPT)
+AC_SUBST(LIBRUBY_A_OBJS)
+
+AC_ARG_ENABLE(gcov,
+       AS_HELP_STRING([--enable-gcov], [enable coverage measurement by gcov]),
+       [gcov=yes])
+AS_IF([test x"$gcov" = xyes], [
+    CFLAGS="$CFLAGS -coverage"
+    LDFLAGS="$LDFLAGS -coverage"
+])
+
+RUBY_SETJMP_TYPE
+}
+
+: "build section" && {
+dnl build rdoc index if requested
+RDOCTARGET=""
+CAPITARGET=""
+AC_ARG_ENABLE(install-doc,
+       AS_HELP_STRING([--disable-install-doc], [do not install either rdoc indexes or C API documents during install]),
+       [install_doc=$enableval], [install_doc=yes])
+AC_ARG_WITH(rdoc,
+      AS_HELP_STRING([--with-rdoc=ri,html], [comma/space separated list of RDoc formats to install]),
+      [install_rdoc=`echo ,$withval, | sed 'y/,/ /;s/ ri / rdoc /;s/^ *//;s/ *$//'`], [
+AC_ARG_ENABLE(install-rdoc,
+      AS_HELP_STRING([--disable-install-rdoc], [do not install rdoc indexes during install]),
+      [install_rdoc=$enableval], [install_rdoc=yes])
+])
+AC_ARG_ENABLE(install-capi,
+      AS_HELP_STRING([--disable-install-capi], [do not install C API documents during install]),
+      [install_capi=$enableval], [install_capi=no])
+
+AS_IF([test "$install_doc" != no], [
+    AS_CASE(["$install_rdoc"],
+    [yes], [
+	RDOCTARGET="rdoc"
+    ],
+    [all], [
+	RDOCTARGET="rdoc html"
+    ],
+    [no|''], [
+	RDOCTARGET="nodoc"
+    ],
+    [
+	RDOCTARGET="$install_rdoc"
+    ])
+    AS_IF([test "$install_capi" != no -a -n "$DOXYGEN"], [
+	CAPITARGET="capi"
+    ], [
+	CAPITARGET="nodoc"
+    ])
+], [
+    RDOCTARGET="nodoc"
+    CAPITARGET="nodoc"
+])
+
+AC_SUBST(RDOCTARGET)
+AC_SUBST(CAPITARGET)
+
+AS_CASE(["$RDOCTARGET:$CAPITARGET"],[nodoc:nodoc],[INSTALLDOC=nodoc],[INSTALLDOC=all])
+AC_SUBST(INSTALLDOC)
+
+AC_ARG_ENABLE(jit-support,
+        AS_HELP_STRING([--disable-jit-support], [disable JIT features]),
+        [MJIT_SUPPORT=$enableval
+         AS_IF([test x"$enable_jit_support" = "xyes"],
+                 [AC_DEFINE(USE_MJIT, 1)],
+                 [AC_DEFINE(USE_MJIT, 0)])],
+        [MJIT_SUPPORT=yes
+         AC_DEFINE(USE_MJIT, 1)])
+
+AC_SUBST(MJIT_SUPPORT)
+
+AC_ARG_ENABLE(install-static-library,
+	AS_HELP_STRING([--disable-install-static-library], [do not install static ruby library]),
+	[INSTALL_STATIC_LIBRARY=$enableval],
+	AS_IF([test x"$enable_shared" = xyes],
+	    [INSTALL_STATIC_LIBRARY=no],
+	    [INSTALL_STATIC_LIBRARY=yes]))
+AC_SUBST(INSTALL_STATIC_LIBRARY)
+
+AS_IF([test "$rb_with_pthread" = "yes"], [
+    THREAD_MODEL=pthread
+])
+AC_CACHE_CHECK([for prefix of external symbols], rb_cv_symbol_prefix, [
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[extern void conftest_external(void) {}]], [[]])],[
+	rb_cv_symbol_prefix=`$NM conftest.$ac_objext |
+			     sed -n ['/.*T[ 	]\([^ 	]*\)conftest_external.*/!d;s//\1/p;q']`
+	],
+	[rb_cv_symbol_prefix=''])
+    test -n "$rb_cv_symbol_prefix" || rb_cv_symbol_prefix=NONE
+])
+SYMBOL_PREFIX="$rb_cv_symbol_prefix"
+test "x$SYMBOL_PREFIX" = xNONE && SYMBOL_PREFIX=''
+DLNOBJ=dln.o
+AC_ARG_ENABLE(dln,
+	      AS_HELP_STRING([--disable-dln], [disable dynamic link feature]),
+	      [test "$enableval" = yes || DLNOBJ=dmydln.o])
+AC_SUBST(DLNOBJ)
+MINIDLNOBJ=dmydln.o
+
+AS_CASE(["$target_os"],
+    [linux*], [
+	],
+    [netbsd*], [
+	RUBY_APPEND_OPTION(CFLAGS, -pipe)
+	],
+    [darwin*], [
+	RUBY_APPEND_OPTION(CFLAGS, -pipe)
+	AC_COMPILE_IFELSE([
+	    AC_LANG_BOOL_COMPILE_TRY([@%:@include <AvailabilityMacros.h>],
+		[MAC_OS_X_VERSION_MIN_REQUIRED >= MAC_OS_X_VERSION_10_7])],
+	    [dnl
+		RUBY_APPEND_OPTION(XLDFLAGS, [-framework Security])
+		RUBY_APPEND_OPTION(LIBRUBYARG_STATIC, [-framework Security])
+	    ]dnl
+	)
+	RUBY_APPEND_OPTION(XLDFLAGS, [-framework Foundation])
+	RUBY_APPEND_OPTION(LIBRUBYARG_STATIC, [-framework Foundation])
+	],
+    [osf*], [
+	AS_IF([test "$GCC" != "yes" ], [
+	  # compile something small: taint.c is fine for this.
+	  # the main point is the '-v' flag of 'cc'.
+	  AS_CASE(["`cc -v -I. -c main.c -o /tmp/main.o 2>&1`"],
+	  [*/gemc_cc*], [   # we have the new DEC GEM CC
+                        CFLAGS="$CFLAGS -oldc"
+                        ],
+          [            # we have the old MIPS CC
+                        ])
+	  # cleanup
+	  rm -f /tmp/main.o
+	  CFLAGS="$CFLAGS -std"
+	])
+	],
+    [cygwin*|mingw*], [
+	LIBRUBY_DLDFLAGS="${LIBRUBY_DLDFLAGS}"' -Wl,--out-implib=$(LIBRUBY)'
+	AS_CASE(["$target_os"],
+	[cygwin*], [
+	    AS_IF([test x"$enable_shared" = xyes], [
+		LIBRUBY_SO='cyg$(RUBY_SO_NAME)'.dll
+		LIBRUBY_DLDFLAGS="${LIBRUBY_DLDFLAGS}"' $(RUBYDEF)'
+	    ])
+	    ],
+	[mingw*], [
+	    AS_IF([test x"$enable_shared" = xyes], [
+		LIBRUBY_SO='$(RUBY_SO_NAME)'.dll
+		LIBRUBY_DLDFLAGS="${LIBRUBY_DLDFLAGS}"' $(RUBYDEF)'
+	    ])
+	    EXPORT_PREFIX=' '
+	    DLDFLAGS="${DLDFLAGS}"' $(DEFFILE)'
+	    AC_LIBOBJ([win32/win32])
+	    AC_LIBOBJ([win32/file])
+	    COMMON_LIBS=m
+#	    COMMON_MACROS="WIN32_LEAN_AND_MEAN="
+	    COMMON_HEADERS="winsock2.h windows.h"
+	    THREAD_MODEL=win32
+	    PLATFORM_DIR=win32
+	    ])
+	LIBRUBY_ALIASES=''
+	FIRSTMAKEFILE=GNUmakefile:cygwin/GNUmakefile.in
+	AS_IF([test x"$enable_shared" = xyes], [
+	    LIBRUBY='lib$(RUBY_SO_NAME).dll.a'
+	], [
+	    LIBRUBY_SO=dummy
+	    LIBRUBY='lib$(RUBY_SO_NAME).a'
+	    LIBRUBYARG='-l$(RUBY_SO_NAME)'
+	])
+	],
+    [hpux*], [
+	AS_CASE(["$YACC"],[*yacc*], [
+	    XCFLAGS="$XCFLAGS -DYYMAXDEPTH=300"
+	    YACC="$YACC -Nl40000 -Nm40000"
+	])
+])
+
+MINIOBJS="$MINIDLNOBJ"
+
+AS_CASE(["$THREAD_MODEL"],
+[pthread], [AC_CHECK_HEADERS(pthread.h)],
+[win32],   [],
+[""],      [AC_MSG_ERROR(thread model is missing)],
+           [AC_MSG_ERROR(unknown thread model $THREAD_MODEL)])
+
+AC_ARG_ENABLE(debug-env,
+       AS_HELP_STRING([--enable-debug-env], [enable RUBY_DEBUG environment variable]),
+       [AC_SUBST(ENABLE_DEBUG_ENV, yes)])
+
+AS_CASE(["$FIRSTMAKEFILE"], [*GNUmakefile:*], [gnumake=yes], [
+    AC_MSG_CHECKING([if ${MAKE-make} is GNU make])
+    mkdir conftest.dir
+    echo "all:; @echo yes" > conftest.dir/GNUmakefile
+    echo "all:; @echo no" > conftest.dir/Makefile
+    gnumake=`(cd conftest.dir; ${MAKE-make})`
+    rm -fr conftest.dir
+    AS_CASE(["$gnumake"],
+    [*yes*], [
+	FIRSTMAKEFILE=GNUmakefile:template/GNUmakefile.in
+	gnumake=yes],
+    [
+	gnumake=no])
+    AC_MSG_RESULT($gnumake)
+])
+AS_IF([test "$gnumake" = yes], [ NULLCMD=: ], [
+    AC_MSG_CHECKING([for safe null command for ${MAKE-make}])
+    mkdir conftest.dir
+    NULLCMD=
+    for cmd in : true; do
+	echo 'A=1' > conftest.dir/Makefile
+	echo 'B=$(A:1=@'$cmd')' >> conftest.dir/Makefile
+	echo 'all:; $B 1 2 3 4 5 6 7 8 9' >> conftest.dir/Makefile
+	AS_IF([(cd conftest.dir; ${MAKE-make} >/dev/null 2>/dev/null)], [
+	    NULLCMD=$cmd
+	    break
+	])
+    done
+    rm -fr conftest.dir
+    AS_IF([test -z "$NULLCMD"], [
+	AC_MSG_ERROR(no candidate for safe null command)
+    ])
+    AC_MSG_RESULT($NULLCMD)
+])
+AC_SUBST(NULLCMD)
+
+AS_IF([test "${universal_binary-no}" = yes ], [
+    AC_CACHE_CHECK([for architecture macros], rb_cv_architecture_macros, [
+    mv confdefs.h confdefs1.h
+    : > confdefs.h
+    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@if defined __`echo ${universal_archnames} |
+    sed 's/=[^ ]*//g;s/ /__ || defined __/g'`__
+@%:@else
+@%:@error
+>>>>>><<<<<<
+@%:@endif]], [[]])],[
+    rb_cv_architecture_macros=yes
+    mv -f confdefs1.h confdefs.h
+], [
+    rb_cv_architecture_macros=no
+    archflagpat=`eval echo '"'"${ARCH_FLAG}"'"' | sed 's/[[][|.*]]/\\&/g'`
+    new_cflags=`echo "$CFLAGS" | sed "s|$archflagpat"'||'`
+    for archs in ${universal_archnames}; do
+	cpu=${archs@%:@*=}
+	archs=${archs%=*}
+	CFLAGS="$new_cflags -arch $archs"
+	archs="__${archs}__"
+	AC_MSG_CHECKING([for macro ${archs} on ${cpu}])
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@ifndef ${archs}
+@%:@error
+@%:@endif]], [[]])],
+	[AC_MSG_RESULT([yes])], [AC_MSG_RESULT([no])])
+    done
+    mv -f confdefs1.h confdefs.h
+    AC_MSG_ERROR([failed])
+    ])])
+    AC_CACHE_CHECK(whether __ARCHITECTURE__ is available, rb_cv_architecture_available,
+	AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[@%:@include <stdio.h>
+		const char arch[[]] = __ARCHITECTURE__;]], [[puts(arch);]])],
+		[rb_cv_architecture_available=yes], [rb_cv_architecture_available=no]))
+])
+
+: ${MJIT_LDSHARED=`echo "$LDSHARED" | sed ['s|\$(LD)|'"${LD}"'|g;s|\$(CC)|$(MJIT_CC)|g']`}
+
+MAINLIBS="$LIBS"
+LIBS=$ORIG_LIBS
+AS_IF([test -n "${LIBS}"], [
+    libspat=`echo "${LIBS}" | sed 's/[[][|.*$^]]/\\&/g;s/^  */ /;s/^  *$/ /'`
+    MAINFLAGS=`echo " $MAINLIBS " | sed "s|$libspat"'||;s/^ *//;s/ *$//'`
+])
+LIBRUBYARG_STATIC="${LIBRUBYARG_STATIC} \$(MAINLIBS)"
+CPPFLAGS="$CPPFLAGS "'$(DEFS)'
+test -z "$CPPFLAGS" || CPPFLAGS="$CPPFLAGS "; CPPFLAGS="$CPPFLAGS"'${cppflags}'
+AS_IF([test -n "${cflags+set}"], [
+    cflagspat=`eval echo '"'"${cflags}"'"' | sed 's/[[][|.*]]/\\&/g;s/^  */ /;s/^  *$/ /'`
+    CFLAGS=`echo " $CFLAGS " | sed "s|$cflagspat"'|${cflags}|;s/^ *//;s/ *$//'`
+])
+AS_IF([test -n "${cxxflags+set}"], [
+    cxxflagspat=`eval echo '"'"${cxxflags}"'"' | sed 's/[[][|.*]]/\\&/g;s/^  */ /;s/^  *$/ /'`
+    CXXFLAGS=`echo " $CXXFLAGS " | sed "s|$cxxflagspat"'|${cxxflags}|;s/^ *//;s/ *$//'`
+])
+AS_IF([test "${ARCH_FLAG}"], [
+    archflagpat=`eval echo '"'"${ARCH_FLAG}"'"' | sed 's/[[][|.*]]/\\&/g'`
+    CFLAGS=`echo "$CFLAGS" | sed "s| *$archflagpat"'||'`
+    CXXFLAGS=`echo "$CXXFLAGS" | sed "s| *$archflagpat"'||'`
+    LDFLAGS=`echo "$LDFLAGS" | sed "s| *$archflagpat"'||'`
+])
+rb_cv_warnflags=`echo "$rb_cv_warnflags" | sed 's/^ *//;s/ *$//'`
+warnflags="$rb_cv_warnflags"
+AC_SUBST(cppflags)dnl
+AC_SUBST(cflags, ["${orig_cflags:+$orig_cflags }"'${optflags} ${debugflags} ${warnflags}'])dnl
+AC_SUBST(cxxflags)dnl
+AC_SUBST(optflags)dnl
+AC_SUBST(debugflags)dnl
+AC_SUBST(warnflags)dnl
+AC_SUBST(strict_warnflags)dnl
+AC_SUBST(XCFLAGS)dnl
+AC_SUBST(XLDFLAGS)dnl
+AC_SUBST(EXTLDFLAGS)dnl
+AC_SUBST(EXTDLDFLAGS)dnl
+AC_SUBST(LIBRUBY_LDSHARED)
+AC_SUBST(LIBRUBY_DLDFLAGS)
+AC_SUBST(RUBY_INSTALL_NAME)
+AC_SUBST(rubyw_install_name)
+AC_SUBST(RUBYW_INSTALL_NAME)
+AC_SUBST(RUBY_SO_NAME)
+AC_SUBST(LIBRUBY_A)
+AC_SUBST(LIBRUBY_SO)
+AC_SUBST(LIBRUBY_SONAME)
+AC_SUBST(LIBRUBY_ALIASES)
+AC_SUBST(LIBRUBY)
+AC_SUBST(LIBRUBYARG)
+AC_SUBST(LIBRUBYARG_STATIC)
+AC_SUBST(LIBRUBYARG_SHARED)
+AC_SUBST(SOLIBS)
+AC_SUBST(DLDLIBS)
+AC_SUBST(DLDSHARED)
+AC_SUBST(ENABLE_SHARED)
+AC_SUBST(MAINLIBS)
+AC_SUBST(COMMON_LIBS)
+AC_SUBST(COMMON_MACROS)
+AC_SUBST(COMMON_HEADERS)
+AC_SUBST(EXPORT_PREFIX)
+AC_SUBST(SYMBOL_PREFIX)
+AC_SUBST(MINIOBJS)
+AC_SUBST(THREAD_MODEL)
+AC_SUBST(PLATFORM_DIR)
+
+firstmf=`echo $FIRSTMAKEFILE | sed 's/:.*//'`
+firsttmpl=`echo $FIRSTMAKEFILE | sed 's/.*://'`
+MAKEFILES="Makefile $firstmf"
+MAKEFILES="`echo $MAKEFILES`"
+AC_SUBST(MAKEFILES)
+
+ri_prefix=
+test "$program_prefix" != NONE &&
+  ri_prefix=$program_prefix
+
+ri_suffix=
+test "$program_suffix" != NONE &&
+  ri_suffix=$program_suffix
+
+RUBY_INSTALL_NAME="${ri_prefix}"'$(RUBY_BASE_NAME)'"${ri_suffix}"
+AS_CASE(["$target_os"],
+  [cygwin*|mingw*], [
+    RUBYW_INSTALL_NAME="${ri_prefix}"'$(RUBYW_BASE_NAME)'"${ri_suffix}"
+    rubyw_install_name='$(RUBYW_INSTALL_NAME)'
+    ])
+
+rubyarchprefix=${multiarch+'${archlibdir}/${RUBY_BASE_NAME}'}${multiarch-'${rubylibprefix}/${arch}'}
+AC_ARG_WITH(rubyarchprefix,
+	    AS_HELP_STRING([--with-rubyarchprefix=DIR],
+			   [prefix for architecture dependent ruby libraries [[RUBYLIBPREFIX/ARCH]]]),
+	    [rubyarchprefix="$withval"])
+AC_SUBST(rubyarchprefix)
+
+rubysitearchprefix=${multiarch+'${sitearchlibdir}/${RUBY_BASE_NAME}'}${multiarch-'${rubylibprefix}/${sitearch}'}
+AC_ARG_WITH(rubysitearchprefix,
+	    AS_HELP_STRING([--with-rubysitearchprefix=DIR],
+			   [prefix for architecture dependent site libraries [[RUBYLIBPREFIX/SITEARCH]]]),
+	    [rubysitearchprefix="$withval"])
+AC_SUBST(rubysitearchprefix)
+
+RI_BASE_NAME=`echo ${RUBY_BASE_NAME} | sed 's/ruby/ri/'`
+ridir='${datarootdir}/${RI_BASE_NAME}'
+AC_ARG_WITH(ridir,
+	    AS_HELP_STRING([--with-ridir=DIR], [ri documentation [[DATAROOTDIR/ri]]]),
+	    [ridir=$withval])
+AC_SUBST(ridir)
+AC_SUBST(RI_BASE_NAME)
+
+unset RUBY_LIB_VERSION
+RUBY_LIB_VERSION_STYLE='3	/* full */'
+{
+echo "#define RUBY_LIB_VERSION_STYLE $RUBY_LIB_VERSION_STYLE"
+echo '#define STRINGIZE(x) x'
+test -f revision.h -o -f "${srcdir}/revision.h" || echo '#define RUBY_REVISION 0'
+echo '#include "version.h"'
+echo 'ruby_version=RUBY_LIB_VERSION'
+} > conftest.c
+ruby_version="`$CPP -I. -I"${srcdir}" -I"${srcdir}/include" conftest.c | sed '/^ruby_version=/!d;s/ //g'`"
+eval $ruby_version
+
+RUBY_LIB_VERSION="${ruby_version}"
+
+AC_SUBST(RUBY_LIB_VERSION_STYLE)
+AC_SUBST(RUBY_LIB_VERSION)
+
+AC_ARG_WITH(ruby-version,
+	    AS_HELP_STRING([--with-ruby-version=STR], [ruby version string for version specific directories [[full]] (full|STR)]),
+            [ruby_version_dir_name=$withval],
+            [ruby_version_dir_name=full])
+AS_CASE(["$ruby_version_dir_name"],
+  [full], [ruby_version_dir_name='${ruby_version}'])
+
+ruby_version_dir=/'${ruby_version_dir_name}'
+
+if test -z "${ruby_version_dir_name}"; then
+    unset ruby_version_dir
+    AC_DEFINE(RUBY_LIB_VERSION_BLANK, 1)
+fi
+
+rubylibdir='${rubylibprefix}'${ruby_version_dir}
+rubyarchdir=${multiarch+'${rubyarchprefix}'${ruby_version_dir}}${multiarch-'${rubylibdir}/${arch}'}
+
+AC_ARG_WITH(sitedir,
+	    AS_HELP_STRING([--with-sitedir=DIR], [site libraries in DIR [[RUBY_LIB_PREFIX/site_ruby]], "no" to disable site directory]),
+            [sitedir=$withval],
+            [sitedir='${rubylibprefix}/site_ruby'])
+sitelibdir='${sitedir}'${ruby_version_dir}
+
+AC_ARG_WITH(sitearchdir,
+	    AS_HELP_STRING([--with-sitearchdir=DIR],
+			   [architecture dependent site libraries in DIR [[SITEDIR/SITEARCH]], "no" to disable site directory]),
+            [sitearchdir=$withval],
+            [sitearchdir=${multiarch+'${rubysitearchprefix}/site_ruby'${ruby_version_dir}}${multiarch-'${sitelibdir}/${sitearch}'}])
+
+AC_ARG_WITH(vendordir,
+	    AS_HELP_STRING([--with-vendordir=DIR], [vendor libraries in DIR [[RUBY_LIB_PREFIX/vendor_ruby]], "no" to disable vendor directory]),
+            [vendordir=$withval],
+            [vendordir='${rubylibprefix}/vendor_ruby'])
+vendorlibdir='${vendordir}'${ruby_version_dir}
+
+AC_ARG_WITH(vendorarchdir,
+	    AS_HELP_STRING([--with-vendorarchdir=DIR],
+			   [architecture dependent vendor libraries in DIR [[VENDORDIR/SITEARCH]], "no" to disable vendor directory]),
+            [vendorarchdir=$withval],
+            [vendorarchdir=${multiarch+'${rubysitearchprefix}/vendor_ruby'${ruby_version_dir}}${multiarch-'${vendorlibdir}/${sitearch}'}])
+
+AS_IF([test "${LOAD_RELATIVE+set}"], [
+    AC_DEFINE_UNQUOTED(LOAD_RELATIVE, $LOAD_RELATIVE)
+    RUBY_EXEC_PREFIX=''
+])
+
+AC_SUBST(RUBY_EXEC_PREFIX)
+
+AC_SUBST(libdirname, ${multiarch+arch}libdir)
+AC_SUBST(archlibdir)dnl
+AC_SUBST(sitearchlibdir)dnl
+AC_SUBST(archincludedir)dnl
+AC_SUBST(sitearchincludedir)dnl
+AC_SUBST(arch)dnl
+AC_SUBST(sitearch)dnl
+AC_SUBST(ruby_version)dnl
+AC_SUBST(ruby_version_dir_name)dnl
+AC_SUBST(rubylibdir)dnl
+AC_SUBST(rubyarchdir)dnl
+AC_SUBST(sitedir)dnl
+AC_SUBST(sitelibdir)dnl
+AC_SUBST(sitearchdir)dnl
+AC_SUBST(vendordir)dnl
+AC_SUBST(vendorlibdir)dnl
+AC_SUBST(vendorarchdir)dnl
+
+AC_SUBST(CONFIGURE, "`echo $0 | sed 's|.*/||'`")dnl
+AC_SUBST(configure_args, "`echo "${ac_configure_args}" | sed 's/\\$/$$/g'`")dnl
+
+target_cpu=`echo $target_cpu | sed s/i.86/i386/`
+
+AS_IF([test "${universal_binary-no}" = yes ], [
+    arch="universal-${target_os}"
+    AS_IF([test "${rb_cv_architecture_available}" = yes], [
+	AC_DEFINE_UNQUOTED(RUBY_PLATFORM_CPU, __ARCHITECTURE__)
+    ], [
+	for archs in ${universal_archnames}; do
+	    cpu=`echo $archs | sed 's/.*=//'`
+	    archs=`echo $archs | sed 's/=.*//'`
+	    RUBY_DEFINE_IF([defined __${archs}__ &&! defined RUBY_PLATFORM_CPU], RUBY_PLATFORM_CPU, ["${cpu}"])
+	done
+    ])
+    ints='long int short'
+    test "$ac_cv_type_long_long" = yes && ints="'long long' $ints"
+    AC_SUBST(UNIVERSAL_ARCHNAMES, "${universal_archnames}")
+    AC_SUBST(UNIVERSAL_INTS, "${ints}")
+    AC_DEFINE_UNQUOTED(RUBY_PLATFORM_OS, "${target_os}")
+    AC_DEFINE_UNQUOTED(RUBY_ARCH, "universal-" RUBY_PLATFORM_OS)
+    AC_DEFINE_UNQUOTED(RUBY_PLATFORM, "universal." RUBY_PLATFORM_CPU "-" RUBY_PLATFORM_OS)
+], [
+    arch="${target_cpu}-${target_os}"
+    AC_DEFINE_UNQUOTED(RUBY_PLATFORM, "$arch")
+])
+
+unset sitearch
+AS_CASE(["$target_os"],[mingw*],[sitearch="$target_cpu-$rb_cv_msvcrt"])
+: ${sitearch='${arch}'}
+
+AC_ARG_WITH(search-path,
+		AS_HELP_STRING([--with-search-path=DIR], [specify the additional search path]),
+		[search_path=$withval])
+AS_IF([test "$search_path" != ""], [
+    AC_SUBST(RUBY_SEARCH_PATH, $search_path)
+])
+
+AC_ARG_WITH(rubyhdrdir,
+	    AS_HELP_STRING([--with-rubyhdrdir=DIR], [core headers in DIR [[INCLUDEDIR/RUBY_BASE_NAME-RUBY_VERSION]]]),
+	    [rubyhdrdir=$withval],
+	    [rubyhdrdir='${includedir}/${RUBY_VERSION_NAME}'])
+
+AC_ARG_WITH(rubyarchhdrdir,
+	    AS_HELP_STRING([--with-rubyarchhdrdir=DIR],
+			   [architecture dependent core headers in DIR [[$(rubyhdrdir)/$(arch)]]]),
+	    [rubyarchhdrdir=$withval],
+	    [rubyarchhdrdir=${multiarch+'${archincludedir}/${RUBY_VERSION_NAME}'}${multiarch-'${rubyhdrdir}/${arch}'}])
+
+AC_ARG_WITH(sitehdrdir,
+	    AS_HELP_STRING([--with-sitehdrdir=DIR], [core site headers in DIR [[RUBYHDRDIR/site_ruby]]]),
+	    [sitehdrdir=$withval],
+	    [sitehdrdir='${rubyhdrdir}/site_ruby'])
+
+AC_ARG_WITH(sitearchhdrdir,
+	    AS_HELP_STRING([--with-sitearchhdrdir=DIR],
+			   [architecture dependent core site headers in DIR [[RUBYHDRDIR/site_ruby]]]),
+	    [sitearchhdrdir=$withval],
+	    [sitearchhdrdir=${multiarch+'${sitearchincludedir}/${RUBY_VERSION_NAME}/site_ruby'}${multiarch-'${sitehdrdir}/${sitearch}'}])
+
+AC_ARG_WITH(vendorhdrdir,
+	    AS_HELP_STRING([--with-vendorhdrdir=DIR], [core vendor headers in DIR [[RUBYHDRDIR/vendor_ruby]]]),
+	    [vendorhdrdir=$withval],
+	    [vendorhdrdir='${rubyhdrdir}/vendor_ruby'])
+
+AC_ARG_WITH(vendorarchhdrdir,
+	    AS_HELP_STRING([--with-vendorarchhdrdir=DIR],
+			   [architecture dependent core vendor headers in DIR [[RUBYHDRDIR/vendor_ruby]]]),
+	    [vendorarchhdrdir=$withval],
+	    [vendorarchhdrdir=${multiarch+'${sitearchincludedir}/${RUBY_VERSION_NAME}/vendor_ruby'}${multiarch-'${vendorhdrdir}/${sitearch}'}])
+
+AC_SUBST(rubyhdrdir)dnl
+AC_SUBST(sitehdrdir)dnl
+AC_SUBST(vendorhdrdir)dnl
+AC_SUBST(rubyarchhdrdir)dnl
+AC_SUBST(sitearchhdrdir)dnl
+AC_SUBST(vendorarchhdrdir)dnl
+
+AC_ARG_WITH(mantype,
+	AS_HELP_STRING([--with-mantype=TYPE], [specify man page type; TYPE is one of man and doc]),
+		[
+			AS_CASE(["$withval"],
+			[man|man.gz|man.bz2|doc|doc.gz|doc.bz2], [MANTYPE=$withval],
+			[AC_MSG_ERROR(invalid man type: $withval)])
+		])
+AS_IF([test -z "$MANTYPE"], [
+	dnl Looks for nroff with -mdoc support.
+	AC_CACHE_VAL([ac_cv_path_NROFF], [
+		AC_PATH_PROGS_FEATURE_CHECK([NROFF],
+			[nroff awf mandoc],
+			[$ac_path_NROFF -mdoc ${srcdir}/man/ruby.1 \
+				>/dev/null 2>&1 &&
+				ac_cv_path_NROFF=$ac_path_NROFF \
+				ac_path_NROFF_found=:],
+			[], ["/usr/bin:/usr/ucb"]
+		)
+	])
+	AS_IF([test -n "$ac_cv_path_NROFF"], [
+		MANTYPE=doc
+	], [
+		MANTYPE=man
+	])
+])
+AC_SUBST(MANTYPE)
+
+AC_ARG_ENABLE(rubygems,
+	AS_HELP_STRING([--disable-rubygems], [disable rubygems by default]),
+	[enable_rubygems="$enableval"], [enable_rubygems=yes])
+AS_IF([test x"$enable_rubygems" = xno], [
+    USE_RUBYGEMS=no
+], [
+    USE_RUBYGEMS=yes
+])
+AC_SUBST(USE_RUBYGEMS)
+
+arch_hdrdir="${EXTOUT}/include/${arch}/ruby"
+AS_MKDIR_P("${arch_hdrdir}")
+config_h="${arch_hdrdir}/config.h"
+guard=INCLUDE_RUBY_CONFIG_H
+{
+  echo "#ifndef $guard"
+  echo "#define $guard 1"
+  grep -v "^#define PACKAGE_" confdefs.h
+  echo "#endif /* $guard */"
+} | tr -d '\015' |
+(
+  AS_IF([test "x$CONFIGURE_TTY" = xyes], [color=--color], [color=])
+  exec ${srcdir}/tool/ifchange $color "${config_h}" -
+) >&AS_MESSAGE_FD || AC_MSG_ERROR([failed to create ${config_h}])
+tr -d '\015' < largefile.h > confdefs.h
+rm largefile.h
+
+BUILTIN_ENCS=["`sed -n -e '/^BUILTIN_ENCS[ 	]*=/{' \
+	-e s/// -e :l -e '/\\\\$/N' -e 's/\\\\\\n/ /' -e 't l' -e p \
+	-e '}' "${srcdir}/enc/Makefile.in"`"]
+BUILTIN_ENCOBJS=
+for e in $BUILTIN_ENCS; do BUILTIN_ENCOBJS="$BUILTIN_ENCOBJS "`echo $e | sed 's/\.c$/.$(OBJEXT)/'`; done
+AC_SUBST(BUILTIN_ENCOBJS)
+
+BUILTIN_TRANSES=["`sed -n -e '/^BUILTIN_TRANSES[ 	]*=/{' \
+	-e s/// -e :l -e '/\\\\$/N' -e 's/\\\\\\n/ /' -e 't l' -e p \
+	-e '}' "${srcdir}/enc/Makefile.in"`"]
+BUILTIN_TRANSSRCS=
+BUILTIN_TRANSOBJS=
+for e in $BUILTIN_TRANSES; do
+  BUILTIN_TRANSSRCS="$BUILTIN_TRANSSRCS "`echo $e | sed 's/\.trans$/.c/'`
+  BUILTIN_TRANSOBJS="$BUILTIN_TRANSOBJS "`echo $e | sed 's/\.trans$/.$(OBJEXT)/'`
+done
+AC_SUBST(BUILTIN_TRANSSRCS)
+AC_SUBST(BUILTIN_TRANSOBJS)
+
+PACKAGE=$RUBY_BASE_NAME
+AC_SUBST(PACKAGE)
+AS_MESSAGE([$PACKAGE library version = $ruby_version])
+
+AS_IF([test x"$CC_WRAPPER" != x], [
+    CC='$(CC_WRAPPER) '"${CC@%:@$CC_WRAPPER }"
+    CPP='$(CC_WRAPPER) '"${CPP@%:@$CC_WRAPPER }"
+    CC_WRAPPER='$(rubyarchdir)/darwin-cc'
+    XCC_WRAPPER='$(top_srcdir)/tool/darwin-cc'
+])
+AC_SUBST(CC_WRAPPER, '')
+AC_SUBST(XCC_WRAPPER)
+
+AS_CASE([" $CPP "], [*" $CC "*], [CPP=`echo " $CPP " | sed "s| $CC |"' $(CC) |;s/^ *//;s/  *$//'`])
+
+AS_IF([test x"$firstmf" != x], [
+    AC_CONFIG_FILES($firstmf:$firsttmpl, [], [firstmf="$firstmf" firsttmpl="$firsttmpl"])
+])
+AC_CONFIG_FILES(Makefile:template/Makefile.in, [
+    tmpmk=confmk$$.tmp
+    {
+	AS_IF([test ${VCS+set}], [
+	    :
+	], [git_dir=`$GIT --work-tree="$srcdir" --git-dir="$srcdir/.git" rev-parse --git-dir 2>/dev/null`], [
+	    VCS='$(GIT)'
+	], [
+	    VCS='echo cannot'
+	])
+	AS_CASE("$VCS",
+		['$(GIT)'|git], [VCSUP='$(VCS) pull $(GITPULLOPTIONS)'],
+		[VCSUP='$(VCS)'])
+	sed -n \
+	    -e '[/^@%:@define \(RUBY_RELEASE_[A-Z]*\) \([0-9][0-9]*\)/]{' \
+	    -e   's//\1 = \2/' \
+	    -e   '[s/ \([0-9]\)$/ 0\1/]' \
+	    -e   p \
+	    -e '}' "$srcdir/version.h"
+	sed '/^MISSING/s/\$U\././g;/^VCS *=/s#@VCS@#'"$VCS"'#;/^VCSUP *=/s#@VCSUP@#'"$VCSUP"'#' Makefile
+	echo; test x"$EXEEXT" = x || echo 'miniruby: miniruby$(EXEEXT)'
+	AS_IF([test "$gnumake" != yes], [
+	    echo ['$(MKFILES): $(srcdir)/common.mk']
+	    sed ['s/{\$([^(){}]*)[^{}]*}//g'] ${srcdir}/common.mk
+	], [
+	    echo 'distclean-local::; @$(RM) GNUmakefile uncommon.mk'
+	])
+    } > $tmpmk && AS_IF([! grep '^ruby:' $tmpmk > /dev/null], [
+	AS_IF([test "${gnumake}" = yes], [
+	    tmpgmk=confgmk$$.tmp
+	    {
+		echo "include $tmpmk"
+		echo "-include uncommon.mk"
+	    } > $tmpgmk
+	], [
+	    tmpgmk=$tmpmk
+	]) &&
+	test -z "`${MAKE-make} -f $tmpgmk info-program | grep '^PROGRAM=ruby$'`" &&
+	echo 'ruby: $(PROGRAM);' >> $tmpmk
+	test "$tmpmk" = "$tmpgmk" || rm -f "$tmpgmk"
+    ]) && mv -f $tmpmk Makefile],
+[EXEEXT='$EXEEXT' gnumake='$gnumake' GIT='$GIT'])
+
+AC_ARG_WITH([ruby-pc],
+	    AS_HELP_STRING([--with-ruby-pc=FILENAME], [pc file basename]),
+	    [ruby_pc="$withval"],
+	    [ruby_pc="${RUBY_BASE_NAME}-${MAJOR}.${MINOR}.pc"])
+AC_SUBST(ruby_pc)
+AC_SUBST(exec, [exec])
+
+AC_ARG_WITH(destdir,
+	    AS_HELP_STRING([--with-destdir=DESTDIR], [specify default directory to install]),
+	    [DESTDIR="$withval"])
+AC_SUBST(DESTDIR)
+
+AC_CONFIG_FILES($ruby_pc:template/ruby.pc.in,
+    [
+    AS_IF([sed ['s/\$(\([A-Za-z_][A-Za-z0-9_]*\))/${\1}/g;s/@[A-Za-z_][A-Za-z0-9_]*@//'] $ruby_pc > ruby.tmp.pc &&
+	{
+	    test -z "$PKG_CONFIG" ||
+	    PKG_CONFIG_PATH=. $PKG_CONFIG --print-errors ruby.tmp
+	}],
+    [
+	mv -f ruby.tmp.pc $ruby_pc
+    ], [
+	exit 1
+    ])
+    ],
+    [ruby_pc='$ruby_pc' PKG_CONFIG='$PKG_CONFIG'])
+
+AC_OUTPUT
+}
+}
+
+AS_IF([test "$silent" = yes], [], [
+AS_IF([${FOLD+:} false], [], [
+AS_IF([test "`echo abcdefg hijklmno | fold -s -w10 | sed 1d`" = hijklmno], [FOLD="fold"], [FOLD=])
+])
+fold_width=`expr $COLUMNS - 30 2>/dev/null` || fold_width=50
+AS_REQUIRE_SHELL_FN([config_summary],
+    [AS_FUNCTION_DESCRIBE([config_summary], [NAME, VAL], [configuration summary])],
+    [AS_IF([test -z "$2"], [], [
+	AS_ECHO_N(["   * $1:                     "]) | dd bs=1 count=26 2>/dev/null
+	AS_IF([test "$FOLD"], [
+	    echo "$2" | fold -s -w$fold_width |
+	    sed '1!s/^/                          /;$!s/$/\\/'
+	], [echo "$2"])
+    ])]
+)
+
+AS_IF([test $install_doc = yes],
+    [DOCTARGETS=`echo " $RDOCTARGET $CAPITARGET " | sed 's/ nodoc //g;s/^ *//;s/ *$//'`],
+    [DOCTARGETS=no])
+echo "---"
+echo "Configuration summary for $RUBY_BASE_NAME version $MAJOR.$MINOR.$TEENY"
+echo ""
+config_summary "Installation prefix" "$prefix"
+config_summary "exec prefix"         "$exec_prefix"
+config_summary "arch"                "$arch"
+config_summary "site arch"           "$sitearch"
+config_summary "RUBY_BASE_NAME"      "$RUBY_BASE_NAME"
+config_summary "enable shared"       "$enable_shared"
+config_summary "ruby lib prefix"     "$rubylibprefix"
+config_summary "site libraries path" "$rubysitearchprefix"
+config_summary "vendor path"         "$vendordir"
+config_summary "target OS"           "$target_os"
+config_summary "compiler"            "$CC"
+config_summary "with pthread"        "$enable_pthread"
+config_summary "with coroutine"      "$rb_cv_coroutine"
+config_summary "enable shared libs"  "$ENABLE_SHARED"
+config_summary "dynamic library ext" "$DLEXT"
+config_summary "CFLAGS"              "$cflags"
+config_summary "CPPFLAGS"            "$cppflags"
+config_summary "LDFLAGS"             "$LDFLAGS"
+config_summary "DLDFLAGS"            "$DLDFLAGS"
+config_summary "optflags"            "$optflags"
+config_summary "debugflags"          "$debugflags"
+config_summary "warnflags"           "$warnflags"
+config_summary "strip command"       "$STRIP"
+config_summary "install doc"         "$DOCTARGETS"
+config_summary "JIT support"         "$MJIT_SUPPORT"
+config_summary "man page type"       "$MANTYPE"
+config_summary "search path"         "$search_path"
+config_summary "static-linked-ext"   ${EXTSTATIC:+"yes"}
+config_summary "BASERUBY -v"         "$BASERUBY_VERSION"
+echo ""
+echo "---"
+])
diff -Nuarp ruby-2.7.8.a/eval_error.c ruby-2.7.8.b/eval_error.c
--- ruby-2.7.8.a/eval_error.c	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/eval_error.c	2023-05-20 18:17:55.733552286 -0400
@@ -241,8 +241,8 @@ print_backtrace(const VALUE eclass, cons
 		     (len < threshold ? 0 : 9) + 1);
 
 #define TRACE_MAX (TRACE_HEAD+TRACE_TAIL+5)
-#define TRACE_HEAD 8
-#define TRACE_TAIL 5
+#define TRACE_HEAD 100
+#define TRACE_TAIL 100
 
 	for (i = 1; i < len; i++) {
 	    VALUE line = RARRAY_AREF(errat, reverse ? len - i : i);
diff -Nuarp ruby-2.7.8.a/ext/openssl/openssl.gemspec ruby-2.7.8.b/ext/openssl/openssl.gemspec
--- ruby-2.7.8.a/ext/openssl/openssl.gemspec	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/ext/openssl/openssl.gemspec	2023-05-20 18:17:38.205337584 -0400
@@ -17,7 +17,6 @@ Gem::Specification.new do |spec|
 
   spec.required_ruby_version = ">= 2.3.0"
 
-  spec.add_runtime_dependency "ipaddr"
   spec.add_development_dependency "rake", ">= 11.2.0"
   spec.add_development_dependency "rake-compiler"
   spec.add_development_dependency "test-unit", "~> 3.0"
diff -Nuarp ruby-2.7.8.a/gc.c ruby-2.7.8.b/gc.c
--- ruby-2.7.8.a/gc.c	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/gc.c	2023-05-20 18:17:59.783601895 -0400
@@ -290,6 +290,9 @@ rb_gc_guarded_ptr_val(volatile VALUE *pt
 #ifndef GC_MALLOC_LIMIT_GROWTH_FACTOR
 #define GC_MALLOC_LIMIT_GROWTH_FACTOR 1.4
 #endif
+#ifndef GC_MALLOC_TRIM_FREQUENCY
+#define GC_MALLOC_TRIM_FREQUENCY 0
+#endif
 
 #ifndef GC_OLDMALLOC_LIMIT_MIN
 #define GC_OLDMALLOC_LIMIT_MIN (16 * 1024 * 1024 /* 16MB */)
@@ -328,6 +331,7 @@ typedef struct {
     size_t malloc_limit_min;
     size_t malloc_limit_max;
     double malloc_limit_growth_factor;
+    size_t malloc_trim_frequency;
 
     size_t oldmalloc_limit_min;
     size_t oldmalloc_limit_max;
@@ -350,6 +354,7 @@ static ruby_gc_params_t gc_params = {
     GC_MALLOC_LIMIT_MIN,
     GC_MALLOC_LIMIT_MAX,
     GC_MALLOC_LIMIT_GROWTH_FACTOR,
+    GC_MALLOC_TRIM_FREQUENCY,
 
     GC_OLDMALLOC_LIMIT_MIN,
     GC_OLDMALLOC_LIMIT_MAX,
@@ -698,6 +703,8 @@ typedef struct rb_objspace {
 #if GC_ENABLE_INCREMENTAL_MARK
 	unsigned int during_incremental_marking : 1;
 #endif
+        int collect_gc_stats;
+        int verbose_gc_stats;
     } flags;
 
     rb_event_flag_t hook_events;
@@ -772,14 +779,21 @@ typedef struct rb_objspace {
 
 	/* temporary profiling space */
 	double gc_sweep_start_time;
+        double gc_mark_start_time;
+
 	size_t total_allocated_objects_at_gc_start;
 	size_t heap_used_at_gc_start;
 
 	/* basic statistics */
 	size_t count;
+        double time;
 	size_t total_freed_objects;
 	size_t total_allocated_pages;
 	size_t total_freed_pages;
+        size_t total_mallocs;
+        size_t total_malloced_bytes;
+        size_t live_after_last_sweep;
+
     } profile;
     struct gc_list *global_list;
 
@@ -920,6 +934,7 @@ VALUE *ruby_initial_gc_stress_ptr = &rub
 #define heap_tomb               (&objspace->tomb_heap)
 #define dont_gc 		objspace->flags.dont_gc
 #define during_gc		objspace->flags.during_gc
+#define collect_gc_stats        objspace->flags.collect_gc_stats
 #define finalizing		objspace->atomic_flags.finalizing
 #define finalizer_table 	objspace->finalizer_table
 #define global_list		objspace->global_list
@@ -6908,6 +6923,107 @@ rb_gc_writebarrier_remember(VALUE obj)
 
 static st_table *rgengc_unprotect_logging_table;
 
+VALUE
+rb_gc_enable_stats()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    int old = collect_gc_stats;
+    collect_gc_stats = 1;
+    return old ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_enable_stats(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_enable_stats();
+}
+
+VALUE
+rb_gc_disable_stats()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    int old = collect_gc_stats;
+    collect_gc_stats = 0;
+    return old ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_disable_stats(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_disable_stats();
+}
+
+
+VALUE
+rb_gc_stats_enabled()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return collect_gc_stats ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_stats_enabled(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_stats_enabled();
+}
+
+double rb_gc_total_time()
+{
+    return rb_objspace.profile.time;
+}
+
+static VALUE
+gc_time(rb_execution_context_t *ec, VALUE _)
+{
+    return DBL2NUM(1000000*rb_objspace.profile.time);
+}
+
+VALUE
+rb_gc_heap_slots()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return SIZET2NUM(heap_allocated_pages * HEAP_PAGE_OBJ_LIMIT);
+}
+
+static
+VALUE gc_heap_slots(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_heap_slots();
+}
+
+VALUE
+rb_gc_heap_slots_live_after_last_gc()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return SIZET2NUM(objspace->profile.live_after_last_sweep);
+}
+
+static
+VALUE gc_heap_slots_live_after_last_gc(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_heap_slots_live_after_last_gc();
+}
+
+size_t rb_gc_total_mallocs() {
+    return rb_objspace.profile.total_mallocs;
+}
+
+static VALUE
+gc_total_mallocs(rb_execution_context_t *ec, VALUE _)
+{
+    return SIZET2NUM(rb_objspace.profile.total_mallocs);
+}
+
+size_t rb_gc_total_malloced_bytes(void) {
+    return rb_objspace.profile.total_malloced_bytes;
+}
+
+static VALUE
+gc_total_malloced_bytes(rb_execution_context_t *ec, VALUE _)
+{
+    return SIZET2NUM(rb_objspace.profile.total_malloced_bytes);
+}
+
 static int
 rgengc_unprotect_logging_exit_func_i(st_data_t key, st_data_t val, st_data_t arg)
 {
@@ -7352,6 +7468,20 @@ gc_start(rb_objspace_t *objspace, int re
     gc_prof_timer_start(objspace);
     {
 	gc_marks(objspace, do_full_mark);
+#ifdef HAVE_MALLOC_TRIM
+        /* [Experimental] Explicitly free all eligible pages to the kernel.  See:
+         *
+         * - https://www.joyfulbikeshedding.com/blog/2019-03-14-what-causes-ruby-memory-bloat.html
+         * - https://bugs.ruby-lang.org/issues/15667
+         */
+#if USE_RGENGC
+        size_t gc_count = rb_objspace.profile.major_gc_count;
+#else
+        size_t gc_count = rb_objspace.profile.count;
+#endif
+        if (do_full_mark && gc_params.malloc_trim_frequency && gc_count % gc_params.malloc_trim_frequency == 0)
+            malloc_trim(0);
+#endif
     }
     gc_prof_timer_stop(objspace);
 
@@ -9475,6 +9605,7 @@ ruby_gc_set_params(void)
     get_envparam_size  ("RUBY_GC_OLDMALLOC_LIMIT_MAX", &gc_params.oldmalloc_limit_max, 0);
     get_envparam_double("RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR", &gc_params.oldmalloc_limit_growth_factor, 1.0, 0.0, FALSE);
 #endif
+    get_envparam_size  ("RUBY_GC_MALLOC_TRIM_FREQUENCY", &gc_params.malloc_trim_frequency, 0);
 }
 
 void
@@ -9734,6 +9865,10 @@ objspace_malloc_increase(rb_objspace_t *
 {
     if (new_size > old_size) {
 	ATOMIC_SIZE_ADD(malloc_increase, new_size - old_size);
+        if (collect_gc_stats) {
+            ATOMIC_SIZE_ADD(objspace->profile.total_mallocs, 1);
+            ATOMIC_SIZE_ADD(objspace->profile.total_malloced_bytes, new_size - old_size);
+        }
 #if RGENGC_ESTIMATE_OLDMALLOC
 	ATOMIC_SIZE_ADD(objspace->rgengc.oldmalloc_increase, new_size - old_size);
 #endif
@@ -10313,6 +10448,12 @@ gc_malloc_allocated_size(VALUE self)
     return UINT2NUM(rb_objspace.malloc_params.allocated_size);
 }
 
+size_t
+rb_gc_malloc_allocated_size(void)
+{
+    return rb_objspace.malloc_params.allocated_size;
+}
+
 /*
  *  call-seq:
  *     GC.malloc_allocations -> Integer
@@ -10327,6 +10468,12 @@ gc_malloc_allocations(VALUE self)
 {
     return UINT2NUM(rb_objspace.malloc_params.allocations);
 }
+
+size_t
+rb_gc_malloc_allocations(void)
+{
+    return rb_objspace.malloc_params.allocations;
+}
 #endif
 
 void
@@ -10934,6 +11081,14 @@ gc_prof_mark_timer_start(rb_objspace_t *
 #if GC_PROFILE_MORE_DETAIL
     if (gc_prof_enabled(objspace)) {
 	gc_prof_record(objspace)->gc_mark_time = getrusage_time();
+    } else {
+        if (collect_gc_stats) {
+          objspace->profile.gc_mark_start_time = getrusage_time();
+        }
+    }
+#else
+    if (collect_gc_stats) {
+        objspace->profile.gc_mark_start_time = getrusage_time();
     }
 #endif
 }
@@ -10946,6 +11101,17 @@ gc_prof_mark_timer_stop(rb_objspace_t *o
     if (gc_prof_enabled(objspace)) {
         gc_profile_record *record = gc_prof_record(objspace);
 	record->gc_mark_time = elapsed_time_from(record->gc_mark_time);
+        if (collect_gc_stats) {
+            objspace->profile.time += record->gc_mark_time;
+        }
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.time += elapsed_time_from(objspace->profile.gc_mark_start_time);
+        }
+    }
+#else
+    if (collect_gc_stats) {
+        objspace->profile.time += elapsed_time_from(objspace->profile.gc_mark_start_time);
     }
 #endif
 }
@@ -10957,9 +11123,13 @@ gc_prof_sweep_timer_start(rb_objspace_t
     if (gc_prof_enabled(objspace)) {
 	gc_profile_record *record = gc_prof_record(objspace);
 
-	if (record->gc_time > 0 || GC_PROFILE_MORE_DETAIL) {
+	if (record->gc_time > 0 || GC_PROFILE_MORE_DETAIL || collect_gc_stats) {
 	    objspace->profile.gc_sweep_start_time = getrusage_time();
-	}
+        }
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.gc_sweep_start_time = getrusage_time();
+        }
     }
 }
 
@@ -10976,16 +11146,30 @@ gc_prof_sweep_timer_stop(rb_objspace_t *
 	    sweep_time = elapsed_time_from(objspace->profile.gc_sweep_start_time);
 	    /* need to accumulate GC time for lazy sweep after gc() */
 	    record->gc_time += sweep_time;
+            if (collect_gc_stats) {
+                objspace->profile.time += sweep_time;
+            }
 	}
 	else if (GC_PROFILE_MORE_DETAIL) {
 	    sweep_time = elapsed_time_from(objspace->profile.gc_sweep_start_time);
-	}
+            if (collect_gc_stats) {
+                objspace->profile.time += sweep_time;
+            }
+	} else {
+            if (collect_gc_stats) {
+                objspace->profile.time += elapsed_time_from(objspace->profile.gc_sweep_start_time);
+            }
+        }
 
 #if GC_PROFILE_MORE_DETAIL
 	record->gc_sweep_time += sweep_time;
 	if (heap_pages_deferred_final) record->flags |= GPR_FLAG_HAVE_FINALIZE;
 #endif
 	if (heap_pages_deferred_final) objspace->profile.latest_gc_info |= GPR_FLAG_HAVE_FINALIZE;
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.time += elapsed_time_from(objspace->profile.gc_sweep_start_time);
+        }
     }
 }
 
@@ -11004,9 +11188,13 @@ gc_prof_set_malloc_info(rb_objspace_t *o
 static inline void
 gc_prof_set_heap_info(rb_objspace_t *objspace)
 {
+    if (objspace->profile.total_allocated_objects_at_gc_start > objspace->profile.total_freed_objects)
+        objspace->profile.live_after_last_sweep =
+            objspace->profile.total_allocated_objects_at_gc_start - objspace->profile.total_freed_objects;
+
     if (gc_prof_enabled(objspace)) {
 	gc_profile_record *record = gc_prof_record(objspace);
-	size_t live = objspace->profile.total_allocated_objects_at_gc_start - objspace->profile.total_freed_objects;
+        size_t live = objspace->profile.live_after_last_sweep;
 	size_t total = objspace->profile.heap_used_at_gc_start * HEAP_PAGE_OBJ_LIMIT;
 
 #if GC_PROFILE_MORE_DETAIL
diff -Nuarp ruby-2.7.8.a/gc.rb ruby-2.7.8.b/gc.rb
--- ruby-2.7.8.a/gc.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/gc.rb	2023-05-20 18:17:52.341510738 -0400
@@ -158,6 +158,92 @@ module GC
   def self.compact
     __builtin_rb_gc_compact
   end
+
+  # call-seq:
+  #    GC.enable_stats	  => true or false
+  #
+  # Enables garbage collection statistics, returning <code>true</code> if garbage
+  # collection statistics was already enabled.
+  #
+  #    GC.enable_stats	 #=> false or true
+  #    GC.enable_stats	 #=> true
+  def self.enable_stats
+    __builtin_gc_enable_stats
+  end
+
+  #   call-seq:
+  #    GC.disable_stats	   => true or false
+  #
+  # Disables garbage collection statistics, returning <code>true</code> if garbage
+  # collection statistics was already disabled.
+  #
+  #    GC.disable_stats	  #=> false or true
+  #    GC.disable_stats	  #=> true
+  def self.disable_stats
+    __builtin_gc_disable_stats
+  end
+
+  # call-seq:
+  #    GC.stats_enabled?    => true or false
+  #
+  # Check whether GC stats have been enabled.
+  #
+  #    GC.stats_enabled?   #=> false or true
+  def self.stats_enabled?
+    __builtin_gc_stats_enabled
+  end
+
+  #   call-seq:
+  #    GC.time	  => Integer
+  #
+  # Returns the time spent during garbage collection while GC statistics collection
+  # was enabled (in micro seconds).
+  #
+  #    GC.time	  #=> 20000
+  def self.time
+    __builtin_gc_time
+  end
+
+  #  call-seq:
+  #	GC.heap_slots	=> Integer
+  #
+  #  Returns the number of heap slots available for object allocations.
+  #
+  #	GC.heap_slots	#=> 10000
+  def self.heap_slots
+    __builtin_gc_heap_slots
+  end
+
+  # call-seq:
+  #    GC.heap_slots_live_after_last_gc	   => Integer
+  #
+  # Returns the number of heap slots which were live after the last garbage collection.
+  #
+  #    GC.heap_slots_live_after_last_gc	   #=> 231223
+  def self.heap_slots_live_after_last_gc
+    __builtin_gc_heap_slots_live_after_last_gc
+  end
+
+  #   call-seq:
+  #	 GC.total_mallocs	   => Integer
+  #
+  #   Returns the number malloc calls. Might wrap around.
+  #
+  #	 GC.total_mallocs	   #=> 324234323246
+  def self.total_mallocs
+    __builtin_gc_total_mallocs
+  end
+
+  #   call-seq:
+  #	 GC.total_malloced_bytes	   => Integer
+  #
+  #   Returns the number of bytes allocated. Might wrap around.
+  #
+  #	 GC.total_malloced_bytes	   #=> 354656256432446
+  def self.total_malloced_bytes
+    __builtin_gc_total_malloced_bytes
+  end
+
 end
 
 module ObjectSpace
diff -Nuarp ruby-2.7.8.a/gc.rbinc ruby-2.7.8.b/gc.rbinc
--- ruby-2.7.8.a/gc.rbinc	2023-03-30 08:34:10.000000000 -0400
+++ ruby-2.7.8.b/gc.rbinc	2023-05-20 18:18:54.536272556 -0400
@@ -17,6 +17,14 @@ static void load_gc(void)
     RB_BUILTIN_FUNCTION(6, gc_stat, gc_stat, 1),
     RB_BUILTIN_FUNCTION(7, gc_latest_gc_info, gc_latest_gc_info, 1),
     RB_BUILTIN_FUNCTION(8, rb_gc_compact, rb_gc_compact, 0),
+    RB_BUILTIN_FUNCTION(9, gc_enable_stats, gc_enable_stats, 0),
+    RB_BUILTIN_FUNCTION(10, gc_disable_stats, gc_disable_stats, 0),
+    RB_BUILTIN_FUNCTION(11, gc_stats_enabled, gc_stats_enabled, 0),
+    RB_BUILTIN_FUNCTION(12, gc_time, gc_time, 0),
+    RB_BUILTIN_FUNCTION(13, gc_heap_slots, gc_heap_slots, 0),
+    RB_BUILTIN_FUNCTION(14, gc_heap_slots_live_after_last_gc, gc_heap_slots_live_after_last_gc, 0),
+    RB_BUILTIN_FUNCTION(15, gc_total_mallocs, gc_total_mallocs, 0),
+    RB_BUILTIN_FUNCTION(16, gc_total_malloced_bytes, gc_total_malloced_bytes, 0),
     RB_BUILTIN_FUNCTION(-1, NULL, NULL, 0),
   };
 
@@ -34,6 +42,14 @@ COMPILER_WARNING_ERROR(-Wincompatible-po
   if (0) rb_builtin_function_check_arity1(gc_stat);
   if (0) rb_builtin_function_check_arity1(gc_latest_gc_info);
   if (0) rb_builtin_function_check_arity0(rb_gc_compact);
+  if (0) rb_builtin_function_check_arity0(gc_enable_stats);
+  if (0) rb_builtin_function_check_arity0(gc_disable_stats);
+  if (0) rb_builtin_function_check_arity0(gc_stats_enabled);
+  if (0) rb_builtin_function_check_arity0(gc_time);
+  if (0) rb_builtin_function_check_arity0(gc_heap_slots);
+  if (0) rb_builtin_function_check_arity0(gc_heap_slots_live_after_last_gc);
+  if (0) rb_builtin_function_check_arity0(gc_total_mallocs);
+  if (0) rb_builtin_function_check_arity0(gc_total_malloced_bytes);
 COMPILER_WARNING_POP
 
   // load
diff -Nuarp ruby-2.7.8.a/include/ruby/intern.h ruby-2.7.8.b/include/ruby/intern.h
--- ruby-2.7.8.a/include/ruby/intern.h	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/include/ruby/intern.h	2023-05-20 18:17:52.342510750 -0400
@@ -544,6 +544,9 @@ void rb_gc(void);
 void rb_gc_copy_finalizer(VALUE,VALUE);
 VALUE rb_gc_enable(void);
 VALUE rb_gc_disable(void);
+VALUE rb_gc_enable_stats(void);
+VALUE rb_gc_disable_stats(void);
+VALUE rb_gc_stats_enabled(void);
 VALUE rb_gc_start(void);
 VALUE rb_define_finalizer(VALUE, VALUE);
 VALUE rb_undefine_finalizer(VALUE);
@@ -551,6 +554,11 @@ size_t rb_gc_count(void);
 size_t rb_gc_stat(VALUE);
 VALUE rb_gc_latest_gc_info(VALUE);
 void rb_gc_adjust_memory_usage(ssize_t);
+double rb_gc_total_time(void);
+VALUE rb_gc_heap_slots(void);
+VALUE rb_gc_heap_slots_live_after_last_gc(void);
+size_t rb_gc_total_mallocs(void);
+size_t rb_gc_total_malloced_bytes(void);
 /* hash.c */
 void rb_st_foreach_safe(struct st_table *, int (*)(st_data_t, st_data_t, st_data_t), st_data_t);
 #define st_foreach_safe rb_st_foreach_safe
diff -Nuarp ruby-2.7.8.a/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb ruby-2.7.8.b/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb
--- ruby-2.7.8.a/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb	2023-05-20 18:17:34.437291431 -0400
@@ -197,10 +197,10 @@ class Bundler::Persistent::Net::HTTP::Pe
   ##
   # The default connection pool size is 1/4 the allowed open files.
 
-  if Gem.win_platform? then
-    DEFAULT_POOL_SIZE = 256
-  else
+  if Process.const_defined? :RLIMIT_NOFILE
     DEFAULT_POOL_SIZE = Process.getrlimit(Process::RLIMIT_NOFILE).first / 4
+  else
+    DEFAULT_POOL_SIZE = 256
   end
 
   ##
diff -Nuarp ruby-2.7.8.a/lib/mkmf.rb ruby-2.7.8.b/lib/mkmf.rb
--- ruby-2.7.8.a/lib/mkmf.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/lib/mkmf.rb	2023-05-20 18:17:23.470157093 -0400
@@ -1930,7 +1930,7 @@ SRC
 SHELL = /bin/sh
 
 # V=0 quiet, V=1 verbose.  other values don't work.
-V = 0
+V = 1
 Q1 = $(V:1=)
 Q = $(Q1:0=@)
 ECHO1 = $(V:1=@ #{CONFIG['NULLCMD']})
diff -Nuarp ruby-2.7.8.a/lib/rdoc/ri/paths.rb ruby-2.7.8.b/lib/rdoc/ri/paths.rb
--- ruby-2.7.8.a/lib/rdoc/ri/paths.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/lib/rdoc/ri/paths.rb	2023-05-20 18:17:03.213908978 -0400
@@ -10,7 +10,7 @@ module RDoc::RI::Paths
   #:stopdoc:
   require 'rbconfig'
 
-  version = RbConfig::CONFIG['ruby_version']
+  version = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
 
   BASE    = if RbConfig::CONFIG.key? 'ridir' then
               File.join RbConfig::CONFIG['ridir'], version
diff -Nuarp ruby-2.7.8.a/lib/rubygems/defaults.rb ruby-2.7.8.b/lib/rubygems/defaults.rb
--- ruby-2.7.8.a/lib/rubygems/defaults.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/lib/rubygems/defaults.rb	2023-05-20 18:17:03.214908990 -0400
@@ -32,13 +32,13 @@ module Gem
              [
                File.dirname(RbConfig::CONFIG['sitedir']),
                'Gems',
-               RbConfig::CONFIG['ruby_version']
+               RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
              ]
            else
              [
                RbConfig::CONFIG['rubylibprefix'],
                'gems',
-               RbConfig::CONFIG['ruby_version']
+               RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
              ]
            end
 
@@ -75,7 +75,8 @@ module Gem
 
   def self.user_dir
     parts = [Gem.user_home, '.gem', ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    ruby_version_dir_name = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
+    parts << ruby_version_dir_name unless ruby_version_dir_name.empty?
     File.join parts
   end
 
@@ -158,7 +159,7 @@ module Gem
     return nil unless RbConfig::CONFIG.key? 'vendordir'
 
     File.join RbConfig::CONFIG['vendordir'], 'gems',
-              RbConfig::CONFIG['ruby_version']
+              RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
   end
 
   ##
diff -Nuarp ruby-2.7.8.a/loadpath.c ruby-2.7.8.b/loadpath.c
--- ruby-2.7.8.a/loadpath.c	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/loadpath.c	2023-05-20 18:17:20.038115054 -0400
@@ -65,22 +65,38 @@ const char ruby_initial_load_paths[] =
     RUBY_SEARCH_PATH "\0"
 #endif
 #ifndef NO_RUBY_SITE_LIB
+#ifdef RUBY_LIB_VERSION_BLANK
+    RUBY_SITE_LIB "\0"
+#else
     RUBY_SITE_LIB2 "\0"
+#endif
 #ifdef RUBY_THINARCH
     RUBY_SITE_ARCH_LIB_FOR(RUBY_THINARCH) "\0"
 #endif
     RUBY_SITE_ARCH_LIB_FOR(RUBY_SITEARCH) "\0"
+#ifndef RUBY_LIB_VERSION_BLANK
     RUBY_SITE_LIB "\0"
 #endif
+#endif
 
 #ifndef NO_RUBY_VENDOR_LIB
+#ifdef RUBY_LIB_VERSION_BLANK
+    RUBY_VENDOR_LIB "\0"
+#else
     RUBY_VENDOR_LIB2 "\0"
+#endif
 #ifdef RUBY_THINARCH
     RUBY_VENDOR_ARCH_LIB_FOR(RUBY_THINARCH) "\0"
 #endif
     RUBY_VENDOR_ARCH_LIB_FOR(RUBY_SITEARCH) "\0"
+#ifndef RUBY_LIB_VERSION_BLANK
     RUBY_VENDOR_LIB "\0"
 #endif
+#endif
+
+#ifdef RUBYGEMS_DIR
+    RUBYGEMS_DIR "\0"
+#endif
 
     RUBY_LIB "\0"
 #ifdef RUBY_THINARCH
diff -Nuarp ruby-2.7.8.a/miniprelude.c ruby-2.7.8.b/miniprelude.c
--- ruby-2.7.8.a/miniprelude.c	2023-03-30 08:34:10.000000000 -0400
+++ ruby-2.7.8.b/miniprelude.c	2023-05-20 18:18:48.666200654 -0400
@@ -167,8 +167,9 @@ static const struct {
 static const char prelude_name1[] = "<internal:gc>";
 static const struct {
     char L0[506]; /* 1..71 */
-    char L71[463]; /* 72..163 */
-    char L163[204]; /* 164..170 */
+    char L71[508]; /* 72..172 */
+    char L172[503]; /* 173..244 */
+    char L244[235]; /* 245..256 */
 } prelude_code1 = {
 #line 1 "gc.rb"
 "\n"/* for gc.c */
@@ -333,18 +334,106 @@ static const struct {
 "  def self.compact\n"
 "    __builtin_rb_gc_compact\n"
 "  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.enable_stats\011  => true or false */
+"\n"/*  */
+"\n"/* Enables garbage collection statistics, returning <code>true</code> if garbage */
+"\n"/* collection statistics was already enabled. */
+"\n"/*  */
+"\n"/*    GC.enable_stats\011 #=> false or true */
+"\n"/*    GC.enable_stats\011 #=> true */
+"  def self.enable_stats\n"
+"    __builtin_gc_enable_stats\n"
+"  end\n"
+,
+#line 173 "gc.rb"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*    GC.disable_stats\011   => true or false */
+"\n"/*  */
+"\n"/* Disables garbage collection statistics, returning <code>true</code> if garbage */
+"\n"/* collection statistics was already disabled. */
+"\n"/*  */
+"\n"/*    GC.disable_stats\011  #=> false or true */
+"\n"/*    GC.disable_stats\011  #=> true */
+"  def self.disable_stats\n"
+"    __builtin_gc_disable_stats\n"
+"  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.stats_enabled?    => true or false */
+"\n"/*  */
+"\n"/* Check whether GC stats have been enabled. */
+"\n"/*  */
+"\n"/*    GC.stats_enabled?   #=> false or true */
+"  def self.stats_enabled?\n"
+"    __builtin_gc_stats_enabled\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*    GC.time\011  => Integer */
+"\n"/*  */
+"\n"/* Returns the time spent during garbage collection while GC statistics collection */
+"\n"/* was enabled (in micro seconds). */
+"\n"/*  */
+"\n"/*    GC.time\011  #=> 20000 */
+"  def self.time\n"
+"    __builtin_gc_time\n"
+"  end\n"
+"\n"
+"\n"/*  call-seq: */
+"\n"/* GC.heap_slots\011=> Integer */
+"\n"/*  */
+"\n"/*  Returns the number of heap slots available for object allocations. */
+"\n"/*  */
+"\n"/* GC.heap_slots\011#=> 10000 */
+"  def self.heap_slots\n"
+"    __builtin_gc_heap_slots\n"
+"  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.heap_slots_live_after_last_gc\011   => Integer */
+"\n"/*  */
+"\n"/* Returns the number of heap slots which were live after the last garbage collection. */
+"\n"/*  */
+"\n"/*    GC.heap_slots_live_after_last_gc\011   #=> 231223 */
+"  def self.heap_slots_live_after_last_gc\n"
+"    __builtin_gc_heap_slots_live_after_last_gc\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*  GC.total_mallocs\011   => Integer */
+"\n"/*  */
+"\n"/*   Returns the number malloc calls. Might wrap around. */
+"\n"/*  */
+"\n"/*  GC.total_mallocs\011   #=> 324234323246 */
+"  def self.total_mallocs\n"
+"    __builtin_gc_total_mallocs\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*  GC.total_malloced_bytes\011   => Integer */
+"\n"/*  */
+"\n"/*   Returns the number of bytes allocated. Might wrap around. */
+"\n"/*  */
+"\n"/*  GC.total_malloced_bytes\011   #=> 354656256432446 */
+"  def self.total_malloced_bytes\n"
+"    __builtin_gc_total_malloced_bytes\n"
+,
+#line 245 "gc.rb"
+"  end\n"
+"\n"
 "end\n"
 "\n"
 "module ObjectSpace\n"
-,
-#line 164 "gc.rb"
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
 "    __builtin_gc_start_internal full_mark, immediate_mark, immediate_sweep\n"
 "  end\n"
 "\n"
 "  module_function :garbage_collect\n"
 "end\n"
-#line 348 "miniprelude.c"
+#line 437 "miniprelude.c"
 };
 
 static const char prelude_name2[] = "<internal:io>";
@@ -475,7 +564,7 @@ static const struct {
 "    __builtin_io_write_nonblock(buf, exception)\n"
 "  end\n"
 "end\n"
-#line 479 "miniprelude.c"
+#line 568 "miniprelude.c"
 };
 
 static const char prelude_name3[] = "<internal:pack>";
@@ -766,7 +855,7 @@ static const struct {
 "    __builtin_pack_unpack1(fmt)\n"
 "  end\n"
 "end\n"
-#line 770 "miniprelude.c"
+#line 859 "miniprelude.c"
 };
 
 static const char prelude_name4[] = "<internal:trace_point>";
@@ -1131,7 +1220,7 @@ static const struct {
 "    __builtin_tracepoint_attr_instruction_sequence\n"
 "  end\n"
 "end\n"
-#line 1135 "miniprelude.c"
+#line 1224 "miniprelude.c"
 };
 
 static const char prelude_name5[] = "<internal:warning>";
@@ -1184,7 +1273,7 @@ static const struct {
 "    __builtin_rb_warn_m(msgs, uplevel)\n"
 "  end\n"
 "end\n"
-#line 1188 "miniprelude.c"
+#line 1277 "miniprelude.c"
 };
 
 static const char prelude_name6[] = "<internal:prelude>";
@@ -1229,7 +1318,7 @@ static const struct {
 "\n"
 "  private :pp\n"
 "end\n"
-#line 1233 "miniprelude.c"
+#line 1322 "miniprelude.c"
 };
 
 static const char prelude_name7[] = "<internal:gem_prelude>";
@@ -1239,7 +1328,7 @@ static const struct {
 #line 1 "gem_prelude.rb"
 "require 'rubygems.rb' if defined?(Gem)\n"
 "require 'did_you_mean' if defined?(DidYouMean)\n"
-#line 1243 "miniprelude.c"
+#line 1332 "miniprelude.c"
 };
 
 #define PRELUDE_NAME(n) rb_usascii_str_new_static(prelude_name##n, sizeof(prelude_name##n)-1)
diff -Nuarp ruby-2.7.8.a/ruby.c ruby-2.7.8.b/ruby.c
--- ruby-2.7.8.a/ruby.c	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/ruby.c	2023-05-20 18:17:27.031200712 -0400
@@ -1463,10 +1463,14 @@ proc_options(long argc, char **argv, rub
 
 void Init_builtin_features(void);
 
+/* abrt.c */
+void Init_abrt(void);
+
 static void
 ruby_init_prelude(void)
 {
     Init_builtin_features();
+    Init_abrt();
     rb_const_remove(rb_cObject, rb_intern_const("TMP_RUBY_PREFIX"));
 }
 
diff -Nuarp ruby-2.7.8.a/ruby.c.orig ruby-2.7.8.b/ruby.c.orig
--- ruby-2.7.8.a/ruby.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.8.b/ruby.c.orig	2023-05-20 18:16:53.419789012 -0400
@@ -0,0 +1,2485 @@
+/**********************************************************************
+
+  ruby.c -
+
+  $Author$
+  created at: Tue Aug 10 12:47:31 JST 1993
+
+  Copyright (C) 1993-2007 Yukihiro Matsumoto
+  Copyright (C) 2000  Network Applied Communication Laboratory, Inc.
+  Copyright (C) 2000  Information-technology Promotion Agency, Japan
+
+**********************************************************************/
+
+#ifdef __CYGWIN__
+#include <windows.h>
+#include <sys/cygwin.h>
+#endif
+#include "ruby/encoding.h"
+#include "ruby/thread.h"
+#include "ruby/version.h"
+#include "internal.h"
+#include "eval_intern.h"
+#include "dln.h"
+#include <stdio.h>
+#include <sys/types.h>
+#include <ctype.h>
+
+#ifdef __hpux
+#include <sys/pstat.h>
+#endif
+#if (defined(LOAD_RELATIVE) || defined(__MACH__)) && defined(HAVE_DLADDR)
+#include <dlfcn.h>
+#endif
+
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#if defined(HAVE_FCNTL_H)
+#include <fcntl.h>
+#elif defined(HAVE_SYS_FCNTL_H)
+#include <sys/fcntl.h>
+#endif
+#ifdef HAVE_SYS_PARAM_H
+# include <sys/param.h>
+#endif
+#ifndef MAXPATHLEN
+# define MAXPATHLEN 1024
+#endif
+#ifndef O_ACCMODE
+# define O_ACCMODE (O_RDONLY | O_WRONLY | O_RDWR)
+#endif
+
+#include "ruby/util.h"
+
+#include "mjit.h"
+
+void Init_ruby_description(void);
+
+#ifndef HAVE_STDLIB_H
+char *getenv();
+#endif
+
+#ifndef DISABLE_RUBYGEMS
+# define DISABLE_RUBYGEMS 0
+#endif
+#if DISABLE_RUBYGEMS
+#define DEFAULT_RUBYGEMS_ENABLED "disabled"
+#else
+#define DEFAULT_RUBYGEMS_ENABLED "enabled"
+#endif
+
+void rb_warning_category_update(unsigned int mask, unsigned int bits);
+
+#define COMMA ,
+#define FEATURE_BIT(bit) (1U << feature_##bit)
+#define EACH_FEATURES(X, SEP) \
+    X(gems) \
+    SEP \
+    X(did_you_mean) \
+    SEP \
+    X(rubyopt) \
+    SEP \
+    X(frozen_string_literal) \
+    SEP \
+    X(jit) \
+    /* END OF FEATURES */
+#define EACH_DEBUG_FEATURES(X, SEP) \
+    X(frozen_string_literal) \
+    /* END OF DEBUG FEATURES */
+#define AMBIGUOUS_FEATURE_NAMES 0 /* no ambiguous feature names now */
+#define DEFINE_FEATURE(bit) feature_##bit
+#define DEFINE_DEBUG_FEATURE(bit) feature_debug_##bit
+enum feature_flag_bits {
+    EACH_FEATURES(DEFINE_FEATURE, COMMA),
+    feature_debug_flag_first,
+    feature_debug_flag_begin = feature_debug_flag_first - 1,
+    EACH_DEBUG_FEATURES(DEFINE_DEBUG_FEATURE, COMMA),
+    feature_flag_count
+};
+
+#define DEBUG_BIT(bit) (1U << feature_debug_##bit)
+
+#define DUMP_BIT(bit) (1U << dump_##bit)
+#define DEFINE_DUMP(bit) dump_##bit
+#define EACH_DUMPS(X, SEP) \
+    X(version) \
+    SEP \
+    X(copyright) \
+    SEP \
+    X(usage) \
+    SEP \
+    X(help) \
+    SEP \
+    X(yydebug) \
+    SEP \
+    X(syntax) \
+    SEP \
+    X(parsetree) \
+    SEP \
+    X(parsetree_with_comment) \
+    SEP \
+    X(insns) \
+    /* END OF DUMPS */
+enum dump_flag_bits {
+    dump_version_v,
+    EACH_DUMPS(DEFINE_DUMP, COMMA),
+    dump_exit_bits = (DUMP_BIT(yydebug) | DUMP_BIT(syntax) |
+		      DUMP_BIT(parsetree) | DUMP_BIT(parsetree_with_comment) |
+		      DUMP_BIT(insns))
+};
+
+typedef struct ruby_cmdline_options ruby_cmdline_options_t;
+
+typedef struct {
+    unsigned int mask;
+    unsigned int set;
+} ruby_features_t;
+
+static inline void
+rb_feature_set_to(ruby_features_t *feat, unsigned int bit_mask, unsigned int bit_set)
+{
+    feat->mask |= bit_mask;
+    feat->set = (feat->set & ~bit_mask) | bit_set;
+}
+
+#define FEATURE_SET_TO(feat, bit_mask, bit_set) \
+    rb_feature_set_to(&(feat), bit_mask, bit_set)
+#define FEATURE_SET(feat, bits) FEATURE_SET_TO(feat, bits, bits)
+#define FEATURE_SET_RESTORE(feat, save) FEATURE_SET_TO(feat, (save).mask, (save).set & (save).mask)
+#define FEATURE_SET_P(feat, bits) ((feat).set & (bits))
+
+struct ruby_cmdline_options {
+    const char *script;
+    VALUE script_name;
+    VALUE e_script;
+    struct {
+	struct {
+	    VALUE name;
+	    int index;
+	} enc;
+    } src, ext, intern;
+    VALUE req_list;
+    ruby_features_t features;
+    ruby_features_t warn;
+    unsigned int dump;
+#if USE_MJIT
+    struct mjit_options mjit;
+#endif
+    int sflag, xflag;
+    unsigned int warning: 1;
+    unsigned int verbose: 1;
+    unsigned int do_loop: 1;
+    unsigned int do_print: 1;
+    unsigned int do_line: 1;
+    unsigned int do_split: 1;
+    unsigned int do_search: 1;
+    unsigned int setids: 2;
+};
+
+static void init_ids(ruby_cmdline_options_t *);
+
+#define src_encoding_index GET_VM()->src_encoding_index
+
+enum {
+    COMPILATION_FEATURES = (
+	0
+	| FEATURE_BIT(frozen_string_literal)
+	| FEATURE_BIT(debug_frozen_string_literal)
+	),
+    DEFAULT_FEATURES = (
+	(FEATURE_BIT(debug_flag_first)-1)
+#if DISABLE_RUBYGEMS
+	& ~FEATURE_BIT(gems)
+#endif
+	& ~FEATURE_BIT(frozen_string_literal)
+        & ~FEATURE_BIT(jit)
+	)
+};
+
+static ruby_cmdline_options_t *
+cmdline_options_init(ruby_cmdline_options_t *opt)
+{
+    MEMZERO(opt, *opt, 1);
+    init_ids(opt);
+    opt->src.enc.index = src_encoding_index;
+    opt->ext.enc.index = -1;
+    opt->intern.enc.index = -1;
+    opt->features.set = DEFAULT_FEATURES;
+#ifdef MJIT_FORCE_ENABLE /* to use with: ./configure cppflags="-DMJIT_FORCE_ENABLE" */
+    opt->features.set |= FEATURE_BIT(jit);
+#endif
+    return opt;
+}
+
+static rb_ast_t *load_file(VALUE parser, VALUE fname, VALUE f, int script,
+		       ruby_cmdline_options_t *opt);
+static VALUE open_load_file(VALUE fname_v, int *xflag);
+static void forbid_setid(const char *, const ruby_cmdline_options_t *);
+#define forbid_setid(s) forbid_setid((s), opt)
+
+static struct {
+    int argc;
+    char **argv;
+} origarg;
+
+static void
+show_usage_line(const char *str, unsigned int namelen, unsigned int secondlen, int help)
+{
+    const unsigned int w = 16;
+    const int wrap = help && namelen + secondlen - 1 > w;
+    printf("  %.*s%-*.*s%-*s%s\n", namelen-1, str,
+	   (wrap ? 0 : w - namelen + 1),
+	   (help ? secondlen-1 : 0), str + namelen,
+	   (wrap ? w + 3 : 0), (wrap ? "\n" : ""),
+	   str + namelen + secondlen);
+}
+
+static void
+usage(const char *name, int help)
+{
+    /* This message really ought to be max 23 lines.
+     * Removed -h because the user already knows that option. Others? */
+
+    struct message {
+	const char *str;
+	unsigned short namelen, secondlen;
+    };
+#define M(shortopt, longopt, desc) { \
+    shortopt " " longopt " " desc, \
+    (unsigned short)sizeof(shortopt), \
+    (unsigned short)sizeof(longopt), \
+}
+    static const struct message usage_msg[] = {
+	M("-0[octal]",	   "",			   "specify record separator (\\0, if no argument)"),
+	M("-a",		   "",			   "autosplit mode with -n or -p (splits $_ into $F)"),
+	M("-c",		   "",			   "check syntax only"),
+	M("-Cdirectory",   "",			   "cd to directory before executing your script"),
+	M("-d",		   ", --debug",		   "set debugging flags (set $DEBUG to true)"),
+	M("-e 'command'",  "",			   "one line of script. Several -e's allowed. Omit [programfile]"),
+	M("-Eex[:in]",     ", --encoding=ex[:in]", "specify the default external and internal character encodings"),
+	M("-Fpattern",	   "",			   "split() pattern for autosplit (-a)"),
+	M("-i[extension]", "",			   "edit ARGV files in place (make backup if extension supplied)"),
+	M("-Idirectory",   "",			   "specify $LOAD_PATH directory (may be used more than once)"),
+	M("-l",		   "",			   "enable line ending processing"),
+	M("-n",		   "",			   "assume 'while gets(); ... end' loop around your script"),
+	M("-p",		   "",			   "assume loop like -n but print line also like sed"),
+	M("-rlibrary",	   "",			   "require the library before executing your script"),
+	M("-s",		   "",			   "enable some switch parsing for switches after script name"),
+	M("-S",		   "",			   "look for the script using PATH environment variable"),
+	M("-v",		   "",			   "print the version number, then turn on verbose mode"),
+	M("-w",		   "",			   "turn warnings on for your script"),
+	M("-W[level=2|:category]",   "",	   "set warning level; 0=silence, 1=medium, 2=verbose"),
+	M("-x[directory]", "",			   "strip off text before #!ruby line and perhaps cd to directory"),
+        M("--jit",         "",                     "enable JIT with default options (experimental)"),
+        M("--jit-[option]","",                     "enable JIT with an option (experimental)"),
+	M("-h",		   "",			   "show this message, --help for more info"),
+    };
+    static const struct message help_msg[] = {
+	M("--copyright",                            "", "print the copyright"),
+	M("--dump={insns|parsetree|...}[,...]",     "",
+          "dump debug information. see below for available dump list"),
+	M("--enable={gems|rubyopt|...}[,...]", ", --disable={gems|rubyopt|...}[,...]",
+	  "enable or disable features. see below for available features"),
+	M("--external-encoding=encoding",           ", --internal-encoding=encoding",
+	  "specify the default external or internal character encoding"),
+	M("--verbose",                              "", "turn on verbose mode and disable script from stdin"),
+	M("--version",                              "", "print the version number, then exit"),
+	M("--help",			            "", "show this message, -h for short message"),
+    };
+    static const struct message dumps[] = {
+	M("insns",                  "", "instruction sequences"),
+	M("yydebug",                "", "yydebug of yacc parser generator"),
+	M("parsetree",              "", "AST"),
+	M("parsetree_with_comment", "", "AST with comments"),
+    };
+    static const struct message features[] = {
+	M("gems",    "",        "rubygems (default: "DEFAULT_RUBYGEMS_ENABLED")"),
+	M("did_you_mean", "",   "did_you_mean (default: "DEFAULT_RUBYGEMS_ENABLED")"),
+	M("rubyopt", "",        "RUBYOPT environment variable (default: enabled)"),
+	M("frozen-string-literal", "", "freeze all string literals (default: disabled)"),
+        M("jit", "",            "JIT compiler (default: disabled)"),
+    };
+    static const struct message warn_categories[] = {
+        M("deprecated", "",       "deprecated features"),
+        M("experimental", "",     "experimental features"),
+    };
+    static const struct message mjit_options[] = {
+        M("--jit-warnings",      "", "Enable printing JIT warnings"),
+        M("--jit-debug",         "", "Enable JIT debugging (very slow), or add cflags if specified"),
+        M("--jit-wait",          "", "Wait until JIT compilation finishes every time (for testing)"),
+        M("--jit-save-temps",    "", "Save JIT temporary files in $TMP or /tmp (for testing)"),
+        M("--jit-verbose=num",   "", "Print JIT logs of level num or less to stderr (default: 0)"),
+        M("--jit-max-cache=num", "", "Max number of methods to be JIT-ed in a cache (default: 100)"),
+        M("--jit-min-calls=num", "", "Number of calls to trigger JIT (for testing, default: 10000)"),
+    };
+    int i;
+    const int num = numberof(usage_msg) - (help ? 1 : 0);
+#define SHOW(m) show_usage_line((m).str, (m).namelen, (m).secondlen, help)
+
+    printf("Usage: %s [switches] [--] [programfile] [arguments]\n", name);
+    for (i = 0; i < num; ++i)
+	SHOW(usage_msg[i]);
+
+    if (!help) return;
+
+    for (i = 0; i < numberof(help_msg); ++i)
+	SHOW(help_msg[i]);
+    puts("Dump List:");
+    for (i = 0; i < numberof(dumps); ++i)
+	SHOW(dumps[i]);
+    puts("Features:");
+    for (i = 0; i < numberof(features); ++i)
+	SHOW(features[i]);
+    puts("Warning categories:");
+    for (i = 0; i < numberof(warn_categories); ++i)
+	SHOW(warn_categories[i]);
+    puts("JIT options (experimental):");
+    for (i = 0; i < numberof(mjit_options); ++i)
+	SHOW(mjit_options[i]);
+}
+
+#define rubylib_path_new rb_str_new
+
+static void
+push_include(const char *path, VALUE (*filter)(VALUE))
+{
+    const char sep = PATH_SEP_CHAR;
+    const char *p, *s;
+    VALUE load_path = GET_VM()->load_path;
+
+    p = path;
+    while (*p) {
+	while (*p == sep)
+	    p++;
+	if (!*p) break;
+	for (s = p; *s && *s != sep; s = CharNext(s));
+	rb_ary_push(load_path, (*filter)(rubylib_path_new(p, s - p)));
+	p = s;
+    }
+}
+
+#ifdef __CYGWIN__
+static void
+push_include_cygwin(const char *path, VALUE (*filter)(VALUE))
+{
+    const char *p, *s;
+    char rubylib[FILENAME_MAX];
+    VALUE buf = 0;
+
+    p = path;
+    while (*p) {
+	unsigned int len;
+	while (*p == ';')
+	    p++;
+	if (!*p) break;
+	for (s = p; *s && *s != ';'; s = CharNext(s));
+	len = s - p;
+	if (*s) {
+	    if (!buf) {
+		buf = rb_str_new(p, len);
+		p = RSTRING_PTR(buf);
+	    }
+	    else {
+		rb_str_resize(buf, len);
+		p = strncpy(RSTRING_PTR(buf), p, len);
+	    }
+	}
+#ifdef HAVE_CYGWIN_CONV_PATH
+#define CONV_TO_POSIX_PATH(p, lib) \
+	cygwin_conv_path(CCP_WIN_A_TO_POSIX|CCP_RELATIVE, (p), (lib), sizeof(lib))
+#else
+# error no cygwin_conv_path
+#endif
+	if (CONV_TO_POSIX_PATH(p, rubylib) == 0)
+	    p = rubylib;
+	push_include(p, filter);
+	if (!*s) break;
+	p = s + 1;
+    }
+}
+
+#define push_include push_include_cygwin
+#endif
+
+void
+ruby_push_include(const char *path, VALUE (*filter)(VALUE))
+{
+    if (path == 0)
+	return;
+    push_include(path, filter);
+}
+
+static VALUE
+identical_path(VALUE path)
+{
+    return path;
+}
+static VALUE
+locale_path(VALUE path)
+{
+    rb_enc_associate(path, rb_locale_encoding());
+    return path;
+}
+
+void
+ruby_incpush(const char *path)
+{
+    ruby_push_include(path, locale_path);
+}
+
+static VALUE
+expand_include_path(VALUE path)
+{
+    char *p = RSTRING_PTR(path);
+    if (!p)
+	return path;
+    if (*p == '.' && p[1] == '/')
+	return path;
+    return rb_file_expand_path(path, Qnil);
+}
+
+void
+ruby_incpush_expand(const char *path)
+{
+    ruby_push_include(path, expand_include_path);
+}
+
+#undef UTF8_PATH
+#if defined _WIN32 || defined __CYGWIN__
+static HMODULE libruby;
+
+BOOL WINAPI
+DllMain(HINSTANCE dll, DWORD reason, LPVOID reserved)
+{
+    if (reason == DLL_PROCESS_ATTACH)
+	libruby = dll;
+    return TRUE;
+}
+
+HANDLE
+rb_libruby_handle(void)
+{
+    return libruby;
+}
+
+static inline void
+translit_char_bin(char *p, int from, int to)
+{
+    while (*p) {
+	if ((unsigned char)*p == from)
+	    *p = to;
+	p++;
+    }
+}
+#endif
+
+#ifdef _WIN32
+# define UTF8_PATH 1
+#endif
+
+#ifndef UTF8_PATH
+# define UTF8_PATH 0
+#endif
+#if UTF8_PATH
+# define IF_UTF8_PATH(t, f) t
+#else
+# define IF_UTF8_PATH(t, f) f
+#endif
+
+#if UTF8_PATH
+static VALUE
+str_conv_enc(VALUE str, rb_encoding *from, rb_encoding *to)
+{
+    return rb_str_conv_enc_opts(str, from, to,
+				ECONV_UNDEF_REPLACE|ECONV_INVALID_REPLACE,
+				Qnil);
+}
+#else
+# define str_conv_enc(str, from, to) (str)
+#endif
+
+void ruby_init_loadpath(void);
+
+#if defined(LOAD_RELATIVE) || defined(__MACH__)
+static VALUE
+runtime_libruby_path(void)
+{
+#if defined _WIN32 || defined __CYGWIN__
+    DWORD len = RSTRING_EMBED_LEN_MAX, ret;
+    VALUE path;
+    VALUE wsopath = rb_str_new(0, len*sizeof(WCHAR));
+    WCHAR *wlibpath;
+    char *libpath;
+
+    while (wlibpath = (WCHAR *)RSTRING_PTR(wsopath),
+	   ret = GetModuleFileNameW(libruby, wlibpath, len),
+	   (ret == len))
+    {
+	rb_str_modify_expand(wsopath, len*sizeof(WCHAR));
+	rb_str_set_len(wsopath, (len += len)*sizeof(WCHAR));
+    }
+    if (!ret || ret > len) rb_fatal("failed to get module file name");
+#if defined __CYGWIN__
+    {
+	const int win_to_posix = CCP_WIN_W_TO_POSIX | CCP_RELATIVE;
+	size_t newsize = cygwin_conv_path(win_to_posix, wlibpath, 0, 0);
+	if (!newsize) rb_fatal("failed to convert module path to cygwin");
+	path = rb_str_new(0, newsize);
+	libpath = RSTRING_PTR(path);
+	if (cygwin_conv_path(win_to_posix, wlibpath, libpath, newsize)) {
+	    rb_str_resize(path, 0);
+	}
+    }
+#else
+    {
+	DWORD i;
+	for (len = ret, i = 0; i < len; ++i) {
+	    if (wlibpath[i] == L'\\') {
+		wlibpath[i] = L'/';
+		ret = i+1;	/* chop after the last separator */
+	    }
+	}
+    }
+    len = WideCharToMultiByte(CP_UTF8, 0, wlibpath, ret, NULL, 0, NULL, NULL);
+    path = rb_utf8_str_new(0, len);
+    libpath = RSTRING_PTR(path);
+    WideCharToMultiByte(CP_UTF8, 0, wlibpath, ret, libpath, len, NULL, NULL);
+#endif
+    rb_str_resize(wsopath, 0);
+    return path;
+#elif defined(HAVE_DLADDR)
+    Dl_info dli;
+    VALUE fname, path;
+    const void* addr = (void *)(VALUE)expand_include_path;
+
+    if (!dladdr((void *)addr, &dli)) {
+	return rb_str_new(0, 0);
+    }
+#ifdef __linux__
+    else if (origarg.argc > 0 && origarg.argv && dli.dli_fname == origarg.argv[0]) {
+	fname = rb_str_new_cstr("/proc/self/exe");
+	path = rb_readlink(fname, NULL);
+    }
+#endif
+    else {
+	fname = rb_str_new_cstr(dli.dli_fname);
+	path = rb_realpath_internal(Qnil, fname, 1);
+    }
+    rb_str_resize(fname, 0);
+    return path;
+#else
+# error relative load path is not supported on this platform.
+#endif
+}
+#endif
+
+#define INITIAL_LOAD_PATH_MARK rb_intern_const("@gem_prelude_index")
+
+VALUE ruby_archlibdir_path, ruby_prefix_path;
+#if defined(__MACH__)
+// A path to libruby.dylib itself or where it's statically linked to.
+VALUE rb_libruby_selfpath;
+#endif
+
+void
+ruby_init_loadpath(void)
+{
+    VALUE load_path, archlibdir = 0;
+    ID id_initial_load_path_mark;
+    const char *paths = ruby_initial_load_paths;
+#if defined(LOAD_RELATIVE) || defined(__MACH__)
+    VALUE libruby_path = runtime_libruby_path();
+# if defined(__MACH__)
+    rb_libruby_selfpath = libruby_path;
+    rb_gc_register_address(&rb_libruby_selfpath);
+# endif
+#endif
+
+#if defined LOAD_RELATIVE
+#if !defined ENABLE_MULTIARCH
+# define RUBY_ARCH_PATH ""
+#elif defined RUBY_ARCH
+# define RUBY_ARCH_PATH "/"RUBY_ARCH
+#else
+# define RUBY_ARCH_PATH "/"RUBY_PLATFORM
+#endif
+    char *libpath;
+    VALUE sopath;
+    size_t baselen;
+    const char *p;
+
+    sopath = libruby_path;
+    libpath = RSTRING_PTR(sopath);
+
+    p = strrchr(libpath, '/');
+    if (p) {
+	static const char libdir[] = "/"
+#ifdef LIBDIR_BASENAME
+	    LIBDIR_BASENAME
+#else
+	    "lib"
+#endif
+	    RUBY_ARCH_PATH;
+	const ptrdiff_t libdir_len = (ptrdiff_t)sizeof(libdir)
+	    - rb_strlen_lit(RUBY_ARCH_PATH) - 1;
+	static const char bindir[] = "/bin";
+	const ptrdiff_t bindir_len = (ptrdiff_t)sizeof(bindir) - 1;
+
+	const char *p2 = NULL;
+
+#ifdef ENABLE_MULTIARCH
+      multiarch:
+#endif
+	if (p - libpath >= bindir_len && !STRNCASECMP(p - bindir_len, bindir, bindir_len)) {
+	    p -= bindir_len;
+	    archlibdir = rb_str_subseq(sopath, 0, p - libpath);
+	    rb_str_cat_cstr(archlibdir, libdir);
+	    OBJ_FREEZE_RAW(archlibdir);
+	}
+	else if (p - libpath >= libdir_len && !strncmp(p - libdir_len, libdir, libdir_len)) {
+	    archlibdir = rb_str_subseq(sopath, 0, (p2 ? p2 : p) - libpath);
+	    OBJ_FREEZE_RAW(archlibdir);
+	    p -= libdir_len;
+	}
+#ifdef ENABLE_MULTIARCH
+	else if (p2) {
+	    p = p2;
+	}
+	else {
+	    p2 = p;
+	    p = rb_enc_path_last_separator(libpath, p, rb_ascii8bit_encoding());
+	    if (p) goto multiarch;
+	    p = p2;
+	}
+#endif
+    }
+    baselen = p - libpath;
+    rb_str_resize(sopath, baselen);
+    libpath = RSTRING_PTR(sopath);
+#define PREFIX_PATH() sopath
+#define BASEPATH() rb_str_buf_cat(rb_str_buf_new(baselen+len), libpath, baselen)
+#define RUBY_RELATIVE(path, len) rb_str_buf_cat(BASEPATH(), (path), (len))
+#else
+    const size_t exec_prefix_len = strlen(ruby_exec_prefix);
+#define RUBY_RELATIVE(path, len) rubylib_path_new((path), (len))
+#define PREFIX_PATH() RUBY_RELATIVE(ruby_exec_prefix, exec_prefix_len)
+#endif
+    rb_gc_register_address(&ruby_prefix_path);
+    ruby_prefix_path = PREFIX_PATH();
+    OBJ_FREEZE_RAW(ruby_prefix_path);
+    if (!archlibdir) archlibdir = ruby_prefix_path;
+    rb_gc_register_address(&ruby_archlibdir_path);
+    ruby_archlibdir_path = archlibdir;
+
+    load_path = GET_VM()->load_path;
+
+    ruby_push_include(getenv("RUBYLIB"), identical_path);
+
+    id_initial_load_path_mark = INITIAL_LOAD_PATH_MARK;
+    while (*paths) {
+	size_t len = strlen(paths);
+	VALUE path = RUBY_RELATIVE(paths, len);
+	rb_ivar_set(path, id_initial_load_path_mark, path);
+	rb_ary_push(load_path, path);
+	paths += len + 1;
+    }
+
+    rb_const_set(rb_cObject, rb_intern_const("TMP_RUBY_PREFIX"), ruby_prefix_path);
+}
+
+
+static void
+add_modules(VALUE *req_list, const char *mod)
+{
+    VALUE list = *req_list;
+    VALUE feature;
+
+    if (!list) {
+	*req_list = list = rb_ary_tmp_new(0);
+    }
+    feature = rb_str_cat_cstr(rb_str_tmp_new(0), mod);
+    rb_ary_push(list, feature);
+}
+
+static void
+require_libraries(VALUE *req_list)
+{
+    VALUE list = *req_list;
+    VALUE self = rb_vm_top_self();
+    ID require;
+    rb_encoding *extenc = rb_default_external_encoding();
+
+    CONST_ID(require, "require");
+    while (list && RARRAY_LEN(list) > 0) {
+	VALUE feature = rb_ary_shift(list);
+	rb_enc_associate(feature, extenc);
+	RBASIC_SET_CLASS_RAW(feature, rb_cString);
+	OBJ_FREEZE(feature);
+	rb_funcallv(self, require, 1, &feature);
+    }
+    *req_list = 0;
+}
+
+static const struct rb_block*
+toplevel_context(rb_binding_t *bind)
+{
+    return &bind->block;
+}
+
+static void
+process_sflag(int *sflag)
+{
+    if (*sflag > 0) {
+	long n;
+	const VALUE *args;
+	VALUE argv = rb_argv;
+
+	n = RARRAY_LEN(argv);
+	args = RARRAY_CONST_PTR(argv);
+	while (n > 0) {
+	    VALUE v = *args++;
+	    char *s = StringValuePtr(v);
+	    char *p;
+	    int hyphen = FALSE;
+
+	    if (s[0] != '-')
+		break;
+	    n--;
+	    if (s[1] == '-' && s[2] == '\0')
+		break;
+
+	    v = Qtrue;
+	    /* check if valid name before replacing - with _ */
+	    for (p = s + 1; *p; p++) {
+		if (*p == '=') {
+		    *p++ = '\0';
+		    v = rb_str_new2(p);
+		    break;
+		}
+		if (*p == '-') {
+		    hyphen = TRUE;
+		}
+		else if (*p != '_' && !ISALNUM(*p)) {
+		    VALUE name_error[2];
+		    name_error[0] =
+			rb_str_new2("invalid name for global variable - ");
+		    if (!(p = strchr(p, '='))) {
+			rb_str_cat2(name_error[0], s);
+		    }
+		    else {
+			rb_str_cat(name_error[0], s, p - s);
+		    }
+		    name_error[1] = args[-1];
+		    rb_exc_raise(rb_class_new_instance(2, name_error, rb_eNameError));
+		}
+	    }
+	    s[0] = '$';
+	    if (hyphen) {
+		for (p = s + 1; *p; ++p) {
+		    if (*p == '-')
+			*p = '_';
+		}
+	    }
+	    rb_gv_set(s, v);
+	}
+	n = RARRAY_LEN(argv) - n;
+	while (n--) {
+	    rb_ary_shift(argv);
+	}
+	*sflag = -1;
+    }
+}
+
+static long proc_options(long argc, char **argv, ruby_cmdline_options_t *opt, int envopt);
+
+static void
+moreswitches(const char *s, ruby_cmdline_options_t *opt, int envopt)
+{
+    long argc, i, len;
+    char **argv, *p;
+    const char *ap = 0;
+    VALUE argstr, argary;
+    void *ptr;
+
+    while (ISSPACE(*s)) s++;
+    if (!*s) return;
+    argstr = rb_str_tmp_new((len = strlen(s)) + (envopt!=0));
+    argary = rb_str_tmp_new(0);
+
+    p = RSTRING_PTR(argstr);
+    if (envopt) *p++ = ' ';
+    memcpy(p, s, len + 1);
+    ap = 0;
+    rb_str_cat(argary, (char *)&ap, sizeof(ap));
+    while (*p) {
+	ap = p;
+	rb_str_cat(argary, (char *)&ap, sizeof(ap));
+	while (*p && !ISSPACE(*p)) ++p;
+	if (!*p) break;
+	*p++ = '\0';
+	while (ISSPACE(*p)) ++p;
+    }
+    argc = RSTRING_LEN(argary) / sizeof(ap);
+    ap = 0;
+    rb_str_cat(argary, (char *)&ap, sizeof(ap));
+    argv = ptr = ALLOC_N(char *, argc);
+    MEMMOVE(argv, RSTRING_PTR(argary), char *, argc);
+
+    while ((i = proc_options(argc, argv, opt, envopt)) > 1 && envopt && (argc -= i) > 0) {
+	argv += i;
+	if (**argv != '-') {
+	    *--*argv = '-';
+	}
+	if ((*argv)[1]) {
+	    ++argc;
+	    --argv;
+	}
+    }
+
+    ruby_xfree(ptr);
+    /* get rid of GC */
+    rb_str_resize(argary, 0);
+    rb_str_resize(argstr, 0);
+}
+
+static int
+name_match_p(const char *name, const char *str, size_t len)
+{
+    if (len == 0) return 0;
+    while (1) {
+	while (TOLOWER(*str) == *name) {
+	    if (!--len || !*++str) return 1;
+	    ++name;
+	}
+	if (*str != '-' && *str != '_') return 0;
+	while (ISALNUM(*name)) name++;
+	if (*name != '-' && *name != '_') return 0;
+	++name;
+	++str;
+    }
+}
+
+#define NAME_MATCH_P(name, str, len) \
+    ((len) < (int)sizeof(name) && name_match_p((name), (str), (len)))
+
+#define UNSET_WHEN(name, bit, str, len)	\
+    if (NAME_MATCH_P((name), (str), (len))) { \
+	*(unsigned int *)arg &= ~(bit); \
+	return;				\
+    }
+
+#define SET_WHEN(name, bit, str, len)	\
+    if (NAME_MATCH_P((name), (str), (len))) { \
+	*(unsigned int *)arg |= (bit);	\
+	return;				\
+    }
+
+#define LITERAL_NAME_ELEMENT(name) #name
+
+static void
+feature_option(const char *str, int len, void *arg, const unsigned int enable)
+{
+    static const char list[] = EACH_FEATURES(LITERAL_NAME_ELEMENT, ", ");
+    ruby_features_t *argp = arg;
+    unsigned int mask = ~0U;
+    unsigned int set = 0U;
+#if AMBIGUOUS_FEATURE_NAMES
+    int matched = 0;
+# define FEATURE_FOUND ++matched
+#else
+# define FEATURE_FOUND goto found
+#endif
+#define SET_FEATURE(bit) \
+    if (NAME_MATCH_P(#bit, str, len)) {set |= mask = FEATURE_BIT(bit); FEATURE_FOUND;}
+    EACH_FEATURES(SET_FEATURE, ;);
+    if (NAME_MATCH_P("all", str, len)) {
+      found:
+        FEATURE_SET_TO(*argp, mask, (mask & enable));
+	return;
+    }
+#if AMBIGUOUS_FEATURE_NAMES
+    if (matched == 1) goto found;
+    if (matched > 1) {
+	VALUE mesg = rb_sprintf("ambiguous feature: `%.*s' (", len, str);
+#define ADD_FEATURE_NAME(bit) \
+	if (FEATURE_BIT(bit) & set) { \
+	    rb_str_cat_cstr(mesg, #bit); \
+	    if (--matched) rb_str_cat_cstr(mesg, ", "); \
+	}
+	EACH_FEATURES(ADD_FEATURE_NAME, ;);
+	rb_str_cat_cstr(mesg, ")");
+	rb_exc_raise(rb_exc_new_str(rb_eRuntimeError, mesg));
+#undef ADD_FEATURE_NAME
+    }
+#endif
+    rb_warn("unknown argument for --%s: `%.*s'",
+	    enable ? "enable" : "disable", len, str);
+    rb_warn("features are [%.*s].", (int)strlen(list), list);
+}
+
+static void
+enable_option(const char *str, int len, void *arg)
+{
+    feature_option(str, len, arg, ~0U);
+}
+
+static void
+disable_option(const char *str, int len, void *arg)
+{
+    feature_option(str, len, arg, 0U);
+}
+
+RUBY_EXTERN const int  ruby_patchlevel;
+int ruby_env_debug_option(const char *str, int len, void *arg);
+
+static void
+debug_option(const char *str, int len, void *arg)
+{
+    static const char list[] = EACH_DEBUG_FEATURES(LITERAL_NAME_ELEMENT, ", ");
+    ruby_features_t *argp = arg;
+#define SET_WHEN_DEBUG(bit) \
+    if (NAME_MATCH_P(#bit, str, len)) { \
+        FEATURE_SET(*argp, DEBUG_BIT(bit)); \
+        return; \
+    }
+    EACH_DEBUG_FEATURES(SET_WHEN_DEBUG, ;);
+#ifdef RUBY_DEVEL
+    if (ruby_patchlevel < 0 && ruby_env_debug_option(str, len, 0)) return;
+#endif
+    rb_warn("unknown argument for --debug: `%.*s'", len, str);
+    rb_warn("debug features are [%.*s].", (int)strlen(list), list);
+}
+
+static void
+dump_option(const char *str, int len, void *arg)
+{
+    static const char list[] = EACH_DUMPS(LITERAL_NAME_ELEMENT, ", ");
+#define SET_WHEN_DUMP(bit) SET_WHEN(#bit, DUMP_BIT(bit), str, len)
+    EACH_DUMPS(SET_WHEN_DUMP, ;);
+    rb_warn("don't know how to dump `%.*s',", len, str);
+    rb_warn("but only [%.*s].", (int)strlen(list), list);
+}
+
+static void
+set_option_encoding_once(const char *type, VALUE *name, const char *e, long elen)
+{
+    VALUE ename;
+
+    if (!elen) elen = strlen(e);
+    ename = rb_str_new(e, elen);
+
+    if (*name &&
+	rb_funcall(ename, rb_intern("casecmp"), 1, *name) != INT2FIX(0)) {
+	rb_raise(rb_eRuntimeError,
+		 "%s already set to %"PRIsVALUE, type, *name);
+    }
+    *name = ename;
+}
+
+#define set_internal_encoding_once(opt, e, elen) \
+    set_option_encoding_once("default_internal", &(opt)->intern.enc.name, (e), (elen))
+#define set_external_encoding_once(opt, e, elen) \
+    set_option_encoding_once("default_external", &(opt)->ext.enc.name, (e), (elen))
+#define set_source_encoding_once(opt, e, elen) \
+    set_option_encoding_once("source", &(opt)->src.enc.name, (e), (elen))
+
+#if USE_MJIT
+static void
+setup_mjit_options(const char *s, struct mjit_options *mjit_opt)
+{
+    if (*s == 0) return;
+    else if (strcmp(s, "-warnings") == 0) {
+        mjit_opt->warnings = 1;
+    }
+    else if (strncmp(s, "-debug=", 7) == 0) {
+        mjit_opt->debug_flags = strdup(s + 7);
+    }
+    else if (strcmp(s, "-debug") == 0) {
+        mjit_opt->debug = 1;
+    }
+    else if (strcmp(s, "-wait") == 0) {
+        mjit_opt->wait = 1;
+    }
+    else if (strcmp(s, "-save-temps") == 0) {
+        mjit_opt->save_temps = 1;
+    }
+    else if (strncmp(s, "-verbose=", 9) == 0) {
+        mjit_opt->verbose = atoi(s + 9);
+    }
+    else if (strncmp(s, "-max-cache=", 11) == 0) {
+        mjit_opt->max_cache_size = atoi(s + 11);
+    }
+    else if (strncmp(s, "-min-calls=", 11) == 0) {
+        mjit_opt->min_calls = atoi(s + 11);
+    }
+    else {
+        rb_raise(rb_eRuntimeError,
+                 "invalid MJIT option `%s' (--help will show valid MJIT options)", s + 1);
+    }
+}
+#endif
+
+static long
+proc_options(long argc, char **argv, ruby_cmdline_options_t *opt, int envopt)
+{
+    long n, argc0 = argc;
+    const char *s;
+    int warning = opt->warning;
+
+    if (argc <= 0 || !argv)
+	return 0;
+
+    for (argc--, argv++; argc > 0; argc--, argv++) {
+	const char *const arg = argv[0];
+	if (!arg || arg[0] != '-' || !arg[1])
+	    break;
+
+	s = arg + 1;
+      reswitch:
+	switch (*s) {
+	  case 'a':
+	    if (envopt) goto noenvopt;
+	    opt->do_split = TRUE;
+	    s++;
+	    goto reswitch;
+
+	  case 'p':
+	    if (envopt) goto noenvopt;
+	    opt->do_print = TRUE;
+	    /* through */
+	  case 'n':
+	    if (envopt) goto noenvopt;
+	    opt->do_loop = TRUE;
+	    s++;
+	    goto reswitch;
+
+	  case 'd':
+	    ruby_debug = Qtrue;
+	    ruby_verbose = Qtrue;
+	    s++;
+	    goto reswitch;
+
+	  case 'y':
+	    if (envopt) goto noenvopt;
+	    opt->dump |= DUMP_BIT(yydebug);
+	    s++;
+	    goto reswitch;
+
+	  case 'v':
+	    if (opt->verbose) {
+		s++;
+		goto reswitch;
+	    }
+	    opt->dump |= DUMP_BIT(version_v);
+	    opt->verbose = 1;
+	  case 'w':
+	    if (!opt->warning) {
+		warning = 1;
+		ruby_verbose = Qtrue;
+	    }
+	    FEATURE_SET(opt->warn, RB_WARN_CATEGORY_ALL_BITS);
+	    s++;
+	    goto reswitch;
+
+	  case 'W':
+            if (s[1] == ':') {
+                unsigned int bits = 0;
+                static const char no_prefix[] = "no-";
+                int enable = strncmp(s += 2, no_prefix, sizeof(no_prefix)-1) != 0;
+                if (!enable) s += sizeof(no_prefix)-1;
+                size_t len = strlen(s);
+                if (NAME_MATCH_P("deprecated", s, len)) {
+                    bits = 1U << RB_WARN_CATEGORY_DEPRECATED;
+                }
+                else if (NAME_MATCH_P("experimental", s, len)) {
+                    bits = 1U << RB_WARN_CATEGORY_EXPERIMENTAL;
+                }
+                else {
+                    rb_warn("unknown warning category: `%s'", s);
+                }
+                if (bits) FEATURE_SET_TO(opt->warn, bits, enable ? bits : 0);
+                break;
+            }
+	    {
+		size_t numlen;
+		int v = 2;	/* -W as -W2 */
+
+		if (*++s) {
+		    v = scan_oct(s, 1, &numlen);
+		    if (numlen == 0)
+			v = 1;
+		    s += numlen;
+		}
+		if (!opt->warning) {
+		    switch (v) {
+		      case 0:
+			ruby_verbose = Qnil;
+			break;
+		      case 1:
+			ruby_verbose = Qfalse;
+			break;
+		      default:
+			ruby_verbose = Qtrue;
+			break;
+		    }
+		}
+		warning = 1;
+		switch (v) {
+		  case 0:
+		    FEATURE_SET_TO(opt->warn, RB_WARN_CATEGORY_ALL_BITS, 0);
+		    break;
+		  case 1:
+		    FEATURE_SET_TO(opt->warn, 1U << RB_WARN_CATEGORY_DEPRECATED, 0);
+		    break;
+		  default:
+		    FEATURE_SET(opt->warn, RB_WARN_CATEGORY_ALL_BITS);
+		    break;
+		}
+	    }
+	    goto reswitch;
+
+	  case 'c':
+	    if (envopt) goto noenvopt;
+	    opt->dump |= DUMP_BIT(syntax);
+	    s++;
+	    goto reswitch;
+
+	  case 's':
+	    if (envopt) goto noenvopt;
+	    forbid_setid("-s");
+	    if (!opt->sflag) opt->sflag = 1;
+	    s++;
+	    goto reswitch;
+
+	  case 'h':
+	    if (envopt) goto noenvopt;
+	    opt->dump |= DUMP_BIT(usage);
+	    goto switch_end;
+
+	  case 'l':
+	    if (envopt) goto noenvopt;
+	    opt->do_line = TRUE;
+	    rb_output_rs = rb_rs;
+	    s++;
+	    goto reswitch;
+
+	  case 'S':
+	    if (envopt) goto noenvopt;
+	    forbid_setid("-S");
+	    opt->do_search = TRUE;
+	    s++;
+	    goto reswitch;
+
+	  case 'e':
+	    if (envopt) goto noenvopt;
+	    forbid_setid("-e");
+	    if (!*++s) {
+		if (!--argc)
+		    rb_raise(rb_eRuntimeError, "no code specified for -e");
+		s = *++argv;
+	    }
+	    if (!opt->e_script) {
+		opt->e_script = rb_str_new(0, 0);
+		if (opt->script == 0)
+		    opt->script = "-e";
+	    }
+	    rb_str_cat2(opt->e_script, s);
+	    rb_str_cat2(opt->e_script, "\n");
+	    break;
+
+	  case 'r':
+	    forbid_setid("-r");
+	    if (*++s) {
+		add_modules(&opt->req_list, s);
+	    }
+	    else if (argc > 1) {
+		add_modules(&opt->req_list, argv[1]);
+		argc--, argv++;
+	    }
+	    break;
+
+	  case 'i':
+	    if (envopt) goto noenvopt;
+	    forbid_setid("-i");
+	    ruby_set_inplace_mode(s + 1);
+	    break;
+
+	  case 'x':
+	    if (envopt) goto noenvopt;
+	    forbid_setid("-x");
+	    opt->xflag = TRUE;
+	    s++;
+	    if (*s && chdir(s) < 0) {
+		rb_fatal("Can't chdir to %s", s);
+	    }
+	    break;
+
+	  case 'C':
+	  case 'X':
+	    if (envopt) goto noenvopt;
+	    if (!*++s && (!--argc || !(s = *++argv) || !*s)) {
+		rb_fatal("Can't chdir");
+	    }
+	    if (chdir(s) < 0) {
+		rb_fatal("Can't chdir to %s", s);
+	    }
+	    break;
+
+	  case 'F':
+	    if (envopt) goto noenvopt;
+	    if (*++s) {
+		rb_fs = rb_reg_new(s, strlen(s), 0);
+	    }
+	    break;
+
+	  case 'E':
+	    if (!*++s && (!--argc || !(s = *++argv))) {
+		rb_raise(rb_eRuntimeError, "missing argument for -E");
+	    }
+	    goto encoding;
+
+	  case 'U':
+	    set_internal_encoding_once(opt, "UTF-8", 0);
+	    ++s;
+	    goto reswitch;
+
+	  case 'K':
+	    if (*++s) {
+		const char *enc_name = 0;
+		switch (*s) {
+		  case 'E': case 'e':
+		    enc_name = "EUC-JP";
+		    break;
+		  case 'S': case 's':
+		    enc_name = "Windows-31J";
+		    break;
+		  case 'U': case 'u':
+		    enc_name = "UTF-8";
+		    break;
+		  case 'N': case 'n': case 'A': case 'a':
+		    enc_name = "ASCII-8BIT";
+		    break;
+		}
+		if (enc_name) {
+		    opt->src.enc.name = rb_str_new2(enc_name);
+		    if (!opt->ext.enc.name)
+			opt->ext.enc.name = opt->src.enc.name;
+		}
+		s++;
+	    }
+	    goto reswitch;
+
+	  case 'T':
+            {
+                size_t numlen;
+
+                if (*++s) {
+                    scan_oct(s, 2, &numlen);
+                    s += numlen;
+                }
+            }
+            rb_warn("ruby -T will be removed in Ruby 3.0");
+	    goto reswitch;
+
+	  case 'I':
+	    forbid_setid("-I");
+	    if (*++s)
+		ruby_incpush_expand(s);
+	    else if (argc > 1) {
+		ruby_incpush_expand(argv[1]);
+		argc--, argv++;
+	    }
+	    break;
+
+	  case '0':
+	    if (envopt) goto noenvopt;
+	    {
+		size_t numlen;
+		int v;
+		char c;
+
+		v = scan_oct(s, 4, &numlen);
+		s += numlen;
+		if (v > 0377)
+		    rb_rs = Qnil;
+		else if (v == 0 && numlen >= 2) {
+		    rb_rs = rb_str_new2("");
+		}
+		else {
+		    c = v & 0xff;
+		    rb_rs = rb_str_new(&c, 1);
+		}
+	    }
+	    goto reswitch;
+
+	  case '-':
+	    if (!s[1] || (s[1] == '\r' && !s[2])) {
+		argc--, argv++;
+		goto switch_end;
+	    }
+	    s++;
+
+#	define is_option_end(c, allow_hyphen) \
+	    (!(c) || ((allow_hyphen) && (c) == '-') || (c) == '=')
+#	define check_envopt(name, allow_envopt) \
+	    (((allow_envopt) || !envopt) ? (void)0 : \
+	     rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: --" name))
+#	define need_argument(name, s, needs_arg, next_arg)			\
+	    ((*(s) ? !*++(s) : (next_arg) && (!argc || !((s) = argv[1]) || (--argc, ++argv, 0))) && (needs_arg) ? \
+	     rb_raise(rb_eRuntimeError, "missing argument for --" name) \
+	     : (void)0)
+#	define is_option_with_arg(name, allow_hyphen, allow_envopt)	\
+	    is_option_with_optarg(name, allow_hyphen, allow_envopt, Qtrue, Qtrue)
+#	define is_option_with_optarg(name, allow_hyphen, allow_envopt, needs_arg, next_arg) \
+	    (strncmp((name), s, n = sizeof(name) - 1) == 0 && is_option_end(s[n], (allow_hyphen)) ? \
+	     (check_envopt(name, (allow_envopt)), s += n, \
+	      need_argument(name, s, needs_arg, next_arg), 1) : 0)
+
+	    if (strcmp("copyright", s) == 0) {
+		if (envopt) goto noenvopt_long;
+		opt->dump |= DUMP_BIT(copyright);
+	    }
+	    else if (is_option_with_optarg("debug", Qtrue, Qtrue, Qfalse, Qfalse)) {
+		if (s && *s) {
+		    ruby_each_words(s, debug_option, &opt->features);
+		}
+		else {
+		    ruby_debug = Qtrue;
+		    ruby_verbose = Qtrue;
+		}
+            }
+	    else if (is_option_with_arg("enable", Qtrue, Qtrue)) {
+		ruby_each_words(s, enable_option, &opt->features);
+	    }
+	    else if (is_option_with_arg("disable", Qtrue, Qtrue)) {
+		ruby_each_words(s, disable_option, &opt->features);
+	    }
+	    else if (is_option_with_arg("encoding", Qfalse, Qtrue)) {
+		char *p;
+	      encoding:
+		do {
+#	define set_encoding_part(type) \
+		    if (!(p = strchr(s, ':'))) { \
+			set_##type##_encoding_once(opt, s, 0); \
+			break; \
+		    } \
+		    else if (p > s) { \
+			set_##type##_encoding_once(opt, s, p-s); \
+		    }
+		    set_encoding_part(external);
+		    if (!*(s = ++p)) break;
+		    set_encoding_part(internal);
+		    if (!*(s = ++p)) break;
+#if defined ALLOW_DEFAULT_SOURCE_ENCODING && ALLOW_DEFAULT_SOURCE_ENCODING
+		    set_encoding_part(source);
+		    if (!*(s = ++p)) break;
+#endif
+		    rb_raise(rb_eRuntimeError, "extra argument for %s: %s",
+			     (arg[1] == '-' ? "--encoding" : "-E"), s);
+#	undef set_encoding_part
+		} while (0);
+	    }
+	    else if (is_option_with_arg("internal-encoding", Qfalse, Qtrue)) {
+		set_internal_encoding_once(opt, s, 0);
+	    }
+	    else if (is_option_with_arg("external-encoding", Qfalse, Qtrue)) {
+		set_external_encoding_once(opt, s, 0);
+	    }
+#if defined ALLOW_DEFAULT_SOURCE_ENCODING && ALLOW_DEFAULT_SOURCE_ENCODING
+	    else if (is_option_with_arg("source-encoding", Qfalse, Qtrue)) {
+		set_source_encoding_once(opt, s, 0);
+	    }
+#endif
+	    else if (strcmp("version", s) == 0) {
+		if (envopt) goto noenvopt_long;
+		opt->dump |= DUMP_BIT(version);
+	    }
+	    else if (strcmp("verbose", s) == 0) {
+		opt->verbose = 1;
+		ruby_verbose = Qtrue;
+	    }
+            else if (strncmp("jit", s, 3) == 0) {
+#if USE_MJIT
+                FEATURE_SET(opt->features, FEATURE_BIT(jit));
+                setup_mjit_options(s + 3, &opt->mjit);
+#else
+                rb_warn("MJIT support is disabled.");
+#endif
+            }
+	    else if (strcmp("yydebug", s) == 0) {
+		if (envopt) goto noenvopt_long;
+		opt->dump |= DUMP_BIT(yydebug);
+	    }
+	    else if (is_option_with_arg("dump", Qfalse, Qfalse)) {
+		ruby_each_words(s, dump_option, &opt->dump);
+	    }
+	    else if (strcmp("help", s) == 0) {
+		if (envopt) goto noenvopt_long;
+		opt->dump |= DUMP_BIT(help);
+		goto switch_end;
+	    }
+	    else {
+		rb_raise(rb_eRuntimeError,
+			 "invalid option --%s  (-h will show valid options)", s);
+	    }
+	    break;
+
+	  case '\r':
+	    if (!s[1])
+		break;
+
+	  default:
+	    {
+                rb_raise(rb_eRuntimeError,
+			"invalid option -%c  (-h will show valid options)",
+                        (int)(unsigned char)*s);
+	    }
+	    goto switch_end;
+
+	  noenvopt:
+	    /* "EIdvwWrKU" only */
+	    rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: -%c", *s);
+	    break;
+
+	  noenvopt_long:
+	    rb_raise(rb_eRuntimeError, "invalid switch in RUBYOPT: --%s", s);
+	    break;
+
+	  case 0:
+	    break;
+#	undef is_option_end
+#	undef check_envopt
+#	undef need_argument
+#	undef is_option_with_arg
+#	undef is_option_with_optarg
+	}
+    }
+
+  switch_end:
+    if (warning) opt->warning = warning;
+    return argc0 - argc;
+}
+
+void Init_builtin_features(void);
+
+static void
+ruby_init_prelude(void)
+{
+    Init_builtin_features();
+    rb_const_remove(rb_cObject, rb_intern_const("TMP_RUBY_PREFIX"));
+}
+
+static int
+opt_enc_index(VALUE enc_name)
+{
+    const char *s = RSTRING_PTR(enc_name);
+    int i = rb_enc_find_index(s);
+
+    if (i < 0) {
+	rb_raise(rb_eRuntimeError, "unknown encoding name - %s", s);
+    }
+    else if (rb_enc_dummy_p(rb_enc_from_index(i))) {
+	rb_raise(rb_eRuntimeError, "dummy encoding is not acceptable - %s ", s);
+    }
+    return i;
+}
+
+#define rb_progname      (GET_VM()->progname)
+#define rb_orig_progname (GET_VM()->orig_progname)
+VALUE rb_argv0;
+VALUE rb_e_script;
+
+static VALUE
+false_value(ID _x, VALUE *_y)
+{
+    return Qfalse;
+}
+
+static VALUE
+true_value(ID _x, VALUE *_y)
+{
+    return Qtrue;
+}
+
+#define rb_define_readonly_boolean(name, val) \
+    rb_define_virtual_variable((name), (val) ? true_value : false_value, 0)
+
+static VALUE
+uscore_get(void)
+{
+    VALUE line;
+
+    line = rb_lastline_get();
+    if (!RB_TYPE_P(line, T_STRING)) {
+	rb_raise(rb_eTypeError, "$_ value need to be String (%s given)",
+		 NIL_P(line) ? "nil" : rb_obj_classname(line));
+    }
+    return line;
+}
+
+/*
+ *  call-seq:
+ *     sub(pattern, replacement)   -> $_
+ *     sub(pattern) {|...| block } -> $_
+ *
+ *  Equivalent to <code>$_.sub(<i>args</i>)</code>, except that
+ *  <code>$_</code> will be updated if substitution occurs.
+ *  Available only when -p/-n command line option specified.
+ */
+
+static VALUE
+rb_f_sub(int argc, VALUE *argv, VALUE _)
+{
+    VALUE str = rb_funcall_passing_block(uscore_get(), rb_intern("sub"), argc, argv);
+    rb_lastline_set(str);
+    return str;
+}
+
+/*
+ *  call-seq:
+ *     gsub(pattern, replacement)    -> $_
+ *     gsub(pattern) {|...| block }  -> $_
+ *
+ *  Equivalent to <code>$_.gsub...</code>, except that <code>$_</code>
+ *  will be updated if substitution occurs.
+ *  Available only when -p/-n command line option specified.
+ *
+ */
+
+static VALUE
+rb_f_gsub(int argc, VALUE *argv, VALUE _)
+{
+    VALUE str = rb_funcall_passing_block(uscore_get(), rb_intern("gsub"), argc, argv);
+    rb_lastline_set(str);
+    return str;
+}
+
+/*
+ *  call-seq:
+ *     chop   -> $_
+ *
+ *  Equivalent to <code>($_.dup).chop!</code>, except <code>nil</code>
+ *  is never returned. See String#chop!.
+ *  Available only when -p/-n command line option specified.
+ *
+ */
+
+static VALUE
+rb_f_chop(VALUE _)
+{
+    VALUE str = rb_funcall_passing_block(uscore_get(), rb_intern("chop"), 0, 0);
+    rb_lastline_set(str);
+    return str;
+}
+
+
+/*
+ *  call-seq:
+ *     chomp            -> $_
+ *     chomp(string)    -> $_
+ *
+ *  Equivalent to <code>$_ = $_.chomp(<em>string</em>)</code>. See
+ *  String#chomp.
+ *  Available only when -p/-n command line option specified.
+ *
+ */
+
+static VALUE
+rb_f_chomp(int argc, VALUE *argv, VALUE _)
+{
+    VALUE str = rb_funcall_passing_block(uscore_get(), rb_intern("chomp"), argc, argv);
+    rb_lastline_set(str);
+    return str;
+}
+
+static VALUE
+process_options(int argc, char **argv, ruby_cmdline_options_t *opt)
+{
+    rb_ast_t *ast = 0;
+    VALUE parser;
+    VALUE script_name;
+    const rb_iseq_t *iseq;
+    rb_encoding *enc, *lenc;
+#if UTF8_PATH
+    rb_encoding *uenc, *ienc = 0;
+#endif
+    const char *s;
+    char fbuf[MAXPATHLEN];
+    int i = (int)proc_options(argc, argv, opt, 0);
+    unsigned int dump = opt->dump & dump_exit_bits;
+
+    if (opt->dump & (DUMP_BIT(usage)|DUMP_BIT(help))) {
+	const char *const progname =
+	    (argc > 0 && argv && argv[0] ? argv[0] :
+	     origarg.argc > 0 && origarg.argv && origarg.argv[0] ? origarg.argv[0] :
+	     ruby_engine);
+	usage(progname, (opt->dump & DUMP_BIT(help)));
+	return Qtrue;
+    }
+
+    argc -= i;
+    argv += i;
+
+    if ((opt->features.set & FEATURE_BIT(rubyopt)) && (s = getenv("RUBYOPT"))) {
+	VALUE src_enc_name = opt->src.enc.name;
+	VALUE ext_enc_name = opt->ext.enc.name;
+	VALUE int_enc_name = opt->intern.enc.name;
+        ruby_features_t feat = opt->features;
+        ruby_features_t warn = opt->warn;
+
+	opt->src.enc.name = opt->ext.enc.name = opt->intern.enc.name = 0;
+	moreswitches(s, opt, 1);
+	if (src_enc_name)
+	    opt->src.enc.name = src_enc_name;
+	if (ext_enc_name)
+	    opt->ext.enc.name = ext_enc_name;
+	if (int_enc_name)
+	    opt->intern.enc.name = int_enc_name;
+        FEATURE_SET_RESTORE(opt->features, feat);
+        FEATURE_SET_RESTORE(opt->warn, warn);
+    }
+
+    if (opt->src.enc.name)
+	rb_warning("-K is specified; it is for 1.8 compatibility and may cause odd behavior");
+
+#if USE_MJIT
+    if (opt->features.set & FEATURE_BIT(jit)) {
+        opt->mjit.on = TRUE; /* set mjit.on for ruby_show_version() API and check to call mjit_init() */
+    }
+#endif
+    if (opt->dump & (DUMP_BIT(version) | DUMP_BIT(version_v))) {
+#if USE_MJIT
+        mjit_opts.on = opt->mjit.on; /* used by ruby_show_version(). mjit_init() still can't be called here. */
+#endif
+	ruby_show_version();
+	if (opt->dump & DUMP_BIT(version)) return Qtrue;
+    }
+    if (opt->dump & DUMP_BIT(copyright)) {
+	ruby_show_copyright();
+	return Qtrue;
+    }
+
+    if (!opt->e_script) {
+	if (argc <= 0) {	/* no more args */
+	    if (opt->verbose)
+		return Qtrue;
+	    opt->script = "-";
+	}
+	else {
+	    opt->script = argv[0];
+	    if (!opt->script || opt->script[0] == '\0') {
+		opt->script = "-";
+	    }
+	    else if (opt->do_search) {
+		char *path = getenv("RUBYPATH");
+
+		opt->script = 0;
+		if (path) {
+		    opt->script = dln_find_file_r(argv[0], path, fbuf, sizeof(fbuf));
+		}
+		if (!opt->script) {
+		    opt->script = dln_find_file_r(argv[0], getenv(PATH_ENV), fbuf, sizeof(fbuf));
+		}
+		if (!opt->script)
+		    opt->script = argv[0];
+	    }
+	    argc--;
+	    argv++;
+	}
+	if (opt->script[0] == '-' && !opt->script[1]) {
+	    forbid_setid("program input from stdin");
+	}
+    }
+
+    opt->script_name = rb_str_new_cstr(opt->script);
+    opt->script = RSTRING_PTR(opt->script_name);
+
+#if _WIN32
+    translit_char_bin(RSTRING_PTR(opt->script_name), '\\', '/');
+#elif defined DOSISH
+    translit_char(RSTRING_PTR(opt->script_name), '\\', '/');
+#endif
+
+    ruby_gc_set_params();
+    ruby_init_loadpath();
+
+#if USE_MJIT
+    if (opt->mjit.on)
+        /* Using TMP_RUBY_PREFIX created by ruby_init_loadpath(). */
+        mjit_init(&opt->mjit);
+#endif
+
+    Init_ruby_description();
+    Init_enc();
+    lenc = rb_locale_encoding();
+    rb_enc_associate(rb_progname, lenc);
+    rb_obj_freeze(rb_progname);
+    parser = rb_parser_new();
+    if (opt->dump & DUMP_BIT(yydebug)) {
+	rb_parser_set_yydebug(parser, Qtrue);
+    }
+    if (opt->ext.enc.name != 0) {
+	opt->ext.enc.index = opt_enc_index(opt->ext.enc.name);
+    }
+    if (opt->intern.enc.name != 0) {
+	opt->intern.enc.index = opt_enc_index(opt->intern.enc.name);
+    }
+    if (opt->src.enc.name != 0) {
+	opt->src.enc.index = opt_enc_index(opt->src.enc.name);
+	src_encoding_index = opt->src.enc.index;
+    }
+    if (opt->ext.enc.index >= 0) {
+	enc = rb_enc_from_index(opt->ext.enc.index);
+    }
+    else {
+	enc = lenc;
+    }
+    rb_enc_set_default_external(rb_enc_from_encoding(enc));
+    if (opt->intern.enc.index >= 0) {
+	enc = rb_enc_from_index(opt->intern.enc.index);
+	rb_enc_set_default_internal(rb_enc_from_encoding(enc));
+	opt->intern.enc.index = -1;
+#if UTF8_PATH
+	ienc = enc;
+#endif
+    }
+    script_name = opt->script_name;
+    rb_enc_associate(opt->script_name,
+		     IF_UTF8_PATH(uenc = rb_utf8_encoding(), lenc));
+#if UTF8_PATH
+    if (uenc != lenc) {
+	opt->script_name = str_conv_enc(opt->script_name, uenc, lenc);
+	opt->script = RSTRING_PTR(opt->script_name);
+    }
+#endif
+    rb_obj_freeze(opt->script_name);
+    if (IF_UTF8_PATH(uenc != lenc, 1)) {
+	long i;
+        rb_vm_t *vm = GET_VM();
+        VALUE load_path = vm->load_path;
+	const ID id_initial_load_path_mark = INITIAL_LOAD_PATH_MARK;
+        int modifiable = FALSE;
+
+        rb_get_expanded_load_path();
+	for (i = 0; i < RARRAY_LEN(load_path); ++i) {
+	    VALUE path = RARRAY_AREF(load_path, i);
+	    int mark = rb_attr_get(path, id_initial_load_path_mark) == path;
+#if UTF8_PATH
+	    VALUE newpath = rb_str_conv_enc(path, uenc, lenc);
+	    if (newpath == path) continue;
+	    path = newpath;
+#else
+	    path = rb_enc_associate(rb_str_dup(path), lenc);
+#endif
+	    if (mark) rb_ivar_set(path, id_initial_load_path_mark, path);
+            if (!modifiable) {
+                rb_ary_modify(load_path);
+                modifiable = TRUE;
+            }
+	    RARRAY_ASET(load_path, i, path);
+	}
+        if (modifiable) {
+            rb_ary_replace(vm->load_path_snapshot, load_path);
+        }
+    }
+
+    rb_warning_category_update(opt->warn.mask, opt->warn.set);
+
+    Init_ext();		/* load statically linked extensions before rubygems */
+    if (opt->features.set & FEATURE_BIT(gems)) {
+	rb_define_module("Gem");
+        if (opt->features.set & FEATURE_BIT(did_you_mean)) {
+	    rb_define_module("DidYouMean");
+	}
+    }
+    ruby_init_prelude();
+    if (opt->features.mask & COMPILATION_FEATURES) {
+	VALUE option = rb_hash_new();
+#define SET_COMPILE_OPTION(h, o, name) \
+	rb_hash_aset((h), ID2SYM(rb_intern_const(#name)),		\
+                     (FEATURE_SET_P(o->features, FEATURE_BIT(name)) ? Qtrue : Qfalse));
+	SET_COMPILE_OPTION(option, opt, frozen_string_literal);
+	SET_COMPILE_OPTION(option, opt, debug_frozen_string_literal);
+	rb_funcallv(rb_cISeq, rb_intern_const("compile_option="), 1, &option);
+#undef SET_COMPILE_OPTION
+    }
+    ruby_set_argv(argc, argv);
+    process_sflag(&opt->sflag);
+
+    rb_parser_set_context(parser, 0, TRUE);
+
+    if (opt->e_script) {
+	VALUE progname = rb_progname;
+	rb_encoding *eenc;
+	if (opt->src.enc.index >= 0) {
+	    eenc = rb_enc_from_index(opt->src.enc.index);
+	}
+	else {
+	    eenc = lenc;
+#if UTF8_PATH
+	    if (ienc) eenc = ienc;
+#endif
+	}
+#if UTF8_PATH
+	if (eenc != uenc) {
+	    opt->e_script = str_conv_enc(opt->e_script, uenc, eenc);
+	}
+#endif
+	rb_enc_associate(opt->e_script, eenc);
+	if (!(opt->dump & ~DUMP_BIT(version_v))) {
+	    ruby_set_script_name(opt->script_name);
+	    require_libraries(&opt->req_list);
+	}
+        ruby_set_script_name(progname);
+	rb_parser_set_options(parser, opt->do_print, opt->do_loop,
+			      opt->do_line, opt->do_split);
+	ast = rb_parser_compile_string(parser, opt->script, opt->e_script, 1);
+    }
+    else {
+	VALUE f;
+	f = open_load_file(script_name, &opt->xflag);
+	ast = load_file(parser, opt->script_name, f, 1, opt);
+    }
+    ruby_set_script_name(opt->script_name);
+    if (dump & DUMP_BIT(yydebug)) {
+	dump &= ~DUMP_BIT(yydebug);
+	if (!dump) return Qtrue;
+    }
+
+    if (opt->ext.enc.index >= 0) {
+	enc = rb_enc_from_index(opt->ext.enc.index);
+    }
+    else {
+	enc = lenc;
+    }
+    rb_enc_set_default_external(rb_enc_from_encoding(enc));
+    if (opt->intern.enc.index >= 0) {
+	/* Set in the shebang line */
+	enc = rb_enc_from_index(opt->intern.enc.index);
+	rb_enc_set_default_internal(rb_enc_from_encoding(enc));
+    }
+    else if (!rb_default_internal_encoding())
+	/* Freeze default_internal */
+	rb_enc_set_default_internal(Qnil);
+    rb_stdio_set_default_encoding();
+
+    if (!ast->body.root) {
+	rb_ast_dispose(ast);
+	return Qfalse;
+    }
+
+    process_sflag(&opt->sflag);
+    opt->xflag = 0;
+
+    if (dump & DUMP_BIT(syntax)) {
+	printf("Syntax OK\n");
+	dump &= ~DUMP_BIT(syntax);
+	if (!dump) return Qtrue;
+    }
+
+    if (opt->do_loop) {
+	rb_define_global_function("sub", rb_f_sub, -1);
+	rb_define_global_function("gsub", rb_f_gsub, -1);
+	rb_define_global_function("chop", rb_f_chop, 0);
+	rb_define_global_function("chomp", rb_f_chomp, -1);
+    }
+
+    if (dump & (DUMP_BIT(parsetree)|DUMP_BIT(parsetree_with_comment))) {
+	rb_io_write(rb_stdout, rb_parser_dump_tree(ast->body.root, dump & DUMP_BIT(parsetree_with_comment)));
+	rb_io_flush(rb_stdout);
+	dump &= ~DUMP_BIT(parsetree)&~DUMP_BIT(parsetree_with_comment);
+	if (!dump) {
+	    rb_ast_dispose(ast);
+	    return Qtrue;
+	}
+    }
+
+    {
+	VALUE path = Qnil;
+	if (!opt->e_script && strcmp(opt->script, "-")) {
+	    path = rb_realpath_internal(Qnil, script_name, 1);
+#if UTF8_PATH
+	    if (uenc != lenc) {
+		path = str_conv_enc(path, uenc, lenc);
+	    }
+#endif
+	    if (!ENCODING_GET(path)) { /* ASCII-8BIT */
+		rb_enc_copy(path, opt->script_name);
+	    }
+	}
+
+        rb_binding_t *toplevel_binding;
+        GetBindingPtr(rb_const_get(rb_cObject, rb_intern("TOPLEVEL_BINDING")),
+                      toplevel_binding);
+        const struct rb_block *base_block = toplevel_context(toplevel_binding);
+	iseq = rb_iseq_new_main(&ast->body, opt->script_name, path, vm_block_iseq(base_block));
+	rb_ast_dispose(ast);
+    }
+
+    if (dump & DUMP_BIT(insns)) {
+	rb_io_write(rb_stdout, rb_iseq_disasm((const rb_iseq_t *)iseq));
+	rb_io_flush(rb_stdout);
+	dump &= ~DUMP_BIT(insns);
+	if (!dump) return Qtrue;
+    }
+    if (opt->dump & dump_exit_bits) return Qtrue;
+
+    rb_define_readonly_boolean("$-p", opt->do_print);
+    rb_define_readonly_boolean("$-l", opt->do_line);
+    rb_define_readonly_boolean("$-a", opt->do_split);
+
+    if ((rb_e_script = opt->e_script) != 0) {
+        rb_gc_register_mark_object(opt->e_script);
+    }
+
+    {
+        rb_execution_context_t *ec = GET_EC();
+
+        if (opt->e_script) {
+            /* -e */
+            rb_exec_event_hook_script_compiled(ec, iseq, opt->e_script);
+        }
+        else {
+            /* file */
+            rb_exec_event_hook_script_compiled(ec, iseq, Qnil);
+        }
+    }
+    return (VALUE)iseq;
+}
+
+#ifndef DOSISH
+static void
+warn_cr_in_shebang(const char *str, long len)
+{
+    if (str[len-1] == '\n' && str[len-2] == '\r') {
+	rb_warn("shebang line ending with \\r may cause problems");
+    }
+}
+#else
+#define warn_cr_in_shebang(str, len) (void)0
+#endif
+
+struct load_file_arg {
+    VALUE parser;
+    VALUE fname;
+    int script;
+    ruby_cmdline_options_t *opt;
+    VALUE f;
+};
+
+static VALUE
+load_file_internal(VALUE argp_v)
+{
+    struct load_file_arg *argp = (struct load_file_arg *)argp_v;
+    VALUE parser = argp->parser;
+    VALUE orig_fname = argp->fname;
+    int script = argp->script;
+    ruby_cmdline_options_t *opt = argp->opt;
+    VALUE f = argp->f;
+    int line_start = 1;
+    rb_ast_t *ast = 0;
+    rb_encoding *enc;
+    ID set_encoding;
+
+    CONST_ID(set_encoding, "set_encoding");
+    if (script) {
+	VALUE c = 1;		/* something not nil */
+	VALUE line;
+	char *p, *str;
+	long len;
+	int no_src_enc = !opt->src.enc.name;
+	int no_ext_enc = !opt->ext.enc.name;
+	int no_int_enc = !opt->intern.enc.name;
+
+	enc = rb_ascii8bit_encoding();
+	rb_funcall(f, set_encoding, 1, rb_enc_from_encoding(enc));
+
+	if (opt->xflag) {
+	    line_start--;
+	  search_shebang:
+	    while (!NIL_P(line = rb_io_gets(f))) {
+		line_start++;
+		RSTRING_GETMEM(line, str, len);
+		if (len > 2 && str[0] == '#' && str[1] == '!') {
+		    if (line_start == 1) warn_cr_in_shebang(str, len);
+		    if ((p = strstr(str+2, ruby_engine)) != 0) {
+			goto start_read;
+		    }
+		}
+	    }
+	    rb_loaderror("no Ruby script found in input");
+	}
+
+	c = rb_io_getbyte(f);
+	if (c == INT2FIX('#')) {
+	    c = rb_io_getbyte(f);
+            if (c == INT2FIX('!') && !NIL_P(line = rb_io_gets(f))) {
+		RSTRING_GETMEM(line, str, len);
+		warn_cr_in_shebang(str, len);
+		if ((p = strstr(str, ruby_engine)) == 0) {
+		    /* not ruby script, assume -x flag */
+		    goto search_shebang;
+		}
+
+	      start_read:
+		str += len - 1;
+		if (*str == '\n') *str-- = '\0';
+		if (*str == '\r') *str-- = '\0';
+		/* ruby_engine should not contain a space */
+		if ((p = strstr(p, " -")) != 0) {
+		    opt->warning = 0;
+		    moreswitches(p + 1, opt, 0);
+		}
+
+		/* push back shebang for pragma may exist in next line */
+		rb_io_ungetbyte(f, rb_str_new2("!\n"));
+	    }
+	    else if (!NIL_P(c)) {
+		rb_io_ungetbyte(f, c);
+	    }
+	    rb_io_ungetbyte(f, INT2FIX('#'));
+	    if (no_src_enc && opt->src.enc.name) {
+		opt->src.enc.index = opt_enc_index(opt->src.enc.name);
+		src_encoding_index = opt->src.enc.index;
+	    }
+	    if (no_ext_enc && opt->ext.enc.name) {
+		opt->ext.enc.index = opt_enc_index(opt->ext.enc.name);
+	    }
+	    if (no_int_enc && opt->intern.enc.name) {
+		opt->intern.enc.index = opt_enc_index(opt->intern.enc.name);
+	    }
+	}
+	else if (!NIL_P(c)) {
+	    rb_io_ungetbyte(f, c);
+	}
+        if (NIL_P(c)) {
+	    argp->f = f = Qnil;
+	}
+	if (!(opt->dump & ~DUMP_BIT(version_v))) {
+	    ruby_set_script_name(opt->script_name);
+	    require_libraries(&opt->req_list);	/* Why here? unnatural */
+	}
+    }
+    if (opt->src.enc.index >= 0) {
+	enc = rb_enc_from_index(opt->src.enc.index);
+    }
+    else if (f == rb_stdin) {
+	enc = rb_locale_encoding();
+    }
+    else {
+	enc = rb_utf8_encoding();
+    }
+    rb_parser_set_options(parser, opt->do_print, opt->do_loop,
+			  opt->do_line, opt->do_split);
+    if (NIL_P(f)) {
+	f = rb_str_new(0, 0);
+	rb_enc_associate(f, enc);
+	return (VALUE)rb_parser_compile_string_path(parser, orig_fname, f, line_start);
+    }
+    rb_funcall(f, set_encoding, 2, rb_enc_from_encoding(enc), rb_str_new_cstr("-"));
+    ast = rb_parser_compile_file_path(parser, orig_fname, f, line_start);
+    rb_funcall(f, set_encoding, 1, rb_parser_encoding(parser));
+    if (script && rb_parser_end_seen_p(parser)) {
+	/*
+	 * DATA is a File that contains the data section of the executed file.
+	 * To create a data section use <tt>__END__</tt>:
+	 *
+	 *   $ cat t.rb
+	 *   puts DATA.gets
+	 *   __END__
+	 *   hello world!
+	 *
+	 *   $ ruby t.rb
+	 *   hello world!
+	 */
+	rb_define_global_const("DATA", f);
+	argp->f = Qnil;
+    }
+    return (VALUE)ast;
+}
+
+static VALUE
+open_load_file(VALUE fname_v, int *xflag)
+{
+    const char *fname = (fname_v = rb_str_encode_ospath(fname_v),
+			 StringValueCStr(fname_v));
+    long flen = RSTRING_LEN(fname_v);
+    VALUE f;
+    int e;
+
+    if (flen == 1 && fname[0] == '-') {
+	f = rb_stdin;
+    }
+    else {
+	int fd;
+	/* open(2) may block if fname is point to FIFO and it's empty. Let's
+	   use O_NONBLOCK. */
+#if defined O_NONBLOCK && HAVE_FCNTL && !(O_NONBLOCK & O_ACCMODE)
+	/* TODO: fix conflicting O_NONBLOCK in ruby/win32.h */
+# define MODE_TO_LOAD (O_RDONLY | O_NONBLOCK)
+#elif defined O_NDELAY && HAVE_FCNTL && !(O_NDELAY & O_ACCMODE)
+# define MODE_TO_LOAD (O_RDONLY | O_NDELAY)
+#else
+# define MODE_TO_LOAD (O_RDONLY)
+#endif
+	int mode = MODE_TO_LOAD;
+#if defined DOSISH || defined __CYGWIN__
+# define isdirsep(x) ((x) == '/' || (x) == '\\')
+	{
+	    static const char exeext[] = ".exe";
+	    enum {extlen = sizeof(exeext)-1};
+	    if (flen > extlen && !isdirsep(fname[flen-extlen-1]) &&
+		STRNCASECMP(fname+flen-extlen, exeext, extlen) == 0) {
+		mode |= O_BINARY;
+		*xflag = 1;
+	    }
+	}
+#endif
+
+	if ((fd = rb_cloexec_open(fname, mode, 0)) < 0) {
+	    e = errno;
+	    if (!rb_gc_for_fd(e)) {
+		rb_load_fail(fname_v, strerror(e));
+	    }
+	    if ((fd = rb_cloexec_open(fname, mode, 0)) < 0) {
+		rb_load_fail(fname_v, strerror(errno));
+	    }
+	}
+	rb_update_max_fd(fd);
+
+#if defined HAVE_FCNTL && MODE_TO_LOAD != O_RDONLY
+	/* disabling O_NONBLOCK */
+	if (fcntl(fd, F_SETFL, 0) < 0) {
+	    e = errno;
+	    (void)close(fd);
+	    rb_load_fail(fname_v, strerror(e));
+	}
+#endif
+
+	e = ruby_is_fd_loadable(fd);
+	if (!e) {
+	    e = errno;
+	    (void)close(fd);
+	    rb_load_fail(fname_v, strerror(e));
+	}
+
+	f = rb_io_fdopen(fd, mode, fname);
+	if (e < 0) {
+	    /*
+	      We need to wait if FIFO is empty. It's FIFO's semantics.
+	      rb_thread_wait_fd() release GVL. So, it's safe.
+	    */
+	    rb_thread_wait_fd(fd);
+	}
+    }
+    return f;
+}
+
+static VALUE
+restore_load_file(VALUE arg)
+{
+    struct load_file_arg *argp = (struct load_file_arg *)arg;
+    VALUE f = argp->f;
+
+    if (!NIL_P(f) && f != rb_stdin) {
+	rb_io_close(f);
+    }
+    return Qnil;
+}
+
+static rb_ast_t *
+load_file(VALUE parser, VALUE fname, VALUE f, int script, ruby_cmdline_options_t *opt)
+{
+    struct load_file_arg arg;
+    arg.parser = parser;
+    arg.fname = fname;
+    arg.script = script;
+    arg.opt = opt;
+    arg.f = f;
+    return (rb_ast_t *)rb_ensure(load_file_internal, (VALUE)&arg,
+			      restore_load_file, (VALUE)&arg);
+}
+
+void *
+rb_load_file(const char *fname)
+{
+    VALUE fname_v = rb_str_new_cstr(fname);
+    return rb_load_file_str(fname_v);
+}
+
+void *
+rb_load_file_str(VALUE fname_v)
+{
+    return rb_parser_load_file(rb_parser_new(), fname_v);
+}
+
+void *
+rb_parser_load_file(VALUE parser, VALUE fname_v)
+{
+    ruby_cmdline_options_t opt;
+    VALUE f = open_load_file(fname_v, &cmdline_options_init(&opt)->xflag);
+    return load_file(parser, fname_v, f, 0, &opt);
+}
+
+/*
+ *  call-seq:
+ *     Process.argv0  -> frozen_string
+ *
+ *  Returns the name of the script being executed.  The value is not
+ *  affected by assigning a new value to $0.
+ *
+ *  This method first appeared in Ruby 2.1 to serve as a global
+ *  variable free means to get the script name.
+ */
+
+static VALUE
+proc_argv0(VALUE process)
+{
+    return rb_orig_progname;
+}
+
+static VALUE ruby_setproctitle(VALUE title);
+
+/*
+ *  call-seq:
+ *     Process.setproctitle(string)  -> string
+ *
+ *  Sets the process title that appears on the ps(1) command.  Not
+ *  necessarily effective on all platforms.  No exception will be
+ *  raised regardless of the result, nor will NotImplementedError be
+ *  raised even if the platform does not support the feature.
+ *
+ *  Calling this method does not affect the value of $0.
+ *
+ *     Process.setproctitle('myapp: worker #%d' % worker_id)
+ *
+ *  This method first appeared in Ruby 2.1 to serve as a global
+ *  variable free means to change the process title.
+ */
+
+static VALUE
+proc_setproctitle(VALUE process, VALUE title)
+{
+    return ruby_setproctitle(title);
+}
+
+static VALUE
+ruby_setproctitle(VALUE title)
+{
+    const char *ptr = StringValueCStr(title);
+    setproctitle("%.*s", RSTRING_LENINT(title), ptr);
+    return title;
+}
+
+static void
+set_arg0(VALUE val, ID id, VALUE *_)
+{
+    if (origarg.argv == 0)
+	rb_raise(rb_eRuntimeError, "$0 not initialized");
+
+    rb_progname = rb_str_new_frozen(ruby_setproctitle(val));
+}
+
+static inline VALUE
+external_str_new_cstr(const char *p)
+{
+#if UTF8_PATH
+    VALUE str = rb_utf8_str_new_cstr(p);
+    str = str_conv_enc(str, NULL, rb_default_external_encoding());
+    return str;
+#else
+    return rb_external_str_new_cstr(p);
+#endif
+}
+
+/*! Sets the current script name to this value.
+ *
+ * This is similar to <code>$0 = name</code> in Ruby level but also affects
+ * <code>Method#location</code> and others.
+ */
+void
+ruby_script(const char *name)
+{
+    if (name) {
+	rb_orig_progname = rb_progname = external_str_new_cstr(name);
+	rb_vm_set_progname(rb_progname);
+    }
+}
+
+/*! Sets the current script name to this value.
+ *
+ * Same as ruby_script() but accepts a VALUE.
+ */
+void
+ruby_set_script_name(VALUE name)
+{
+    rb_orig_progname = rb_progname = rb_str_dup(name);
+    rb_vm_set_progname(rb_progname);
+}
+
+static void
+init_ids(ruby_cmdline_options_t *opt)
+{
+    rb_uid_t uid = getuid();
+    rb_uid_t euid = geteuid();
+    rb_gid_t gid = getgid();
+    rb_gid_t egid = getegid();
+
+    if (uid != euid) opt->setids |= 1;
+    if (egid != gid) opt->setids |= 2;
+}
+
+#undef forbid_setid
+static void
+forbid_setid(const char *s, const ruby_cmdline_options_t *opt)
+{
+    if (opt->setids & 1)
+        rb_raise(rb_eSecurityError, "no %s allowed while running setuid", s);
+    if (opt->setids & 2)
+        rb_raise(rb_eSecurityError, "no %s allowed while running setgid", s);
+}
+
+static void
+verbose_setter(VALUE val, ID id, VALUE *variable)
+{
+    *variable = RTEST(val) ? Qtrue : val;
+}
+
+static VALUE
+opt_W_getter(ID id, VALUE *variable)
+{
+    switch (*variable) {
+      case Qnil:
+	return INT2FIX(0);
+      case Qfalse:
+	return INT2FIX(1);
+      case Qtrue:
+	return INT2FIX(2);
+      default:
+	return Qnil;
+    }
+}
+
+/*! Defines built-in variables */
+void
+ruby_prog_init(void)
+{
+    rb_define_hooked_variable("$VERBOSE", &ruby_verbose, 0, verbose_setter);
+    rb_define_hooked_variable("$-v", &ruby_verbose, 0, verbose_setter);
+    rb_define_hooked_variable("$-w", &ruby_verbose, 0, verbose_setter);
+    rb_define_hooked_variable("$-W", &ruby_verbose, opt_W_getter, rb_gvar_readonly_setter);
+    rb_define_variable("$DEBUG", &ruby_debug);
+    rb_define_variable("$-d", &ruby_debug);
+
+    rb_define_hooked_variable("$0", &rb_progname, 0, set_arg0);
+    rb_define_hooked_variable("$PROGRAM_NAME", &rb_progname, 0, set_arg0);
+
+    rb_define_module_function(rb_mProcess, "argv0", proc_argv0, 0);
+    rb_define_module_function(rb_mProcess, "setproctitle", proc_setproctitle, 1);
+
+    /*
+     * ARGV contains the command line arguments used to run ruby.
+     *
+     * A library like OptionParser can be used to process command-line
+     * arguments.
+     */
+    rb_define_global_const("ARGV", rb_argv);
+}
+
+void
+ruby_set_argv(int argc, char **argv)
+{
+    int i;
+    VALUE av = rb_argv;
+
+#if defined(USE_DLN_A_OUT)
+    if (origarg.argc > 0 && origarg.argv)
+	dln_argv0 = origarg.argv[0];
+    else if (argc > 0 && argv)
+	dln_argv0 = argv[0];
+#endif
+    rb_ary_clear(av);
+    for (i = 0; i < argc; i++) {
+	VALUE arg = external_str_new_cstr(argv[i]);
+
+	OBJ_FREEZE(arg);
+	rb_ary_push(av, arg);
+    }
+}
+
+void *
+ruby_process_options(int argc, char **argv)
+{
+    ruby_cmdline_options_t opt;
+    VALUE iseq;
+    const char *script_name = (argc > 0 && argv[0]) ? argv[0] : ruby_engine;
+
+    if (!origarg.argv || origarg.argc <= 0) {
+	origarg.argc = argc;
+	origarg.argv = argv;
+    }
+    ruby_script(script_name);  /* for the time being */
+    rb_argv0 = rb_str_new4(rb_progname);
+    rb_gc_register_mark_object(rb_argv0);
+    iseq = process_options(argc, argv, cmdline_options_init(&opt));
+
+#ifndef HAVE_SETPROCTITLE
+    ruby_init_setproctitle(argc, argv);
+#endif
+
+    return (void*)(struct RData*)iseq;
+}
+
+static void
+fill_standard_fds(void)
+{
+    int f0, f1, f2, fds[2];
+    struct stat buf;
+    f0 = fstat(0, &buf) == -1 && errno == EBADF;
+    f1 = fstat(1, &buf) == -1 && errno == EBADF;
+    f2 = fstat(2, &buf) == -1 && errno == EBADF;
+    if (f0) {
+        if (pipe(fds) == 0) {
+            close(fds[1]);
+            if (fds[0] != 0) {
+                dup2(fds[0], 0);
+                close(fds[0]);
+            }
+        }
+    }
+    if (f1 || f2) {
+        if (pipe(fds) == 0) {
+            close(fds[0]);
+            if (f1 && fds[1] != 1)
+                dup2(fds[1], 1);
+            if (f2 && fds[1] != 2)
+                dup2(fds[1], 2);
+            if (fds[1] != 1 && fds[1] != 2)
+                close(fds[1]);
+        }
+    }
+}
+
+/*! Initializes the process for libruby.
+ *
+ * This function assumes this process is ruby(1) and it has just started.
+ * Usually programs that embed CRuby interpreter may not call this function,
+ * and may do their own initialization.
+ * argc and argv cannot be NULL.
+ */
+void
+ruby_sysinit(int *argc, char ***argv)
+{
+#if defined(_WIN32)
+    rb_w32_sysinit(argc, argv);
+#endif
+    if (*argc >= 0 && *argv) {
+	origarg.argc = *argc;
+	origarg.argv = *argv;
+#if defined(USE_DLN_A_OUT)
+	dln_argv0 = origarg.argv[0];
+#endif
+    }
+    fill_standard_fds();
+}
diff -Nuarp ruby-2.7.8.a/spec/ruby/core/process/groups_spec.rb ruby-2.7.8.b/spec/ruby/core/process/groups_spec.rb
--- ruby-2.7.8.a/spec/ruby/core/process/groups_spec.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/spec/ruby/core/process/groups_spec.rb	2023-05-20 18:17:48.781467131 -0400
@@ -2,13 +2,15 @@ require_relative '../../spec_helper'
 
 describe "Process.groups" do
   platform_is_not :windows do
-    it "gets an Array of the gids of groups in the supplemental group access list" do
-      groups = `id -G`.scan(/\d+/).map { |i| i.to_i }
-      gid = Process.gid
+    guard -> { return ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP'] != "1" } do
+      it "gets an Array of the gids of groups in the supplemental group access list" do
+        groups = `id -G`.scan(/\d+/).map { |i| i.to_i }
+        gid = Process.gid
 
-      expected = (groups.sort - [gid]).uniq.sort
-      actual = (Process.groups - [gid]).uniq.sort
-      actual.should == expected
+        expected = (groups.sort - [gid]).uniq.sort
+        actual = (Process.groups - [gid]).uniq.sort
+        actual.should == expected
+      end
     end
   end
 end
diff -Nuarp ruby-2.7.8.a/spec/ruby/library/etc/getgrgid_spec.rb ruby-2.7.8.b/spec/ruby/library/etc/getgrgid_spec.rb
--- ruby-2.7.8.a/spec/ruby/library/etc/getgrgid_spec.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/spec/ruby/library/etc/getgrgid_spec.rb	2023-05-20 18:17:48.781467131 -0400
@@ -15,6 +15,7 @@ end
 platform_is_not :windows do
   grpname = nil
   guard -> {
+    return false if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     grpname = IO.popen(%w'id -gn', err: IO::NULL, &:read).chomp
     $?.success?
   } do
diff -Nuarp ruby-2.7.8.a/spec/ruby/library/etc/struct_group_spec.rb ruby-2.7.8.b/spec/ruby/library/etc/struct_group_spec.rb
--- ruby-2.7.8.a/spec/ruby/library/etc/struct_group_spec.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/spec/ruby/library/etc/struct_group_spec.rb	2023-05-20 18:17:48.781467131 -0400
@@ -3,6 +3,8 @@ require 'etc'
 
 describe "Struct::Group" do
   platform_is_not :windows do
+    next if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
+
     grpname = IO.popen(%w'id -gn', err: IO::NULL, &:read)
     next unless $?.success?
     grpname.chomp!
diff -Nuarp ruby-2.7.8.a/template/ruby.pc.in ruby-2.7.8.b/template/ruby.pc.in
--- ruby-2.7.8.a/template/ruby.pc.in	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/template/ruby.pc.in	2023-05-20 18:17:03.213908978 -0400
@@ -9,6 +9,7 @@ MAJOR=@MAJOR@
 MINOR=@MINOR@
 TEENY=@TEENY@
 ruby_version=@ruby_version@
+ruby_version_dir_name=@ruby_version_dir_name@
 RUBY_API_VERSION=@RUBY_API_VERSION@
 RUBY_PROGRAM_VERSION=@RUBY_PROGRAM_VERSION@
 RUBY_BASE_NAME=@RUBY_BASE_NAME@
diff -Nuarp ruby-2.7.8.a/template/verconf.h.tmpl ruby-2.7.8.b/template/verconf.h.tmpl
--- ruby-2.7.8.a/template/verconf.h.tmpl	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/template/verconf.h.tmpl	2023-05-20 18:17:20.038115054 -0400
@@ -36,6 +36,9 @@
 % if C["RUBY_SEARCH_PATH"]
 #define RUBY_SEARCH_PATH		"${RUBY_SEARCH_PATH}"
 % end
+% if C["rubygemsdir"]
+#define RUBYGEMS_DIR			"${rubygemsdir}"
+% end
 %
 % R = {}
 % R["ruby_version"] = '"RUBY_LIB_VERSION"'
diff -Nuarp ruby-2.7.8.a/test/-ext-/bug_reporter/test_bug_reporter.rb ruby-2.7.8.b/test/-ext-/bug_reporter/test_bug_reporter.rb
--- ruby-2.7.8.a/test/-ext-/bug_reporter/test_bug_reporter.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/test/-ext-/bug_reporter/test_bug_reporter.rb	2023-05-20 18:17:45.325424798 -0400
@@ -19,7 +19,7 @@ class TestBugReporter < Test::Unit::Test
     args = ["--disable-gems", "-r-test-/bug_reporter",
             "-C", tmpdir]
     stdin = "register_sample_bug_reporter(12345); Process.kill :SEGV, $$"
-    assert_in_out_err(args, stdin, [], expected_stderr, encoding: "ASCII-8BIT")
+    assert_in_out_err(args, stdin, [], expected_stderr, encoding: "ASCII-8BIT", timeout_error: nil)
   ensure
     FileUtils.rm_rf(tmpdir) if tmpdir
   end
diff -Nuarp ruby-2.7.8.a/test/fiddle/helper.rb ruby-2.7.8.b/test/fiddle/helper.rb
--- ruby-2.7.8.a/test/fiddle/helper.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/test/fiddle/helper.rb	2023-05-20 18:17:30.709245765 -0400
@@ -6,115 +6,6 @@ require 'fiddle'
 
 libc_so = libm_so = nil
 
-case RUBY_PLATFORM
-when /cygwin/
-  libc_so = "cygwin1.dll"
-  libm_so = "cygwin1.dll"
-when /android/
-  libdir = '/system/lib'
-  if [0].pack('L!').size == 8
-    libdir = '/system/lib64'
-  end
-  libc_so = File.join(libdir, "libc.so")
-  libm_so = File.join(libdir, "libm.so")
-when /linux/
-  libdir = '/lib'
-  case RbConfig::SIZEOF['void*']
-  when 4
-    # 32-bit ruby
-    case RUBY_PLATFORM
-    when /armv\w+-linux/
-      # In the ARM 32-bit libc package such as libc6:armhf libc6:armel,
-      # libc.so and libm.so are installed to /lib/arm-linux-gnu*.
-      # It's not installed to /lib32.
-      dirs = Dir.glob('/lib/arm-linux-gnu*')
-      libdir = dirs[0] if dirs && File.directory?(dirs[0])
-    else
-      libdir = '/lib32' if File.directory? '/lib32'
-    end
-  when 8
-    # 64-bit ruby
-    libdir = '/lib64' if File.directory? '/lib64'
-  end
-  libc_so = File.join(libdir, "libc.so.6")
-  libm_so = File.join(libdir, "libm.so.6")
-when /mingw/, /mswin/
-  require "rbconfig"
-  crtname = RbConfig::CONFIG["RUBY_SO_NAME"][/msvc\w+/] || 'ucrtbase'
-  libc_so = libm_so = "#{crtname}.dll"
-when /darwin/
-  libc_so = libm_so = "/usr/lib/libSystem.B.dylib"
-when /kfreebsd/
-  libc_so = "/lib/libc.so.0.1"
-  libm_so = "/lib/libm.so.1"
-when /gnu/	#GNU/Hurd
-  libc_so = "/lib/libc.so.0.3"
-  libm_so = "/lib/libm.so.6"
-when /mirbsd/
-  libc_so = "/usr/lib/libc.so.41.10"
-  libm_so = "/usr/lib/libm.so.7.0"
-when /freebsd/
-  libc_so = "/lib/libc.so.7"
-  libm_so = "/lib/libm.so.5"
-when /bsd|dragonfly/
-  libc_so = "/usr/lib/libc.so"
-  libm_so = "/usr/lib/libm.so"
-when /solaris/
-  libdir = '/lib'
-  case RbConfig::SIZEOF['void*']
-  when 4
-    # 32-bit ruby
-    libdir = '/lib' if File.directory? '/lib'
-  when 8
-    # 64-bit ruby
-    libdir = '/lib/64' if File.directory? '/lib/64'
-  end
-  libc_so = File.join(libdir, "libc.so")
-  libm_so = File.join(libdir, "libm.so")
-when /aix/
-  pwd=Dir.pwd
-  libc_so = libm_so = "#{pwd}/libaixdltest.so"
-  unless File.exist? libc_so
-    cobjs=%w!strcpy.o!
-    mobjs=%w!floats.o sin.o!
-    funcs=%w!sin sinf strcpy strncpy!
-    expfile='dltest.exp'
-    require 'tmpdir'
-    Dir.mktmpdir do |dir|
-      begin
-        Dir.chdir dir
-        %x!/usr/bin/ar x /usr/lib/libc.a #{cobjs.join(' ')}!
-        %x!/usr/bin/ar x /usr/lib/libm.a #{mobjs.join(' ')}!
-        %x!echo "#{funcs.join("\n")}\n" > #{expfile}!
-        require 'rbconfig'
-        if RbConfig::CONFIG["GCC"] = 'yes'
-          lflag='-Wl,'
-        else
-          lflag=''
-        end
-        flags="#{lflag}-bE:#{expfile} #{lflag}-bnoentry -lm"
-        %x!#{RbConfig::CONFIG["LDSHARED"]} -o #{libc_so} #{(cobjs+mobjs).join(' ')} #{flags}!
-      ensure
-        Dir.chdir pwd
-      end
-    end
-  end
-else
-  libc_so = ARGV[0] if ARGV[0] && ARGV[0][0] == ?/
-  libm_so = ARGV[1] if ARGV[1] && ARGV[1][0] == ?/
-  if( !(libc_so && libm_so) )
-    $stderr.puts("libc and libm not found: #{$0} <libc> <libm>")
-  end
-end
-
-libc_so = nil if !libc_so || (libc_so[0] == ?/ && !File.file?(libc_so))
-libm_so = nil if !libm_so || (libm_so[0] == ?/ && !File.file?(libm_so))
-
-# macOS 11.0+ removed libSystem.B.dylib from /usr/lib. But It works with dlopen.
-if RUBY_PLATFORM =~ /darwin/
-  libc_so = libm_so = "/usr/lib/libSystem.B.dylib"
-end
-
 if !libc_so || !libm_so
   ruby = EnvUtil.rubybin
   # When the ruby binary is 32-bit and the host is 64-bit,
diff -Nuarp ruby-2.7.8.a/test/ruby/test_process.rb ruby-2.7.8.b/test/ruby/test_process.rb
--- ruby-2.7.8.a/test/ruby/test_process.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/test/ruby/test_process.rb	2023-05-20 18:17:48.782467144 -0400
@@ -1561,6 +1561,7 @@ class TestProcess < Test::Unit::TestCase
   end
 
   def test_maxgroups
+    skip "Broken groups on my AD enabled machine" if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     max = Process.maxgroups
   rescue NotImplementedError
   else
@@ -1915,6 +1916,7 @@ class TestProcess < Test::Unit::TestCase
   def test_execopts_gid
     skip "Process.groups not implemented on Windows platform" if windows?
     skip "root can use Process.groups on Android platform" if RUBY_PLATFORM =~ /android/
+    skip "Broken groups on my AD enabled machine" if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     feature6975 = '[ruby-core:47414]'
 
     groups = Process.groups.map do |g|
diff -Nuarp ruby-2.7.8.a/test/rubygems/test_gem.rb ruby-2.7.8.b/test/rubygems/test_gem.rb
--- ruby-2.7.8.a/test/rubygems/test_gem.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/test/rubygems/test_gem.rb	2023-05-20 18:17:03.214908990 -0400
@@ -1378,7 +1378,8 @@ class TestGem < Gem::TestCase
 
   def test_self_user_dir
     parts = [@userhome, '.gem', Gem.ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    ruby_version_dir_name = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
+    parts << ruby_version_dir_name unless ruby_version_dir_name.empty?
 
     assert_equal File.join(parts), Gem.user_dir
   end
@@ -1454,7 +1455,7 @@ class TestGem < Gem::TestCase
     vendordir(File.join(@tempdir, 'vendor')) do
       expected =
         File.join RbConfig::CONFIG['vendordir'], 'gems',
-                  RbConfig::CONFIG['ruby_version']
+                  RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
 
       assert_equal expected, Gem.vendor_dir
     end
diff -Nuarp ruby-2.7.8.a/tool/mkconfig.rb ruby-2.7.8.b/tool/mkconfig.rb
--- ruby-2.7.8.a/tool/mkconfig.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/tool/mkconfig.rb	2023-05-20 18:17:07.731964320 -0400
@@ -114,7 +114,7 @@ File.foreach "config.status" do |line|
     val = val.gsub(/\$(?:\$|\{?(\w+)\}?)/) {$1 ? "$(#{$1})" : $&}.dump
     case name
     when /^prefix$/
-      val = "(TOPDIR || DESTDIR + #{val})"
+      val = "(((TOPDIR && TOPDIR.empty?) ? nil : TOPDIR) || DESTDIR + #{val})"
     when /^ARCH_FLAG$/
       val = "arch_flag || #{val}" if universal
     when /^UNIVERSAL_ARCHNAMES$/
diff -Nuarp ruby-2.7.8.a/tool/rbinstall.rb ruby-2.7.8.b/tool/rbinstall.rb
--- ruby-2.7.8.a/tool/rbinstall.rb	2023-03-30 08:34:08.000000000 -0400
+++ ruby-2.7.8.b/tool/rbinstall.rb	2023-05-20 18:17:20.038115054 -0400
@@ -343,6 +343,7 @@ if CONFIG["vendordir"]
   vendorlibdir = CONFIG["vendorlibdir"]
   vendorarchlibdir = CONFIG["vendorarchdir"]
 end
+rubygemsdir = CONFIG["rubygemsdir"]
 mandir = CONFIG["mandir", true]
 docdir = CONFIG["docdir", true]
 enable_shared = CONFIG["ENABLE_SHARED"] == 'yes'
@@ -433,7 +434,7 @@ end
 
 install?(:doc, :rdoc) do
   if $rdocdir
-    ridatadir = File.join(CONFIG['ridir'], CONFIG['ruby_version'], "system")
+    ridatadir = File.join(CONFIG['ridir'], CONFIG['ruby_version_dir_name'] || CONFIG['ruby_version'], "system")
     prepare "rdoc", ridatadir
     install_recursive($rdocdir, ridatadir, :no_install => rdoc_noinst, :mode => $data_mode)
   end
@@ -570,7 +571,16 @@ end
 install?(:local, :comm, :lib) do
   prepare "library scripts", rubylibdir
   noinst = %w[*.txt *.rdoc *.gemspec]
+  # Bundler carries "rubygems.rb" file, so it must be specialcased :/
+  noinst += %w[rubygems.rb rubygems/ bundler.rb bundler/] if rubygemsdir
   install_recursive(File.join(srcdir, "lib"), rubylibdir, :no_install => noinst, :mode => $data_mode)
+  if rubygemsdir
+    noinst = %w[*.txt *.rdoc *.gemspec]
+    install_recursive(File.join(srcdir, "lib", "rubygems"), File.join(rubygemsdir, "rubygems"), :no_install => noinst, :mode => $data_mode)
+    install(File.join(srcdir, "lib", "rubygems.rb"), File.join(rubygemsdir, "rubygems.rb"), :mode => $data_mode)
+    install_recursive(File.join(srcdir, "lib", "bundler"), File.join(rubylibdir, "bundler"), :no_install => noinst, :mode => $data_mode)
+    install(File.join(srcdir, "lib", "bundler.rb"), rubylibdir, :mode => $data_mode)
+  end
 end
 
 install?(:local, :comm, :hdr, :'comm-hdr') do
