diff -Nuarp ruby-2.7.6.a/abrt.c ruby-2.7.6.b/abrt.c
--- ruby-2.7.6.a/abrt.c	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.6.b/abrt.c	2022-11-08 10:29:28.474421800 -0500
@@ -0,0 +1,12 @@
+#include "internal.h"
+
+void
+Init_abrt(void)
+{
+  rb_eval_string(
+    "  begin\n"
+    "    require 'abrt'\n"
+    "  rescue LoadError\n"
+    "  end\n"
+  );
+}
diff -Nuarp ruby-2.7.6.a/addr2line.c ruby-2.7.6.b/addr2line.c
--- ruby-2.7.6.a/addr2line.c	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/addr2line.c	2022-11-08 10:29:40.734371900 -0500
@@ -163,11 +163,12 @@ typedef struct obj_info {
     struct dwarf_section debug_info;
     struct dwarf_section debug_line;
     struct dwarf_section debug_ranges;
+    struct dwarf_section debug_rnglists;
     struct dwarf_section debug_str;
     struct obj_info *next;
 } obj_info_t;
 
-#define DWARF_SECTION_COUNT 5
+#define DWARF_SECTION_COUNT 6
 
 static struct dwarf_section *
 obj_dwarf_section_at(obj_info_t *obj, int n)
@@ -177,6 +178,7 @@ obj_dwarf_section_at(obj_info_t *obj, in
         &obj->debug_info,
         &obj->debug_line,
         &obj->debug_ranges,
+        &obj->debug_rnglists,
         &obj->debug_str
     };
     if (n < 0 || DWARF_SECTION_COUNT <= n) {
@@ -415,7 +417,7 @@ parse_debug_line_cu(int num_traces, void
 	    FILL_LINE();
 	    break;
 	case DW_LNS_advance_pc:
-	    a = uleb128((char **)&p);
+	    a = uleb128((char **)&p) * header.minimum_instruction_length;
 	    addr += a;
 	    break;
 	case DW_LNS_advance_line: {
@@ -454,7 +456,7 @@ parse_debug_line_cu(int num_traces, void
 	    /* isa = (unsigned int)*/(void)uleb128((char **)&p);
 	    break;
 	case 0:
-	    a = *(unsigned char *)p++;
+	    a = uleb128((char **)&p);
 	    op = *p++;
 	    switch (op) {
 	    case DW_LNE_end_sequence:
@@ -768,6 +770,18 @@ enum
     DW_FORM_addrx4 = 0x2c
 };
 
+/* Range list entry encodings */
+enum {
+    DW_RLE_end_of_list = 0x00,
+    DW_RLE_base_addressx = 0x01,
+    DW_RLE_startx_endx = 0x02,
+    DW_RLE_startx_length = 0x03,
+    DW_RLE_offset_pair = 0x04,
+    DW_RLE_base_address = 0x05,
+    DW_RLE_start_end = 0x06,
+    DW_RLE_start_length = 0x07
+};
+
 enum {
     VAL_none = 0,
     VAL_cstr = 1,
@@ -921,6 +935,23 @@ debug_info_reader_init(DebugInfoReader *
 }
 
 static void
+di_skip_die_attributes(char **p)
+{
+    for (;;) {
+        uint64_t at = uleb128(p);
+        uint64_t form = uleb128(p);
+        if (!at && !form) break;
+        switch (form) {
+          default:
+            break;
+          case DW_FORM_implicit_const:
+            sleb128(p);
+            break;
+        }
+    }
+}
+
+static void
 di_read_debug_abbrev_cu(DebugInfoReader *reader)
 {
     uint64_t prev = 0;
@@ -934,12 +965,7 @@ di_read_debug_abbrev_cu(DebugInfoReader
         prev = abbrev_number;
         uleb128(&p); /* tag */
         p++; /* has_children */
-        /* skip content */
-        for (;;) {
-            uint64_t at = uleb128(&p);
-            uint64_t form = uleb128(&p);
-            if (!at && !form) break;
-        }
+        di_skip_die_attributes(&p);
     }
 }
 
@@ -1203,12 +1229,7 @@ di_find_abbrev(DebugInfoReader *reader,
     /* skip 255th record */
     uleb128(&p); /* tag */
     p++; /* has_children */
-    /* skip content */
-    for (;;) {
-        uint64_t at = uleb128(&p);
-        uint64_t form = uleb128(&p);
-        if (!at && !form) break;
-    }
+    di_skip_die_attributes(&p);
     for (uint64_t n = uleb128(&p); abbrev_number != n; n = uleb128(&p)) {
         if (n == 0) {
             fprintf(stderr,"%d: Abbrev Number %"PRId64" not found\n",__LINE__, abbrev_number);
@@ -1216,12 +1237,7 @@ di_find_abbrev(DebugInfoReader *reader,
         }
         uleb128(&p); /* tag */
         p++; /* has_children */
-        /* skip content */
-        for (;;) {
-            uint64_t at = uleb128(&p);
-            uint64_t form = uleb128(&p);
-            if (!at && !form) break;
-        }
+        di_skip_die_attributes(&p);
     }
     return p;
 }
@@ -1349,6 +1365,21 @@ ranges_set(ranges_t *ptr, DebugInfoValue
     }
 }
 
+static uint64_t
+read_dw_form_addr(DebugInfoReader *reader, char **ptr)
+{
+    char *p = *ptr;
+    *ptr = p + reader->format;
+    if (reader->format == 4) {
+        return read_uint32(&p);
+    } else if (reader->format == 8) {
+        return read_uint64(&p);
+    } else {
+        fprintf(stderr,"unknown address_size:%d", reader->address_size);
+        abort();
+    }
+}
+
 static uintptr_t
 ranges_include(DebugInfoReader *reader, ranges_t *ptr, uint64_t addr)
 {
@@ -1362,8 +1393,50 @@ ranges_include(DebugInfoReader *reader,
     }
     else if (ptr->ranges_set) {
         /* TODO: support base address selection entry */
-        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        char *p;
         uint64_t base = ptr->low_pc_set ? ptr->low_pc : reader->current_low_pc;
+        if (reader->obj->debug_rnglists.ptr) {
+            p = reader->obj->debug_rnglists.ptr + ptr->ranges;
+            for (;;) {
+                uint8_t rle = read_uint8(&p);
+                uintptr_t base_address = 0;
+                uintptr_t from, to;
+                if (rle == DW_RLE_end_of_list) break;
+                switch (rle) {
+                  case DW_RLE_base_addressx:
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_startx_endx:
+                    uleb128(&p);
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_startx_length:
+                    uleb128(&p);
+                    uleb128(&p);
+                    break;
+                  case DW_RLE_offset_pair:
+                    from = base_address + uleb128(&p);
+                    to = base_address + uleb128(&p);
+                    if (base + from <= addr && addr < base + to) {
+                        return from;
+                    }
+                    break;
+                  case DW_RLE_base_address:
+                    base_address = read_dw_form_addr(reader, &p);
+                    break;
+                  case DW_RLE_start_end:
+                    read_dw_form_addr(reader, &p);
+                    read_dw_form_addr(reader, &p);
+                    break;
+                  case DW_RLE_start_length:
+                    read_dw_form_addr(reader, &p);
+                    uleb128(&p);
+                    break;
+                }
+            }
+            return false;
+        }
+        p = reader->obj->debug_ranges.ptr + ptr->ranges;
         for (;;) {
             uintptr_t from = read_uintptr(&p);
             uintptr_t to = read_uintptr(&p);
@@ -1703,6 +1776,7 @@ fill_lines(int num_traces, void **traces
                     ".debug_info",
                     ".debug_line",
                     ".debug_ranges",
+                    ".debug_rnglists",
                     ".debug_str"
                 };
 
@@ -1952,6 +2026,7 @@ found_mach_header:
                     "__debug_info",
                     "__debug_line",
                     "__debug_ranges",
+                    "__debug_rnglists",
                     "__debug_str"
                 };
                 struct LP(segment_command) *scmd = (struct LP(segment_command) *)lcmd;
diff -Nuarp ruby-2.7.6.a/addr2line.c.orig ruby-2.7.6.b/addr2line.c.orig
--- ruby-2.7.6.a/addr2line.c.orig	1969-12-31 19:00:00.000000000 -0500
+++ ruby-2.7.6.b/addr2line.c.orig	2022-11-08 10:28:55.980469200 -0500
@@ -0,0 +1,2665 @@
+/**********************************************************************
+
+  addr2line.c -
+
+  $Author$
+
+  Copyright (C) 2010 Shinichiro Hamaji
+
+**********************************************************************/
+
+#if defined(__clang__)
+#pragma clang diagnostic ignored "-Wgnu-empty-initializer"
+#pragma clang diagnostic ignored "-Wgcc-compat"
+#endif
+
+#include "ruby/config.h"
+#include "ruby/defines.h"
+#include "ruby/missing.h"
+#include "addr2line.h"
+
+#include <stdio.h>
+#include <errno.h>
+
+#ifdef HAVE_LIBPROC_H
+#include <libproc.h>
+#endif
+
+#ifdef HAVE_STDBOOL_H
+#include <stdbool.h>
+#else
+#include "missing/stdbool.h"
+#endif
+
+#if defined(USE_ELF) || defined(HAVE_MACH_O_LOADER_H)
+
+#include <fcntl.h>
+#include <limits.h>
+#include <stdio.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/mman.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+/* Make alloca work the best possible way.  */
+#ifdef __GNUC__
+# ifndef alloca
+#  define alloca __builtin_alloca
+# endif
+#else
+# ifdef HAVE_ALLOCA_H
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+#pragma alloca
+#  else
+#   ifndef alloca		/* predefined by HP cc +Olibcalls */
+void *alloca();
+#   endif
+#  endif /* AIX */
+# endif	/* HAVE_ALLOCA_H */
+#endif /* __GNUC__ */
+
+#ifdef HAVE_DLADDR
+# include <dlfcn.h>
+#endif
+
+#ifdef HAVE_MACH_O_LOADER_H
+# include <crt_externs.h>
+# include <mach-o/fat.h>
+# include <mach-o/loader.h>
+# include <mach-o/nlist.h>
+# include <mach-o/stab.h>
+#endif
+
+#ifdef USE_ELF
+# ifdef __OpenBSD__
+#  include <elf_abi.h>
+# else
+#  include <elf.h>
+# endif
+
+#ifndef ElfW
+# if SIZEOF_VOIDP == 8
+#  define ElfW(x) Elf64##_##x
+# else
+#  define ElfW(x) Elf32##_##x
+# endif
+#endif
+#ifndef ELF_ST_TYPE
+# if SIZEOF_VOIDP == 8
+#  define ELF_ST_TYPE ELF64_ST_TYPE
+# else
+#  define ELF_ST_TYPE ELF32_ST_TYPE
+# endif
+#endif
+#endif
+
+#ifdef SHF_COMPRESSED
+# if defined(ELFCOMPRESS_ZLIB) && defined(HAVE_LIBZ)
+   /* FreeBSD 11.0 lacks ELFCOMPRESS_ZLIB */
+#  include <zlib.h>
+#  define SUPPORT_COMPRESSED_DEBUG_LINE
+# endif
+#else /* compatibility with glibc < 2.22 */
+# define SHF_COMPRESSED 0
+#endif
+
+#ifndef PATH_MAX
+#define PATH_MAX 4096
+#endif
+
+#define DW_LNS_copy                     0x01
+#define DW_LNS_advance_pc               0x02
+#define DW_LNS_advance_line             0x03
+#define DW_LNS_set_file                 0x04
+#define DW_LNS_set_column               0x05
+#define DW_LNS_negate_stmt              0x06
+#define DW_LNS_set_basic_block          0x07
+#define DW_LNS_const_add_pc             0x08
+#define DW_LNS_fixed_advance_pc         0x09
+#define DW_LNS_set_prologue_end         0x0a /* DWARF3 */
+#define DW_LNS_set_epilogue_begin       0x0b /* DWARF3 */
+#define DW_LNS_set_isa                  0x0c /* DWARF3 */
+
+/* Line number extended opcode name. */
+#define DW_LNE_end_sequence             0x01
+#define DW_LNE_set_address              0x02
+#define DW_LNE_define_file              0x03
+#define DW_LNE_set_discriminator        0x04  /* DWARF4 */
+
+PRINTF_ARGS(static int kprintf(const char *fmt, ...), 1, 2);
+
+typedef struct line_info {
+    const char *dirname;
+    const char *filename;
+    const char *path; /* object path */
+    int line;
+
+    uintptr_t base_addr;
+    uintptr_t saddr;
+    const char *sname; /* function name */
+
+    struct line_info *next;
+} line_info_t;
+
+struct dwarf_section {
+    char *ptr;
+    size_t size;
+    uint64_t flags;
+};
+
+typedef struct obj_info {
+    const char *path; /* object path */
+    char *mapped;
+    size_t mapped_size;
+    void *uncompressed;
+    uintptr_t base_addr;
+    uintptr_t vmaddr;
+    struct dwarf_section debug_abbrev;
+    struct dwarf_section debug_info;
+    struct dwarf_section debug_line;
+    struct dwarf_section debug_ranges;
+    struct dwarf_section debug_str;
+    struct obj_info *next;
+} obj_info_t;
+
+#define DWARF_SECTION_COUNT 5
+
+static struct dwarf_section *
+obj_dwarf_section_at(obj_info_t *obj, int n)
+{
+    struct dwarf_section *ary[] = {
+        &obj->debug_abbrev,
+        &obj->debug_info,
+        &obj->debug_line,
+        &obj->debug_ranges,
+        &obj->debug_str
+    };
+    if (n < 0 || DWARF_SECTION_COUNT <= n) {
+        abort();
+    }
+    return ary[n];
+}
+
+struct debug_section_definition {
+    const char *name;
+    struct dwarf_section *dwarf;
+};
+
+/* Avoid consuming stack as this module may be used from signal handler */
+static char binary_filename[PATH_MAX + 1];
+
+static unsigned long
+uleb128(char **p)
+{
+    unsigned long r = 0;
+    int s = 0;
+    for (;;) {
+	unsigned char b = *(unsigned char *)(*p)++;
+	if (b < 0x80) {
+	    r += (unsigned long)b << s;
+	    break;
+	}
+	r += (b & 0x7f) << s;
+	s += 7;
+    }
+    return r;
+}
+
+static long
+sleb128(char **p)
+{
+    long r = 0;
+    int s = 0;
+    for (;;) {
+	unsigned char b = *(unsigned char *)(*p)++;
+	if (b < 0x80) {
+	    if (b & 0x40) {
+		r -= (0x80 - b) << s;
+	    }
+	    else {
+		r += (b & 0x3f) << s;
+	    }
+	    break;
+	}
+	r += (b & 0x7f) << s;
+	s += 7;
+    }
+    return r;
+}
+
+static const char *
+get_nth_dirname(unsigned long dir, char *p)
+{
+    if (!dir--) {
+	return "";
+    }
+    while (dir--) {
+	while (*p) p++;
+	p++;
+	if (!*p) {
+	    kprintf("Unexpected directory number %lu in %s\n",
+		    dir, binary_filename);
+	    return "";
+	}
+    }
+    return p;
+}
+
+static void
+fill_filename(int file, char *include_directories, char *filenames, line_info_t *line, obj_info_t *obj)
+{
+    int i;
+    char *p = filenames;
+    char *filename;
+    unsigned long dir;
+    for (i = 1; i <= file; i++) {
+	filename = p;
+	if (!*p) {
+	    /* Need to output binary file name? */
+	    kprintf("Unexpected file number %d in %s at %tx\n",
+		    file, binary_filename, filenames - obj->mapped);
+	    return;
+	}
+	while (*p) p++;
+	p++;
+	dir = uleb128(&p);
+	/* last modified. */
+	uleb128(&p);
+	/* size of the file. */
+	uleb128(&p);
+
+	if (i == file) {
+	    line->filename = filename;
+	    line->dirname = get_nth_dirname(dir, include_directories);
+	}
+    }
+}
+
+static void
+fill_line(int num_traces, void **traces, uintptr_t addr, int file, int line,
+	  char *include_directories, char *filenames,
+	  obj_info_t *obj, line_info_t *lines, int offset)
+{
+    int i;
+    addr += obj->base_addr - obj->vmaddr;
+    for (i = offset; i < num_traces; i++) {
+	uintptr_t a = (uintptr_t)traces[i];
+	/* We assume one line code doesn't result >100 bytes of native code.
+       We may want more reliable way eventually... */
+	if (addr < a && a < addr + 100) {
+	    fill_filename(file, include_directories, filenames, &lines[i], obj);
+	    lines[i].line = line;
+	}
+    }
+}
+
+struct LineNumberProgramHeader {
+    uint64_t unit_length;
+    uint16_t version;
+    uint8_t format; /* 4 or 8 */
+    uint64_t header_length;
+    uint8_t minimum_instruction_length;
+    uint8_t maximum_operations_per_instruction;
+    uint8_t default_is_stmt;
+    int8_t line_base;
+    uint8_t line_range;
+    uint8_t opcode_base;
+    /* uint8_t standard_opcode_lengths[opcode_base-1]; */
+    const char *include_directories;
+    const char *filenames;
+    const char *cu_start;
+    const char *cu_end;
+};
+
+static int
+parse_debug_line_header(const char **pp, struct LineNumberProgramHeader *header)
+{
+    const char *p = *pp;
+    header->unit_length = *(uint32_t *)p;
+    p += sizeof(uint32_t);
+
+    header->format = 4;
+    if (header->unit_length == 0xffffffff) {
+	header->unit_length = *(uint64_t *)p;
+	p += sizeof(uint64_t);
+        header->format = 8;
+    }
+
+    header->cu_end = p + header->unit_length;
+
+    header->version = *(uint16_t *)p;
+    p += sizeof(uint16_t);
+    if (header->version > 4) return -1;
+
+    header->header_length = header->format == 4 ? *(uint32_t *)p : *(uint64_t *)p;
+    p += header->format;
+    header->cu_start = p + header->header_length;
+
+    header->minimum_instruction_length = *(uint8_t *)p++;
+
+    if (header->version >= 4) {
+        /* maximum_operations_per_instruction = *(uint8_t *)p; */
+        if (*p != 1) return -1; /* For non-VLIW architectures, this field is 1 */
+        p++;
+    }
+
+    header->default_is_stmt = *(uint8_t *)p++;
+    header->line_base = *(int8_t *)p++;
+    header->line_range = *(uint8_t *)p++;
+    header->opcode_base = *(uint8_t *)p++;
+    /* header->standard_opcode_lengths = (uint8_t *)p - 1; */
+    p += header->opcode_base - 1;
+
+    header->include_directories = p;
+
+    /* temporary measure for compress-debug-sections */
+    if (p >= header->cu_end) return -1;
+
+    /* skip include directories */
+    while (*p) {
+	p = memchr(p, '\0', header->cu_end - p);
+	if (!p) return -1;
+	p++;
+    }
+    p++;
+
+    header->filenames = p;
+
+    *pp = header->cu_start;
+
+    return 0;
+}
+
+static int
+parse_debug_line_cu(int num_traces, void **traces, char **debug_line,
+		obj_info_t *obj, line_info_t *lines, int offset)
+{
+    const char *p = (const char *)*debug_line;
+    struct LineNumberProgramHeader header;
+
+    /* The registers. */
+    unsigned long addr = 0;
+    unsigned int file = 1;
+    unsigned int line = 1;
+    /* unsigned int column = 0; */
+    int is_stmt;
+    /* int basic_block = 0; */
+    /* int end_sequence = 0; */
+    /* int prologue_end = 0; */
+    /* int epilogue_begin = 0; */
+    /* unsigned int isa = 0; */
+
+    if (parse_debug_line_header(&p, &header))
+        return -1;
+    is_stmt = header.default_is_stmt;
+
+#define FILL_LINE()						    \
+    do {							    \
+	fill_line(num_traces, traces, addr, file, line,		    \
+                  (char *)header.include_directories,               \
+                  (char *)header.filenames,                         \
+		  obj, lines, offset);				    \
+	/*basic_block = prologue_end = epilogue_begin = 0;*/	    \
+    } while (0)
+
+    while (p < header.cu_end) {
+	unsigned long a;
+	unsigned char op = *p++;
+	switch (op) {
+	case DW_LNS_copy:
+	    FILL_LINE();
+	    break;
+	case DW_LNS_advance_pc:
+	    a = uleb128((char **)&p);
+	    addr += a;
+	    break;
+	case DW_LNS_advance_line: {
+	    long a = sleb128((char **)&p);
+	    line += a;
+	    break;
+	}
+	case DW_LNS_set_file:
+	    file = (unsigned int)uleb128((char **)&p);
+	    break;
+	case DW_LNS_set_column:
+	    /*column = (unsigned int)*/(void)uleb128((char **)&p);
+	    break;
+	case DW_LNS_negate_stmt:
+	    is_stmt = !is_stmt;
+	    break;
+	case DW_LNS_set_basic_block:
+	    /*basic_block = 1; */
+	    break;
+	case DW_LNS_const_add_pc:
+	    a = ((255UL - header.opcode_base) / header.line_range) *
+		header.minimum_instruction_length;
+	    addr += a;
+	    break;
+	case DW_LNS_fixed_advance_pc:
+	    a = *(unsigned char *)p++;
+	    addr += a;
+	    break;
+	case DW_LNS_set_prologue_end:
+	    /* prologue_end = 1; */
+	    break;
+	case DW_LNS_set_epilogue_begin:
+	    /* epilogue_begin = 1; */
+	    break;
+	case DW_LNS_set_isa:
+	    /* isa = (unsigned int)*/(void)uleb128((char **)&p);
+	    break;
+	case 0:
+	    a = *(unsigned char *)p++;
+	    op = *p++;
+	    switch (op) {
+	    case DW_LNE_end_sequence:
+		/* end_sequence = 1; */
+		FILL_LINE();
+		addr = 0;
+		file = 1;
+		line = 1;
+		/* column = 0; */
+		is_stmt = header.default_is_stmt;
+		/* end_sequence = 0; */
+		/* isa = 0; */
+		break;
+	    case DW_LNE_set_address:
+		addr = *(unsigned long *)p;
+		p += sizeof(unsigned long);
+		break;
+	    case DW_LNE_define_file:
+		kprintf("Unsupported operation in %s\n",
+			binary_filename);
+		break;
+	    case DW_LNE_set_discriminator:
+		/* TODO:currently ignore */
+		uleb128((char **)&p);
+		break;
+	    default:
+		kprintf("Unknown extended opcode: %d in %s\n",
+			op, binary_filename);
+	    }
+	    break;
+	default: {
+            uint8_t adjusted_opcode = op - header.opcode_base;
+            uint8_t operation_advance = adjusted_opcode / header.line_range;
+            /* NOTE: this code doesn't support VLIW */
+            addr += operation_advance * header.minimum_instruction_length;
+            line += header.line_base + (adjusted_opcode % header.line_range);
+	    FILL_LINE();
+	}
+	}
+    }
+    *debug_line = (char *)p;
+    return 0;
+}
+
+static int
+parse_debug_line(int num_traces, void **traces,
+		 char *debug_line, unsigned long size,
+		 obj_info_t *obj, line_info_t *lines, int offset)
+{
+    char *debug_line_end = debug_line + size;
+    while (debug_line < debug_line_end) {
+	if (parse_debug_line_cu(num_traces, traces, &debug_line, obj, lines, offset))
+	    return -1;
+    }
+    if (debug_line != debug_line_end) {
+	kprintf("Unexpected size of .debug_line in %s\n",
+		binary_filename);
+    }
+    return 0;
+}
+
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+	   obj_info_t **objp, line_info_t *lines, int offset);
+
+static void
+append_obj(obj_info_t **objp)
+{
+    obj_info_t *newobj = calloc(1, sizeof(obj_info_t));
+    if (*objp) (*objp)->next = newobj;
+    *objp = newobj;
+}
+
+#ifdef USE_ELF
+static void
+follow_debuglink(const char *debuglink, int num_traces, void **traces,
+		 obj_info_t **objp, line_info_t *lines, int offset)
+{
+    /* Ideally we should check 4 paths to follow gnu_debuglink,
+       but we handle only one case for now as this format is used
+       by some linux distributions. See GDB's info for detail. */
+    static const char global_debug_dir[] = "/usr/lib/debug";
+    const size_t global_debug_dir_len = sizeof(global_debug_dir) - 1;
+    char *p;
+    obj_info_t *o1 = *objp, *o2;
+    size_t len;
+
+    p = strrchr(binary_filename, '/');
+    if (!p) {
+	return;
+    }
+    p[1] = '\0';
+
+    len = strlen(binary_filename);
+    if (len >= PATH_MAX - global_debug_dir_len)
+	len = PATH_MAX - global_debug_dir_len - 1;
+    memmove(binary_filename + global_debug_dir_len, binary_filename, len);
+    memcpy(binary_filename, global_debug_dir, global_debug_dir_len);
+    len += global_debug_dir_len;
+    strlcpy(binary_filename + len, debuglink, PATH_MAX - len);
+
+    append_obj(objp);
+    o2 = *objp;
+    o2->base_addr = o1->base_addr;
+    o2->path = o1->path;
+    fill_lines(num_traces, traces, 0, objp, lines, offset);
+}
+#endif
+
+enum
+{
+    DW_TAG_compile_unit = 0x11,
+    DW_TAG_inlined_subroutine = 0x1d,
+    DW_TAG_subprogram = 0x2e,
+};
+
+/* Attributes encodings */
+enum
+{
+    DW_AT_sibling = 0x01,
+    DW_AT_location = 0x02,
+    DW_AT_name = 0x03,
+    /* Reserved 0x04 */
+    /* Reserved 0x05 */
+    /* Reserved 0x06 */
+    /* Reserved 0x07 */
+    /* Reserved 0x08 */
+    DW_AT_ordering = 0x09,
+    /* Reserved 0x0a */
+    DW_AT_byte_size = 0x0b,
+    /* Reserved 0x0c */
+    DW_AT_bit_size = 0x0d,
+    /* Reserved 0x0e */
+    /* Reserved 0x0f */
+    DW_AT_stmt_list = 0x10,
+    DW_AT_low_pc = 0x11,
+    DW_AT_high_pc = 0x12,
+    DW_AT_language = 0x13,
+    /* Reserved 0x14 */
+    DW_AT_discr = 0x15,
+    DW_AT_discr_value = 0x16,
+    DW_AT_visibility = 0x17,
+    DW_AT_import = 0x18,
+    DW_AT_string_length = 0x19,
+    DW_AT_common_reference = 0x1a,
+    DW_AT_comp_dir = 0x1b,
+    DW_AT_const_value = 0x1c,
+    DW_AT_containing_type = 0x1d,
+    DW_AT_default_value = 0x1e,
+    /* Reserved 0x1f */
+    DW_AT_inline = 0x20,
+    DW_AT_is_optional = 0x21,
+    DW_AT_lower_bound = 0x22,
+    /* Reserved 0x23 */
+    /* Reserved 0x24 */
+    DW_AT_producer = 0x25,
+    /* Reserved 0x26 */
+    DW_AT_prototyped = 0x27,
+    /* Reserved 0x28 */
+    /* Reserved 0x29 */
+    DW_AT_return_addr = 0x2a,
+    /* Reserved 0x2b */
+    DW_AT_start_scope = 0x2c,
+    /* Reserved 0x2d */
+    DW_AT_bit_stride = 0x2e,
+    DW_AT_upper_bound = 0x2f,
+    /* Reserved 0x30 */
+    DW_AT_abstract_origin = 0x31,
+    DW_AT_accessibility = 0x32,
+    DW_AT_address_class = 0x33,
+    DW_AT_artificial = 0x34,
+    DW_AT_base_types = 0x35,
+    DW_AT_calling_convention = 0x36,
+    DW_AT_count = 0x37,
+    DW_AT_data_member_location = 0x38,
+    DW_AT_decl_column = 0x39,
+    DW_AT_decl_file = 0x3a,
+    DW_AT_decl_line = 0x3b,
+    DW_AT_declaration = 0x3c,
+    DW_AT_discr_list = 0x3d,
+    DW_AT_encoding = 0x3e,
+    DW_AT_external = 0x3f,
+    DW_AT_frame_base = 0x40,
+    DW_AT_friend = 0x41,
+    DW_AT_identifier_case = 0x42,
+    /* Reserved 0x43 */
+    DW_AT_namelist_item = 0x44,
+    DW_AT_priority = 0x45,
+    DW_AT_segment = 0x46,
+    DW_AT_specification = 0x47,
+    DW_AT_static_link = 0x48,
+    DW_AT_type = 0x49,
+    DW_AT_use_location = 0x4a,
+    DW_AT_variable_parameter = 0x4b,
+    DW_AT_virtuality = 0x4c,
+    DW_AT_vtable_elem_location = 0x4d,
+    DW_AT_allocated = 0x4e,
+    DW_AT_associated = 0x4f,
+    DW_AT_data_location = 0x50,
+    DW_AT_byte_stride = 0x51,
+    DW_AT_entry_pc = 0x52,
+    DW_AT_use_UTF8 = 0x53,
+    DW_AT_extension = 0x54,
+    DW_AT_ranges = 0x55,
+    DW_AT_trampoline = 0x56,
+    DW_AT_call_column = 0x57,
+    DW_AT_call_file = 0x58,
+    DW_AT_call_line = 0x59,
+    DW_AT_description = 0x5a,
+    DW_AT_binary_scale = 0x5b,
+    DW_AT_decimal_scale = 0x5c,
+    DW_AT_small = 0x5d,
+    DW_AT_decimal_sign = 0x5e,
+    DW_AT_digit_count = 0x5f,
+    DW_AT_picture_string = 0x60,
+    DW_AT_mutable = 0x61,
+    DW_AT_threads_scaled = 0x62,
+    DW_AT_explicit = 0x63,
+    DW_AT_object_pointer = 0x64,
+    DW_AT_endianity = 0x65,
+    DW_AT_elemental = 0x66,
+    DW_AT_pure = 0x67,
+    DW_AT_recursive = 0x68,
+    DW_AT_signature = 0x69,
+    DW_AT_main_subprogram = 0x6a,
+    DW_AT_data_bit_offset = 0x6b,
+    DW_AT_const_expr = 0x6c,
+    DW_AT_enum_class = 0x6d,
+    DW_AT_linkage_name = 0x6e,
+    DW_AT_string_length_bit_size = 0x6f,
+    DW_AT_string_length_byte_size = 0x70,
+    DW_AT_rank = 0x71,
+    DW_AT_str_offsets_base = 0x72,
+    DW_AT_addr_base = 0x73,
+    DW_AT_rnglists_base = 0x74,
+    /* Reserved 0x75 */
+    DW_AT_dwo_name = 0x76,
+    DW_AT_reference = 0x77,
+    DW_AT_rvalue_reference = 0x78,
+    DW_AT_macros = 0x79,
+    DW_AT_call_all_calls = 0x7a,
+    DW_AT_call_all_source_calls = 0x7b,
+    DW_AT_call_all_tail_calls = 0x7c,
+    DW_AT_call_return_pc = 0x7d,
+    DW_AT_call_value = 0x7e,
+    DW_AT_call_origin = 0x7f,
+    DW_AT_call_parameter = 0x80,
+    DW_AT_call_pc = 0x81,
+    DW_AT_call_tail_call = 0x82,
+    DW_AT_call_target = 0x83,
+    DW_AT_call_target_clobbered = 0x84,
+    DW_AT_call_data_location = 0x85,
+    DW_AT_call_data_value = 0x86,
+    DW_AT_noreturn = 0x87,
+    DW_AT_alignment = 0x88,
+    DW_AT_export_symbols = 0x89,
+    DW_AT_deleted = 0x8a,
+    DW_AT_defaulted = 0x8b,
+    DW_AT_loclists_base = 0x8c,
+    DW_AT_lo_user = 0x2000,
+    DW_AT_hi_user = 0x3fff
+};
+
+/* Attribute form encodings */
+enum
+{
+    DW_FORM_addr = 0x01,
+    /* Reserved 0x02 */
+    DW_FORM_block2 = 0x03,
+    DW_FORM_block4 = 0x04,
+    DW_FORM_data2 = 0x05,
+    DW_FORM_data4 = 0x06,
+    DW_FORM_data8 = 0x07,
+    DW_FORM_string = 0x08,
+    DW_FORM_block = 0x09,
+    DW_FORM_block1 = 0x0a,
+    DW_FORM_data1 = 0x0b,
+    DW_FORM_flag = 0x0c,
+    DW_FORM_sdata = 0x0d,
+    DW_FORM_strp = 0x0e,
+    DW_FORM_udata = 0x0f,
+    DW_FORM_ref_addr = 0x10,
+    DW_FORM_ref1 = 0x11,
+    DW_FORM_ref2 = 0x12,
+    DW_FORM_ref4 = 0x13,
+    DW_FORM_ref8 = 0x14,
+    DW_FORM_ref_udata = 0x15,
+    DW_FORM_indirect = 0x16,
+    DW_FORM_sec_offset = 0x17,
+    DW_FORM_exprloc = 0x18,
+    DW_FORM_flag_present = 0x19,
+    DW_FORM_strx = 0x1a,
+    DW_FORM_addrx = 0x1b,
+    DW_FORM_ref_sup4 = 0x1c,
+    DW_FORM_strp_sup = 0x1d,
+    DW_FORM_data16 = 0x1e,
+    DW_FORM_line_strp = 0x1f,
+    DW_FORM_ref_sig8 = 0x20,
+    DW_FORM_implicit_const = 0x21,
+    DW_FORM_loclistx = 0x22,
+    DW_FORM_rnglistx = 0x23,
+    DW_FORM_ref_sup8 = 0x24,
+    DW_FORM_strx1 = 0x25,
+    DW_FORM_strx2 = 0x26,
+    DW_FORM_strx3 = 0x27,
+    DW_FORM_strx4 = 0x28,
+    DW_FORM_addrx1 = 0x29,
+    DW_FORM_addrx2 = 0x2a,
+    DW_FORM_addrx3 = 0x2b,
+    DW_FORM_addrx4 = 0x2c
+};
+
+enum {
+    VAL_none = 0,
+    VAL_cstr = 1,
+    VAL_data = 2,
+    VAL_uint = 3,
+    VAL_int = 4
+};
+
+# define ABBREV_TABLE_SIZE 256
+typedef struct {
+    obj_info_t *obj;
+    char *file;
+    char *current_cu;
+    uint64_t current_low_pc;
+    char *debug_line_cu_end;
+    char *debug_line_files;
+    char *debug_line_directories;
+    char *p;
+    char *cu_end;
+    char *pend;
+    char *q0;
+    char *q;
+    int format; // 4 or 8
+    uint8_t address_size;
+    int level;
+    char *abbrev_table[ABBREV_TABLE_SIZE];
+} DebugInfoReader;
+
+typedef struct {
+    ptrdiff_t pos;
+    int tag;
+    int has_children;
+} DIE;
+
+typedef struct {
+    union {
+        char *ptr;
+        uint64_t uint64;
+        int64_t int64;
+    } as;
+    uint64_t off;
+    uint64_t at;
+    uint64_t form;
+    size_t size;
+    int type;
+} DebugInfoValue;
+
+/* TODO: Big Endian */
+#define MERGE_2INTS(a,b,sz) (((uint64_t)(b)<<sz)|(a))
+
+static uint16_t
+get_uint16(const uint8_t *p)
+{
+    return (uint16_t)MERGE_2INTS(p[0],p[1],8);
+}
+
+static uint32_t
+get_uint32(const uint8_t *p)
+{
+    return (uint32_t)MERGE_2INTS(get_uint16(p),get_uint16(p+2),16);
+}
+
+static uint64_t
+get_uint64(const uint8_t *p)
+{
+    return MERGE_2INTS(get_uint32(p),get_uint32(p+4),32);
+}
+
+static uint8_t
+read_uint8(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 1);
+    return *p;
+}
+
+static uint16_t
+read_uint16(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 2);
+    return get_uint16(p);
+}
+
+static uint32_t
+read_uint24(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 3);
+    return (*p << 16) | get_uint16(p+1);
+}
+
+static uint32_t
+read_uint32(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 4);
+    return get_uint32(p);
+}
+
+static uint64_t
+read_uint64(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + 8);
+    return get_uint64(p);
+}
+
+static uintptr_t
+read_uintptr(char **ptr)
+{
+    const unsigned char *p = (const unsigned char *)*ptr;
+    *ptr = (char *)(p + SIZEOF_VOIDP);
+#if SIZEOF_VOIDP == 8
+    return get_uint64(p);
+#else
+    return get_uint32(p);
+#endif
+}
+
+static uint64_t
+read_uint(DebugInfoReader *reader)
+{
+    if (reader->format == 4) {
+        return read_uint32(&reader->p);
+    } else { /* 64 bit */
+        return read_uint64(&reader->p);
+    }
+}
+
+static uint64_t
+read_uleb128(DebugInfoReader *reader)
+{
+    return uleb128(&reader->p);
+}
+
+static int64_t
+read_sleb128(DebugInfoReader *reader)
+{
+    return sleb128(&reader->p);
+}
+
+static void
+debug_info_reader_init(DebugInfoReader *reader, obj_info_t *obj)
+{
+    reader->file = obj->mapped;
+    reader->obj = obj;
+    reader->p = obj->debug_info.ptr;
+    reader->pend = obj->debug_info.ptr + obj->debug_info.size;
+    reader->debug_line_cu_end = obj->debug_line.ptr;
+}
+
+static void
+di_read_debug_abbrev_cu(DebugInfoReader *reader)
+{
+    uint64_t prev = 0;
+    char *p = reader->q0;
+    for (;;) {
+        uint64_t abbrev_number = uleb128(&p);
+        if (abbrev_number <= prev) break;
+        if (abbrev_number < ABBREV_TABLE_SIZE) {
+            reader->abbrev_table[abbrev_number] = p;
+        }
+        prev = abbrev_number;
+        uleb128(&p); /* tag */
+        p++; /* has_children */
+        /* skip content */
+        for (;;) {
+            uint64_t at = uleb128(&p);
+            uint64_t form = uleb128(&p);
+            if (!at && !form) break;
+        }
+    }
+}
+
+static int
+di_read_debug_line_cu(DebugInfoReader *reader)
+{
+    const char *p;
+    struct LineNumberProgramHeader header;
+
+    p = (const char *)reader->debug_line_cu_end;
+    if (parse_debug_line_header(&p, &header))
+        return -1;
+
+    reader->debug_line_cu_end = (char *)header.cu_end;
+    reader->debug_line_directories = (char *)header.include_directories;
+    reader->debug_line_files = (char *)header.filenames;
+
+    return 0;
+}
+
+static void
+set_uint_value(DebugInfoValue *v, uint64_t n)
+{
+    v->as.uint64 = n;
+    v->type = VAL_uint;
+}
+
+static void
+set_int_value(DebugInfoValue *v, int64_t n)
+{
+    v->as.int64 = n;
+    v->type = VAL_int;
+}
+
+static void
+set_cstr_value(DebugInfoValue *v, char *s)
+{
+    v->as.ptr = s;
+    v->off = 0;
+    v->type = VAL_cstr;
+}
+
+static void
+set_cstrp_value(DebugInfoValue *v, char *s, uint64_t off)
+{
+    v->as.ptr = s;
+    v->off = off;
+    v->type = VAL_cstr;
+}
+
+static void
+set_data_value(DebugInfoValue *v, char *s)
+{
+    v->as.ptr = s;
+    v->type = VAL_data;
+}
+
+static const char *
+get_cstr_value(DebugInfoValue *v)
+{
+    if (v->as.ptr) {
+        return v->as.ptr + v->off;
+    } else {
+        return NULL;
+    }
+}
+
+static void
+debug_info_reader_read_value(DebugInfoReader *reader, uint64_t form, DebugInfoValue *v)
+{
+    switch (form) {
+      case DW_FORM_addr:
+        if (reader->address_size == 4) {
+            set_uint_value(v, read_uint32(&reader->p));
+        } else if (reader->address_size == 8) {
+            set_uint_value(v, read_uint64(&reader->p));
+        } else {
+            fprintf(stderr,"unknown address_size:%d", reader->address_size);
+            abort();
+        }
+        break;
+      case DW_FORM_block2:
+        v->size = read_uint16(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_block4:
+        v->size = read_uint32(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_data2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_data4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_data8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_string:
+        v->size = strlen(reader->p);
+        set_cstr_value(v, reader->p);
+        reader->p += v->size + 1;
+        break;
+      case DW_FORM_block:
+        v->size = uleb128(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_block1:
+        v->size = read_uint8(&reader->p);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_data1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_flag:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_sdata:
+        set_int_value(v, read_sleb128(reader));
+        break;
+      case DW_FORM_strp:
+        set_cstrp_value(v, reader->obj->debug_str.ptr, read_uint(reader));
+        break;
+      case DW_FORM_udata:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_ref_addr:
+        if (reader->address_size == 4) {
+            set_uint_value(v, read_uint32(&reader->p));
+        } else if (reader->address_size == 8) {
+            set_uint_value(v, read_uint64(&reader->p));
+        } else {
+            fprintf(stderr,"unknown address_size:%d", reader->address_size);
+            abort();
+        }
+        break;
+      case DW_FORM_ref1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_ref2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_ref4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_ref8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_ref_udata:
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_indirect:
+        /* TODO: read the referred value */
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_sec_offset:
+        set_uint_value(v, read_uint(reader)); /* offset */
+        /* addrptr: debug_addr */
+        /* lineptr: debug_line */
+        /* loclist: debug_loclists */
+        /* loclistptr: debug_loclists */
+        /* macptr: debug_macro */
+        /* rnglist: debug_rnglists */
+        /* rnglistptr: debug_rnglists */
+        /* stroffsetsptr: debug_str_offsets */
+        break;
+      case DW_FORM_exprloc:
+        v->size = (size_t)read_uleb128(reader);
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_flag_present:
+        set_uint_value(v, 1);
+        break;
+      case DW_FORM_strx:
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_addrx:
+        /* TODO: read .debug_addr */
+        set_uint_value(v, uleb128(&reader->p));
+        break;
+      case DW_FORM_ref_sup4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_strp_sup:
+        set_uint_value(v, read_uint(reader));
+        /* *p = reader->sup_file + reader->sup_str->sh_offset + ret; */
+        break;
+      case DW_FORM_data16:
+        v->size = 16;
+        set_data_value(v, reader->p);
+        reader->p += v->size;
+        break;
+      case DW_FORM_line_strp:
+        set_uint_value(v, read_uint(reader));
+        /* *p = reader->file + reader->line->sh_offset + ret; */
+        break;
+      case DW_FORM_ref_sig8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_implicit_const:
+        set_int_value(v, sleb128(&reader->q));
+        break;
+      case DW_FORM_loclistx:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_rnglistx:
+        set_uint_value(v, read_uleb128(reader));
+        break;
+      case DW_FORM_ref_sup8:
+        set_uint_value(v, read_uint64(&reader->p));
+        break;
+      case DW_FORM_strx1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_strx2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_strx3:
+        set_uint_value(v, read_uint24(&reader->p));
+        break;
+      case DW_FORM_strx4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case DW_FORM_addrx1:
+        set_uint_value(v, read_uint8(&reader->p));
+        break;
+      case DW_FORM_addrx2:
+        set_uint_value(v, read_uint16(&reader->p));
+        break;
+      case DW_FORM_addrx3:
+        set_uint_value(v, read_uint24(&reader->p));
+        break;
+      case DW_FORM_addrx4:
+        set_uint_value(v, read_uint32(&reader->p));
+        break;
+      case 0:
+        goto fail;
+        break;
+    }
+    return;
+
+  fail:
+    fprintf(stderr, "%d: unsupported form: %#"PRIx64"\n", __LINE__, form);
+    exit(1);
+}
+
+/* find abbrev in current compilation unit */
+static char *
+di_find_abbrev(DebugInfoReader *reader, uint64_t abbrev_number)
+{
+    char *p;
+    if (abbrev_number < ABBREV_TABLE_SIZE) {
+        return reader->abbrev_table[abbrev_number];
+    }
+    p = reader->abbrev_table[ABBREV_TABLE_SIZE-1];
+    /* skip 255th record */
+    uleb128(&p); /* tag */
+    p++; /* has_children */
+    /* skip content */
+    for (;;) {
+        uint64_t at = uleb128(&p);
+        uint64_t form = uleb128(&p);
+        if (!at && !form) break;
+    }
+    for (uint64_t n = uleb128(&p); abbrev_number != n; n = uleb128(&p)) {
+        if (n == 0) {
+            fprintf(stderr,"%d: Abbrev Number %"PRId64" not found\n",__LINE__, abbrev_number);
+            exit(1);
+        }
+        uleb128(&p); /* tag */
+        p++; /* has_children */
+        /* skip content */
+        for (;;) {
+            uint64_t at = uleb128(&p);
+            uint64_t form = uleb128(&p);
+            if (!at && !form) break;
+        }
+    }
+    return p;
+}
+
+#if 0
+static void
+hexdump0(const unsigned char *p, size_t n)
+{
+    size_t i;
+    fprintf(stderr, "     0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F\n");
+    for (i=0; i < n; i++){
+        switch (i & 15) {
+          case 0:
+            fprintf(stderr, "%02zd: %02X ", i/16, p[i]);
+            break;
+          case 15:
+            fprintf(stderr, "%02X\n", p[i]);
+            break;
+          default:
+            fprintf(stderr, "%02X ", p[i]);
+            break;
+        }
+    }
+    if ((i & 15) != 15) {
+        fprintf(stderr, "\n");
+    }
+}
+#define hexdump(p,n) hexdump0((const unsigned char *)p, n)
+
+static void
+div_inspect(DebugInfoValue *v)
+{
+    switch (v->type) {
+      case VAL_uint:
+        fprintf(stderr,"%d: type:%d size:%zx v:%lx\n",__LINE__,v->type,v->size,v->as.uint64);
+        break;
+      case VAL_int:
+        fprintf(stderr,"%d: type:%d size:%zx v:%ld\n",__LINE__,v->type,v->size,(int64_t)v->as.uint64);
+        break;
+      case VAL_cstr:
+        fprintf(stderr,"%d: type:%d size:%zx v:'%s'\n",__LINE__,v->type,v->size,v->as.ptr);
+        break;
+      case VAL_data:
+        fprintf(stderr,"%d: type:%d size:%zx v:\n",__LINE__,v->type,v->size);
+        hexdump(v->as.ptr, 16);
+        break;
+    }
+}
+#endif
+
+static DIE *
+di_read_die(DebugInfoReader *reader, DIE *die)
+{
+    uint64_t abbrev_number = uleb128(&reader->p);
+    if (abbrev_number == 0) {
+        reader->level--;
+        return NULL;
+    }
+
+    reader->q = di_find_abbrev(reader, abbrev_number);
+
+    die->pos = reader->p - reader->obj->debug_info.ptr - 1;
+    die->tag = (int)uleb128(&reader->q); /* tag */
+    die->has_children = *reader->q++; /* has_children */
+    if (die->has_children) {
+        reader->level++;
+    }
+    return die;
+}
+
+static DebugInfoValue *
+di_read_record(DebugInfoReader *reader, DebugInfoValue *vp)
+{
+    uint64_t at = uleb128(&reader->q);
+    uint64_t form = uleb128(&reader->q);
+    if (!at || !form) return NULL;
+    vp->at = at;
+    vp->form = form;
+    debug_info_reader_read_value(reader, form, vp);
+    return vp;
+}
+
+static void
+di_skip_records(DebugInfoReader *reader)
+{
+    for (;;) {
+        DebugInfoValue v = {{}};
+        uint64_t at = uleb128(&reader->q);
+        uint64_t form = uleb128(&reader->q);
+        if (!at || !form) return;
+        debug_info_reader_read_value(reader, form, &v);
+    }
+}
+
+typedef struct {
+    uint64_t low_pc;
+    uint64_t high_pc;
+    uint64_t ranges;
+    bool low_pc_set;
+    bool high_pc_set;
+    bool ranges_set;
+} ranges_t;
+
+static void
+ranges_set(ranges_t *ptr, DebugInfoValue *v)
+{
+    switch (v->at) {
+      case DW_AT_low_pc:
+        ptr->low_pc = v->as.uint64;
+        ptr->low_pc_set = true;
+        break;
+      case DW_AT_high_pc:
+        if (v->form == DW_FORM_addr) {
+            ptr->high_pc = v->as.uint64;
+        }
+        else {
+            ptr->high_pc = ptr->low_pc + v->as.uint64;
+        }
+        ptr->high_pc_set = true;
+        break;
+      case DW_AT_ranges:
+        ptr->ranges = v->as.uint64;
+        ptr->ranges_set = true;
+        break;
+    }
+}
+
+static uintptr_t
+ranges_include(DebugInfoReader *reader, ranges_t *ptr, uint64_t addr)
+{
+    if (ptr->high_pc_set) {
+        if (ptr->ranges_set || !ptr->low_pc_set) {
+            exit(1);
+        }
+        if (ptr->low_pc <= addr && addr <= ptr->high_pc) {
+            return (uintptr_t)ptr->low_pc;
+        }
+    }
+    else if (ptr->ranges_set) {
+        /* TODO: support base address selection entry */
+        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        uint64_t base = ptr->low_pc_set ? ptr->low_pc : reader->current_low_pc;
+        for (;;) {
+            uintptr_t from = read_uintptr(&p);
+            uintptr_t to = read_uintptr(&p);
+            if (!from && !to) break;
+            if (from == UINTPTR_MAX) {
+                /* base address selection entry */
+                base = to;
+            }
+            else if (base + from <= addr && addr < base + to) {
+                return from;
+            }
+        }
+    }
+    else if (ptr->low_pc_set) {
+        if (ptr->low_pc == addr) {
+            return (uintptr_t)ptr->low_pc;
+        }
+    }
+    return false;
+}
+
+#if 0
+static void
+ranges_inspect(DebugInfoReader *reader, ranges_t *ptr)
+{
+    if (ptr->high_pc_set) {
+        if (ptr->ranges_set || !ptr->low_pc_set) {
+            fprintf(stderr,"low_pc_set:%d high_pc_set:%d ranges_set:%d\n",ptr->low_pc_set,ptr->high_pc_set,ptr->ranges_set);
+            exit(1);
+        }
+        fprintf(stderr,"low_pc:%"PRIx64" high_pc:%"PRIx64"\n",ptr->low_pc,ptr->high_pc);
+    }
+    else if (ptr->ranges_set) {
+        char *p = reader->obj->debug_ranges.ptr + ptr->ranges;
+        fprintf(stderr,"low_pc:%"PRIx64" ranges:%"PRIx64" %lx ",ptr->low_pc,ptr->ranges, p-reader->obj->mapped);
+        for (;;) {
+            uintptr_t from = read_uintptr(&p);
+            uintptr_t to = read_uintptr(&p);
+            if (!from && !to) break;
+            fprintf(stderr,"%"PRIx64"-%"PRIx64" ",ptr->low_pc+from,ptr->low_pc+to);
+        }
+        fprintf(stderr,"\n");
+    }
+    else if (ptr->low_pc_set) {
+        fprintf(stderr,"low_pc:%"PRIx64"\n",ptr->low_pc);
+    }
+    else {
+        fprintf(stderr,"empty\n");
+    }
+}
+#endif
+
+static int
+di_read_cu(DebugInfoReader *reader)
+{
+    uint64_t unit_length;
+    uint16_t version;
+    uint64_t debug_abbrev_offset;
+    reader->format = 4;
+    reader->current_cu = reader->p;
+    unit_length = read_uint32(&reader->p);
+    if (unit_length == 0xffffffff) {
+        unit_length = read_uint64(&reader->p);
+        reader->format = 8;
+    }
+    reader->cu_end = reader->p + unit_length;
+    version = read_uint16(&reader->p);
+    if (version > 5) {
+        return -1;
+    }
+    else if (version == 5) {
+        /* unit_type = */ read_uint8(&reader->p);
+        reader->address_size = read_uint8(&reader->p);
+        debug_abbrev_offset = read_uint(reader);
+    }
+    else {
+        debug_abbrev_offset = read_uint(reader);
+        reader->address_size = read_uint8(&reader->p);
+    }
+    reader->q0 = reader->obj->debug_abbrev.ptr + debug_abbrev_offset;
+
+    reader->level = 0;
+    di_read_debug_abbrev_cu(reader);
+    if (di_read_debug_line_cu(reader)) return -1;
+
+#if defined(__GNUC__) && !defined(__clang__) && !defined(__INTEL_COMPILER_BUILD_DATE)
+    /* Though DWARF specifies "the applicable base address defaults to the base
+       address of the compilation unit", but GCC seems to use zero as default */
+#else
+    do {
+        DIE die;
+
+        if (!di_read_die(reader, &die)) continue;
+
+        if (die.tag != DW_TAG_compile_unit) {
+            di_skip_records(reader);
+            break;
+        }
+
+        /* enumerate abbrev */
+        for (;;) {
+            DebugInfoValue v = {{}};
+            if (!di_read_record(reader, &v)) break;
+            switch (v.at) {
+              case DW_AT_low_pc:
+                reader->current_low_pc = v.as.uint64;
+                break;
+            }
+        }
+    } while (0);
+#endif
+    return 0;
+}
+
+static void
+read_abstract_origin(DebugInfoReader *reader, uint64_t abstract_origin, line_info_t *line)
+{
+    char *p = reader->p;
+    char *q = reader->q;
+    int level = reader->level;
+    DIE die;
+
+    reader->p = reader->current_cu + abstract_origin;
+    if (!di_read_die(reader, &die)) goto finish;
+
+    /* enumerate abbrev */
+    for (;;) {
+        DebugInfoValue v = {{}};
+        if (!di_read_record(reader, &v)) break;
+        switch (v.at) {
+          case DW_AT_name:
+            line->sname = get_cstr_value(&v);
+            break;
+        }
+    }
+
+  finish:
+    reader->p = p;
+    reader->q = q;
+    reader->level = level;
+}
+
+static void
+debug_info_read(DebugInfoReader *reader, int num_traces, void **traces,
+         line_info_t *lines, int offset) {
+    while (reader->p < reader->cu_end) {
+        DIE die;
+        ranges_t ranges = {};
+        line_info_t line = {};
+
+        if (!di_read_die(reader, &die)) continue;
+        /* fprintf(stderr,"%d:%tx: <%d>\n",__LINE__,die.pos,reader->level,die.tag); */
+
+        if (die.tag != DW_TAG_subprogram && die.tag != DW_TAG_inlined_subroutine) {
+          skip_die:
+            di_skip_records(reader);
+            continue;
+        }
+
+        /* enumerate abbrev */
+        for (;;) {
+            DebugInfoValue v = {{}};
+            /* ptrdiff_t pos = reader->p - reader->p0; */
+            if (!di_read_record(reader, &v)) break;
+            /* fprintf(stderr,"\n%d:%tx: AT:%lx FORM:%lx\n",__LINE__,pos,v.at,v.form); */
+            /* div_inspect(&v); */
+            switch (v.at) {
+              case DW_AT_name:
+                line.sname = get_cstr_value(&v);
+                break;
+              case DW_AT_call_file:
+                fill_filename((int)v.as.uint64, reader->debug_line_directories, reader->debug_line_files, &line, reader->obj);
+                break;
+              case DW_AT_call_line:
+                line.line = (int)v.as.uint64;
+                break;
+              case DW_AT_low_pc:
+              case DW_AT_high_pc:
+              case DW_AT_ranges:
+                ranges_set(&ranges, &v);
+                break;
+              case DW_AT_declaration:
+                goto skip_die;
+              case DW_AT_inline:
+                /* 1 or 3 */
+                break; /* goto skip_die; */
+              case DW_AT_abstract_origin:
+                read_abstract_origin(reader, v.as.uint64, &line);
+                break; /* goto skip_die; */
+            }
+        }
+        /* ranges_inspect(reader, &ranges); */
+        /* fprintf(stderr,"%d:%tx: %x ",__LINE__,diepos,die.tag); */
+        for (int i=offset; i < num_traces; i++) {
+            uintptr_t addr = (uintptr_t)traces[i];
+            uintptr_t offset = addr - reader->obj->base_addr + reader->obj->vmaddr;
+            uintptr_t saddr = ranges_include(reader, &ranges, offset);
+            if (saddr) {
+                /* fprintf(stderr, "%d:%tx: %d %lx->%lx %x %s: %s/%s %d %s %s %s\n",__LINE__,die.pos, i,addr,offset, die.tag,line.sname,line.dirname,line.filename,line.line,reader->obj->path,line.sname,lines[i].sname); */
+                if (lines[i].sname) {
+                    line_info_t *lp = malloc(sizeof(line_info_t));
+                    memcpy(lp, &lines[i], sizeof(line_info_t));
+                    lines[i].next = lp;
+                    lp->dirname = line.dirname;
+                    lp->filename = line.filename;
+                    lp->line = line.line;
+                    lp->saddr = 0;
+                }
+                lines[i].path = reader->obj->path;
+                lines[i].base_addr = line.base_addr;
+                lines[i].sname = line.sname;
+                lines[i].saddr = saddr + reader->obj->base_addr - reader->obj->vmaddr;
+            }
+        }
+    }
+}
+
+#ifdef USE_ELF
+static unsigned long
+uncompress_debug_section(ElfW(Shdr) *shdr, char *file, char **ptr)
+{
+    *ptr = NULL;
+#ifdef SUPPORT_COMPRESSED_DEBUG_LINE
+    ElfW(Chdr) *chdr = (ElfW(Chdr) *)(file + shdr->sh_offset);
+    unsigned long destsize = chdr->ch_size;
+    int ret = 0;
+
+    if (chdr->ch_type != ELFCOMPRESS_ZLIB) {
+	/* unsupported compression type */
+	return 0;
+    }
+
+    *ptr = malloc(destsize);
+    if (!*ptr) return 0;
+    ret = uncompress((Bytef *)*ptr, &destsize,
+	    (const Bytef*)chdr + sizeof(ElfW(Chdr)),
+            shdr->sh_size - sizeof(ElfW(Chdr)));
+    if (ret != Z_OK) goto fail;
+    return destsize;
+
+fail:
+    free(*ptr);
+    *ptr = NULL;
+#endif
+    return 0;
+}
+
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+	   obj_info_t **objp, line_info_t *lines, int offset)
+{
+    int i, j;
+    char *shstr;
+    ElfW(Ehdr) *ehdr;
+    ElfW(Shdr) *shdr, *shstr_shdr;
+    ElfW(Shdr) *gnu_debuglink_shdr = NULL;
+    int fd;
+    off_t filesize;
+    char *file;
+    ElfW(Shdr) *symtab_shdr = NULL, *strtab_shdr = NULL;
+    ElfW(Shdr) *dynsym_shdr = NULL, *dynstr_shdr = NULL;
+    obj_info_t *obj = *objp;
+    uintptr_t dladdr_fbase = 0;
+
+    fd = open(binary_filename, O_RDONLY);
+    if (fd < 0) {
+	goto fail;
+    }
+    filesize = lseek(fd, 0, SEEK_END);
+    if (filesize < 0) {
+	int e = errno;
+	close(fd);
+	kprintf("lseek: %s\n", strerror(e));
+	goto fail;
+    }
+#if SIZEOF_OFF_T > SIZEOF_SIZE_T
+    if (filesize > (off_t)SIZE_MAX) {
+	close(fd);
+	kprintf("Too large file %s\n", binary_filename);
+	goto fail;
+    }
+#endif
+    lseek(fd, 0, SEEK_SET);
+    /* async-signal unsafe */
+    file = (char *)mmap(NULL, (size_t)filesize, PROT_READ, MAP_SHARED, fd, 0);
+    if (file == MAP_FAILED) {
+	int e = errno;
+	close(fd);
+	kprintf("mmap: %s\n", strerror(e));
+	goto fail;
+    }
+    close(fd);
+
+    ehdr = (ElfW(Ehdr) *)file;
+    if (memcmp(ehdr->e_ident, "\177ELF", 4) != 0) {
+	/*
+	 * Huh? Maybe filename was overridden by setproctitle() and
+	 * it match non-elf file.
+	 */
+	goto fail;
+    }
+    obj->mapped = file;
+    obj->mapped_size = (size_t)filesize;
+
+    shdr = (ElfW(Shdr) *)(file + ehdr->e_shoff);
+
+    shstr_shdr = shdr + ehdr->e_shstrndx;
+    shstr = file + shstr_shdr->sh_offset;
+
+    for (i = 0; i < ehdr->e_shnum; i++) {
+        char *section_name = shstr + shdr[i].sh_name;
+	switch (shdr[i].sh_type) {
+	  case SHT_STRTAB:
+	    if (!strcmp(section_name, ".strtab")) {
+		strtab_shdr = shdr + i;
+	    }
+	    else if (!strcmp(section_name, ".dynstr")) {
+		dynstr_shdr = shdr + i;
+	    }
+	    break;
+	  case SHT_SYMTAB:
+	    /* if (!strcmp(section_name, ".symtab")) */
+	    symtab_shdr = shdr + i;
+	    break;
+	  case SHT_DYNSYM:
+	    /* if (!strcmp(section_name, ".dynsym")) */
+	    dynsym_shdr = shdr + i;
+	    break;
+	  case SHT_PROGBITS:
+	    if (!strcmp(section_name, ".gnu_debuglink")) {
+		gnu_debuglink_shdr = shdr + i;
+	    }
+            else {
+                const char *debug_section_names[] = {
+                    ".debug_abbrev",
+                    ".debug_info",
+                    ".debug_line",
+                    ".debug_ranges",
+                    ".debug_str"
+                };
+
+                for (j=0; j < DWARF_SECTION_COUNT; j++) {
+                    struct dwarf_section *s = obj_dwarf_section_at(obj, j);
+
+                    if (strcmp(section_name, debug_section_names[j]) != 0)
+                        continue;
+
+                    s->ptr = file + shdr[i].sh_offset;
+                    s->size = shdr[i].sh_size;
+                    s->flags = shdr[i].sh_flags;
+                    if (s->flags & SHF_COMPRESSED) {
+                        s->size = uncompress_debug_section(&shdr[i], file, &s->ptr);
+                        if (!s->size) goto fail;
+                    }
+                    break;
+                }
+            }
+	    break;
+	}
+    }
+
+    if (offset == -1) {
+	/* main executable */
+	offset = 0;
+	if (dynsym_shdr && dynstr_shdr) {
+	    char *strtab = file + dynstr_shdr->sh_offset;
+	    ElfW(Sym) *symtab = (ElfW(Sym) *)(file + dynsym_shdr->sh_offset);
+	    int symtab_count = (int)(dynsym_shdr->sh_size / sizeof(ElfW(Sym)));
+            void *handle = dlopen(NULL, RTLD_NOW|RTLD_LOCAL);
+            if (handle) {
+                for (j = 0; j < symtab_count; j++) {
+                    ElfW(Sym) *sym = &symtab[j];
+                    Dl_info info;
+                    void *s;
+                    if (ELF_ST_TYPE(sym->st_info) != STT_FUNC || sym->st_size == 0) continue;
+                    s = dlsym(handle, strtab + sym->st_name);
+                    if (s && dladdr(s, &info)) {
+                        obj->base_addr = dladdr_fbase;
+                        dladdr_fbase = (uintptr_t)info.dli_fbase;
+                        break;
+                    }
+                }
+                dlclose(handle);
+            }
+	    if (ehdr->e_type == ET_EXEC) {
+		obj->base_addr = 0;
+	    }
+	    else {
+		/* PIE (position-independent executable) */
+		obj->base_addr = dladdr_fbase;
+	    }
+	}
+    }
+
+    if (obj->debug_info.ptr && obj->debug_abbrev.ptr) {
+        DebugInfoReader reader;
+        debug_info_reader_init(&reader, obj);
+        i = 0;
+        while (reader.p < reader.pend) {
+            /* fprintf(stderr, "%d:%tx: CU[%d]\n", __LINE__, reader.p - reader.obj->debug_info.ptr, i++); */
+            if (di_read_cu(&reader)) goto use_symtab;
+            debug_info_read(&reader, num_traces, traces, lines, offset);
+        }
+    }
+    else {
+        /* This file doesn't have dwarf, use symtab or dynsym */
+use_symtab:
+        if (!symtab_shdr) {
+            /* This file doesn't have symtab, use dynsym instead */
+            symtab_shdr = dynsym_shdr;
+            strtab_shdr = dynstr_shdr;
+        }
+
+        if (symtab_shdr && strtab_shdr) {
+            char *strtab = file + strtab_shdr->sh_offset;
+            ElfW(Sym) *symtab = (ElfW(Sym) *)(file + symtab_shdr->sh_offset);
+            int symtab_count = (int)(symtab_shdr->sh_size / sizeof(ElfW(Sym)));
+            for (j = 0; j < symtab_count; j++) {
+                ElfW(Sym) *sym = &symtab[j];
+                uintptr_t saddr = (uintptr_t)sym->st_value + obj->base_addr;
+                if (ELF_ST_TYPE(sym->st_info) != STT_FUNC) continue;
+                for (i = offset; i < num_traces; i++) {
+                    uintptr_t d = (uintptr_t)traces[i] - saddr;
+                    if (lines[i].line > 0 || d > (uintptr_t)sym->st_size)
+                        continue;
+                    /* fill symbol name and addr from .symtab */
+                    if (!lines[i].sname) lines[i].sname = strtab + sym->st_name;
+                    lines[i].saddr = saddr;
+                    lines[i].path  = obj->path;
+                    lines[i].base_addr = obj->base_addr;
+                }
+            }
+        }
+    }
+
+    if (!obj->debug_line.ptr) {
+	/* This file doesn't have .debug_line section,
+	   let's check .gnu_debuglink section instead. */
+	if (gnu_debuglink_shdr && check_debuglink) {
+	    follow_debuglink(file + gnu_debuglink_shdr->sh_offset,
+			     num_traces, traces,
+			     objp, lines, offset);
+	}
+	goto finish;
+    }
+
+    if (parse_debug_line(num_traces, traces,
+            obj->debug_line.ptr,
+            obj->debug_line.size,
+            obj, lines, offset) == -1)
+        goto fail;
+
+finish:
+    return dladdr_fbase;
+fail:
+    return (uintptr_t)-1;
+}
+#else /* Mach-O */
+/* read file and fill lines */
+static uintptr_t
+fill_lines(int num_traces, void **traces, int check_debuglink,
+        obj_info_t **objp, line_info_t *lines, int offset)
+{
+# ifdef __LP64__
+#  define LP(x) x##_64
+# else
+#  define LP(x) x
+# endif
+    int fd;
+    off_t filesize;
+    char *file, *p = NULL;
+    obj_info_t *obj = *objp;
+    struct LP(mach_header) *header;
+    uintptr_t dladdr_fbase = 0;
+
+    {
+        char *s = binary_filename;
+        char *base = strrchr(binary_filename, '/')+1;
+        size_t max = PATH_MAX;
+        size_t size = strlen(binary_filename);
+        size_t basesize = size - (base - binary_filename);
+        s += size;
+        max -= size;
+        p = s;
+        size = strlcpy(s, ".dSYM/Contents/Resources/DWARF/", max);
+        if (size == 0) goto fail;
+        s += size;
+        max -= size;
+        if (max <= basesize) goto fail;
+        memcpy(s, base, basesize);
+        s[basesize] = 0;
+
+        fd = open(binary_filename, O_RDONLY);
+        if (fd < 0) {
+            *p = 0; /* binary_filename becomes original file name */
+            fd = open(binary_filename, O_RDONLY);
+            if (fd < 0) {
+                goto fail;
+            }
+        }
+    }
+
+    filesize = lseek(fd, 0, SEEK_END);
+    if (filesize < 0) {
+        int e = errno;
+        close(fd);
+        kprintf("lseek: %s\n", strerror(e));
+        goto fail;
+    }
+#if SIZEOF_OFF_T > SIZEOF_SIZE_T
+    if (filesize > (off_t)SIZE_MAX) {
+        close(fd);
+        kprintf("Too large file %s\n", binary_filename);
+        goto fail;
+    }
+#endif
+    lseek(fd, 0, SEEK_SET);
+    /* async-signal unsafe */
+    file = (char *)mmap(NULL, (size_t)filesize, PROT_READ, MAP_SHARED, fd, 0);
+    if (file == MAP_FAILED) {
+        int e = errno;
+        close(fd);
+        kprintf("mmap: %s\n", strerror(e));
+        goto fail;
+    }
+    close(fd);
+
+    obj->mapped = file;
+    obj->mapped_size = (size_t)filesize;
+
+    header = (struct LP(mach_header) *)file;
+    if (header->magic == LP(MH_MAGIC)) {
+        /* non universal binary */
+        p = file;
+    }
+    else if (header->magic == FAT_CIGAM) {
+        struct LP(mach_header) *mhp = _NSGetMachExecuteHeader();
+        struct fat_header *fat = (struct fat_header *)file;
+        char *q = file + sizeof(*fat);
+        uint32_t nfat_arch = __builtin_bswap32(fat->nfat_arch);
+        /* fprintf(stderr,"%d: fat:%s %d\n",__LINE__, binary_filename,nfat_arch); */
+        for (uint32_t i = 0; i < nfat_arch; i++) {
+            struct fat_arch *arch = (struct fat_arch *)q;
+            cpu_type_t cputype = __builtin_bswap32(arch->cputype);
+            cpu_subtype_t cpusubtype = __builtin_bswap32(arch->cpusubtype);
+            uint32_t offset = __builtin_bswap32(arch->offset);
+            /* fprintf(stderr,"%d: fat %d %x/%x %x/%x\n",__LINE__, i, mhp->cputype,mhp->cpusubtype, cputype,cpusubtype); */
+            if (mhp->cputype == cputype &&
+                    (cpu_subtype_t)(mhp->cpusubtype & ~CPU_SUBTYPE_MASK) == cpusubtype) {
+                p = file + offset;
+                file = p;
+                header = (struct LP(mach_header) *)p;
+                if (header->magic == LP(MH_MAGIC)) {
+                    goto found_mach_header;
+                }
+                break;
+            }
+            q += sizeof(*arch);
+        }
+        kprintf("'%s' is not a Mach-O universal binary file!\n",binary_filename);
+        close(fd);
+        goto fail;
+    }
+    else {
+        kprintf("'%s' is not a "
+# ifdef __LP64__
+                "64"
+# else
+                "32"
+# endif
+                "-bit Mach-O file!\n",binary_filename);
+        close(fd);
+        goto fail;
+    }
+found_mach_header:
+    p += sizeof(*header);
+
+    for (uint32_t i = 0; i < (uint32_t)header->ncmds; i++) {
+        struct load_command *lcmd = (struct load_command *)p;
+        switch (lcmd->cmd) {
+          case LP(LC_SEGMENT):
+            {
+                static const char *debug_section_names[] = {
+                    "__debug_abbrev",
+                    "__debug_info",
+                    "__debug_line",
+                    "__debug_ranges",
+                    "__debug_str"
+                };
+                struct LP(segment_command) *scmd = (struct LP(segment_command) *)lcmd;
+                if (strcmp(scmd->segname, "__TEXT") == 0) {
+                    obj->vmaddr = scmd->vmaddr;
+                }
+                else if (strcmp(scmd->segname, "__DWARF") == 0) {
+                    p += sizeof(struct LP(segment_command));
+                    for (uint64_t i = 0; i < scmd->nsects; i++) {
+                        struct LP(section) *sect = (struct LP(section) *)p;
+                        p += sizeof(struct LP(section));
+                        for (int j=0; j < DWARF_SECTION_COUNT; j++) {
+                            struct dwarf_section *s = obj_dwarf_section_at(obj, j);
+
+                            if (strcmp(sect->sectname, debug_section_names[j]) != 0)
+                                continue;
+
+                            s->ptr = file + sect->offset;
+                            s->size = sect->size;
+                            s->flags = sect->flags;
+                            if (s->flags & SHF_COMPRESSED) {
+                                goto fail;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+            break;
+
+          case LC_SYMTAB:
+            {
+                struct symtab_command *cmd = (struct symtab_command *)lcmd;
+                struct LP(nlist) *nl = (struct LP(nlist) *)(file + cmd->symoff);
+                char *strtab = file + cmd->stroff, *sname = 0;
+                uint32_t j;
+                uintptr_t saddr = 0;
+                /* kprintf("[%2d]: %x/symtab %p\n", i, cmd->cmd, p); */
+                for (j = 0; j < cmd->nsyms; j++) {
+                    uintptr_t symsize, d;
+                    struct LP(nlist) *e = &nl[j];
+                        /* kprintf("[%2d][%4d]: %02x/%x/%x: %s %llx\n", i, j, e->n_type,e->n_sect,e->n_desc,strtab+e->n_un.n_strx,e->n_value); */
+                    if (e->n_type != N_FUN) continue;
+                    if (e->n_sect) {
+                        saddr = (uintptr_t)e->n_value + obj->base_addr - obj->vmaddr;
+                        sname = strtab + e->n_un.n_strx;
+                        /* kprintf("[%2d][%4d]: %02x/%x/%x: %s %llx\n", i, j, e->n_type,e->n_sect,e->n_desc,strtab+e->n_un.n_strx,e->n_value); */
+                        continue;
+                    }
+                    for (int k = offset; k < num_traces; k++) {
+                        d = (uintptr_t)traces[k] - saddr;
+                        symsize = e->n_value;
+                        /* kprintf("%lx %lx %lx\n",saddr,symsize,traces[k]); */
+                        if (lines[k].line > 0 || d > (uintptr_t)symsize)
+                            continue;
+                        /* fill symbol name and addr from .symtab */
+                        if (!lines[k].sname) lines[k].sname = sname;
+                        lines[k].saddr = saddr;
+                        lines[k].path  = obj->path;
+                        lines[k].base_addr = obj->base_addr;
+                    }
+                }
+            }
+        }
+        p += lcmd->cmdsize;
+    }
+
+    if (obj->debug_info.ptr && obj->debug_abbrev.ptr) {
+        DebugInfoReader reader;
+        debug_info_reader_init(&reader, obj);
+        while (reader.p < reader.pend) {
+            if (di_read_cu(&reader)) goto fail;
+            debug_info_read(&reader, num_traces, traces, lines, offset);
+        }
+    }
+
+    if (parse_debug_line(num_traces, traces,
+            obj->debug_line.ptr,
+            obj->debug_line.size,
+            obj, lines, offset) == -1)
+        goto fail;
+
+    return dladdr_fbase;
+fail:
+    return (uintptr_t)-1;
+}
+#endif
+
+#define HAVE_MAIN_EXE_PATH
+#if defined(__FreeBSD__)
+# include <sys/sysctl.h>
+#endif
+/* ssize_t main_exe_path(void)
+ *
+ * store the path of the main executable to `binary_filename`,
+ * and returns strlen(binary_filename).
+ * it is NUL terminated.
+ */
+#if defined(__linux__)
+static ssize_t
+main_exe_path(void)
+{
+# define PROC_SELF_EXE "/proc/self/exe"
+    ssize_t len = readlink(PROC_SELF_EXE, binary_filename, PATH_MAX);
+    if (len < 0) return 0;
+    binary_filename[len] = 0;
+    return len;
+}
+#elif defined(__FreeBSD__)
+static ssize_t
+main_exe_path(void)
+{
+    int mib[4] = {CTL_KERN, KERN_PROC, KERN_PROC_PATHNAME, -1};
+    size_t len = PATH_MAX;
+    int err = sysctl(mib, 4, binary_filename, &len, NULL, 0);
+    if (err) {
+	kprintf("Can't get the path of ruby");
+	return -1;
+    }
+    len--; /* sysctl sets strlen+1 */
+    return len;
+}
+#elif defined(HAVE_LIBPROC_H)
+static ssize_t
+main_exe_path(void)
+{
+    int len = proc_pidpath(getpid(), binary_filename, PATH_MAX);
+    if (len == 0) return 0;
+    binary_filename[len] = 0;
+    return len;
+}
+#else
+#undef HAVE_MAIN_EXE_PATH
+#endif
+
+static void
+print_line0(line_info_t *line, void *address)
+{
+    uintptr_t addr = (uintptr_t)address;
+    uintptr_t d = addr - line->saddr;
+    if (!address) {
+        /* inlined */
+        if (line->dirname && line->dirname[0]) {
+            kprintf("%s(%s) %s/%s:%d\n", line->path, line->sname, line->dirname, line->filename, line->line);
+        }
+        else {
+            kprintf("%s(%s) %s:%d\n", line->path, line->sname, line->filename, line->line);
+        }
+    }
+    else if (!line->path) {
+        kprintf("[0x%"PRIxPTR"]\n", addr);
+    }
+    else if (!line->saddr || !line->sname) {
+        kprintf("%s(0x%"PRIxPTR") [0x%"PRIxPTR"]\n", line->path, addr-line->base_addr, addr);
+    }
+    else if (line->line <= 0) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"]\n", line->path, line->sname,
+                d, addr);
+    }
+    else if (!line->filename) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] ???:%d\n", line->path, line->sname,
+                d, addr, line->line);
+    }
+    else if (line->dirname && line->dirname[0]) {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] %s/%s:%d\n", line->path, line->sname,
+                d, addr, line->dirname, line->filename, line->line);
+    }
+    else {
+        kprintf("%s(%s+0x%"PRIxPTR") [0x%"PRIxPTR"] %s:%d\n", line->path, line->sname,
+                d, addr, line->filename, line->line);
+    }
+}
+
+static void
+print_line(line_info_t *line, void *address)
+{
+    print_line0(line, address);
+    if (line->next) {
+        print_line(line->next, NULL);
+    }
+}
+
+void
+rb_dump_backtrace_with_lines(int num_traces, void **traces)
+{
+    int i;
+    /* async-signal unsafe */
+    line_info_t *lines = (line_info_t *)calloc(num_traces, sizeof(line_info_t));
+    obj_info_t *obj = NULL;
+    /* 2 is NULL + main executable */
+    void **dladdr_fbases = (void **)calloc(num_traces+2, sizeof(void *));
+#ifdef HAVE_MAIN_EXE_PATH
+    char *main_path = NULL; /* used on printing backtrace */
+    ssize_t len;
+    if ((len = main_exe_path()) > 0) {
+	main_path = (char *)alloca(len + 1);
+	if (main_path) {
+	    uintptr_t addr;
+	    memcpy(main_path, binary_filename, len+1);
+	    append_obj(&obj);
+	    obj->path = main_path;
+	    addr = fill_lines(num_traces, traces, 1, &obj, lines, -1);
+	    if (addr != (uintptr_t)-1) {
+		dladdr_fbases[0] = (void *)addr;
+	    }
+	}
+    }
+#endif
+
+    /* fill source lines by reading dwarf */
+    for (i = 0; i < num_traces; i++) {
+	Dl_info info;
+	if (lines[i].line) continue;
+	if (dladdr(traces[i], &info)) {
+	    const char *path;
+	    void **p;
+
+	    /* skip symbols which is in already checked objects */
+	    /* if the binary is strip-ed, this may effect */
+	    for (p=dladdr_fbases; *p; p++) {
+		if (*p == info.dli_fbase) {
+		    lines[i].path = info.dli_fname;
+		    lines[i].sname = info.dli_sname;
+		    goto next_line;
+		}
+	    }
+	    *p = info.dli_fbase;
+
+	    append_obj(&obj);
+	    obj->base_addr = (uintptr_t)info.dli_fbase;
+	    path = info.dli_fname;
+	    obj->path = path;
+	    lines[i].path = path;
+            lines[i].sname = info.dli_sname;
+            lines[i].saddr = (uintptr_t)info.dli_saddr;
+	    strlcpy(binary_filename, path, PATH_MAX);
+	    if (fill_lines(num_traces, traces, 1, &obj, lines, i) == (uintptr_t)-1)
+		break;
+	}
+next_line:
+	continue;
+    }
+
+    /* output */
+    for (i = 0; i < num_traces; i++) {
+        print_line(&lines[i], traces[i]);
+
+	/* FreeBSD's backtrace may show _start and so on */
+	if (lines[i].sname && strcmp("main", lines[i].sname) == 0)
+	    break;
+    }
+
+    /* free */
+    while (obj) {
+	obj_info_t *o = obj;
+        for (i=0; i < DWARF_SECTION_COUNT; i++) {
+            struct dwarf_section *s = obj_dwarf_section_at(obj, i);
+            if (s->flags & SHF_COMPRESSED) {
+                free(s->ptr);
+            }
+        }
+	if (obj->mapped_size) {
+	    munmap(obj->mapped, obj->mapped_size);
+	}
+	obj = o->next;
+	free(o);
+    }
+    for (i = 0; i < num_traces; i++) {
+        line_info_t *line = lines[i].next;
+        while (line) {
+            line_info_t *l = line;
+            line = line->next;
+            free(l);
+        }
+    }
+    free(lines);
+    free(dladdr_fbases);
+}
+
+/* From FreeBSD's lib/libstand/printf.c */
+/*-
+ * Copyright (c) 1986, 1988, 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)subr_prf.c	8.3 (Berkeley) 1/21/94
+ */
+
+#include <stdarg.h>
+#define MAXNBUF (sizeof(intmax_t) * CHAR_BIT + 1)
+static inline int toupper(int c) { return ('A' <= c && c <= 'Z') ? (c&0x5f) : c; }
+#define    hex2ascii(hex)  (hex2ascii_data[hex])
+static const char hex2ascii_data[] = "0123456789abcdefghijklmnopqrstuvwxyz";
+static inline int imax(int a, int b) { return (a > b ? a : b); }
+static int kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, va_list ap);
+
+static void putce(int c)
+{
+    char s[1];
+    ssize_t ret;
+
+    s[0] = (char)c;
+    ret = write(2, s, 1);
+    (void)ret;
+}
+
+static int
+kprintf(const char *fmt, ...)
+{
+	va_list ap;
+	int retval;
+
+	va_start(ap, fmt);
+	retval = kvprintf(fmt, putce, NULL, 10, ap);
+	va_end(ap);
+	return retval;
+}
+
+/*
+ * Put a NUL-terminated ASCII number (base <= 36) in a buffer in reverse
+ * order; return an optional length and a pointer to the last character
+ * written in the buffer (i.e., the first character of the string).
+ * The buffer pointed to by `nbuf' must have length >= MAXNBUF.
+ */
+static char *
+ksprintn(char *nbuf, uintmax_t num, int base, int *lenp, int upper)
+{
+	char *p, c;
+
+	p = nbuf;
+	*p = '\0';
+	do {
+		c = hex2ascii(num % base);
+		*++p = upper ? toupper(c) : c;
+	} while (num /= base);
+	if (lenp)
+		*lenp = (int)(p - nbuf);
+	return (p);
+}
+
+/*
+ * Scaled down version of printf(3).
+ *
+ * Two additional formats:
+ *
+ * The format %b is supported to decode error registers.
+ * Its usage is:
+ *
+ *	printf("reg=%b\n", regval, "<base><arg>*");
+ *
+ * where <base> is the output base expressed as a control character, e.g.
+ * \10 gives octal; \20 gives hex.  Each arg is a sequence of characters,
+ * the first of which gives the bit number to be inspected (origin 1), and
+ * the next characters (up to a control character, i.e. a character <= 32),
+ * give the name of the register.  Thus:
+ *
+ *	kvprintf("reg=%b\n", 3, "\10\2BITTWO\1BITONE\n");
+ *
+ * would produce output:
+ *
+ *	reg=3<BITTWO,BITONE>
+ *
+ * XXX:  %D  -- Hexdump, takes pointer and separator string:
+ *		("%6D", ptr, ":")   -> XX:XX:XX:XX:XX:XX
+ *		("%*D", len, ptr, " " -> XX XX XX XX ...
+ */
+static int
+kvprintf(char const *fmt, void (*func)(int), void *arg, int radix, va_list ap)
+{
+#define PCHAR(c) {int cc=(c); if (func) (*func)(cc); else *d++ = cc; retval++; }
+	char nbuf[MAXNBUF];
+	char *d;
+	const char *p, *percent, *q;
+	unsigned char *up;
+	int ch, n;
+	uintmax_t num;
+	int base, lflag, qflag, tmp, width, ladjust, sharpflag, neg, sign, dot;
+	int cflag, hflag, jflag, tflag, zflag;
+	int dwidth, upper;
+	char padc;
+	int stop = 0, retval = 0;
+
+	num = 0;
+	if (!func)
+		d = (char *) arg;
+	else
+		d = NULL;
+
+	if (fmt == NULL)
+		fmt = "(fmt null)\n";
+
+	if (radix < 2 || radix > 36)
+		radix = 10;
+
+	for (;;) {
+		padc = ' ';
+		width = 0;
+		while ((ch = (unsigned char)*fmt++) != '%' || stop) {
+			if (ch == '\0')
+				return (retval);
+			PCHAR(ch);
+		}
+		percent = fmt - 1;
+		qflag = 0; lflag = 0; ladjust = 0; sharpflag = 0; neg = 0;
+		sign = 0; dot = 0; dwidth = 0; upper = 0;
+		cflag = 0; hflag = 0; jflag = 0; tflag = 0; zflag = 0;
+reswitch:	switch (ch = (unsigned char)*fmt++) {
+		case '.':
+			dot = 1;
+			goto reswitch;
+		case '#':
+			sharpflag = 1;
+			goto reswitch;
+		case '+':
+			sign = 1;
+			goto reswitch;
+		case '-':
+			ladjust = 1;
+			goto reswitch;
+		case '%':
+			PCHAR(ch);
+			break;
+		case '*':
+			if (!dot) {
+				width = va_arg(ap, int);
+				if (width < 0) {
+					ladjust = !ladjust;
+					width = -width;
+				}
+			} else {
+				dwidth = va_arg(ap, int);
+			}
+			goto reswitch;
+		case '0':
+			if (!dot) {
+				padc = '0';
+				goto reswitch;
+			}
+		case '1': case '2': case '3': case '4':
+		case '5': case '6': case '7': case '8': case '9':
+				for (n = 0;; ++fmt) {
+					n = n * 10 + ch - '0';
+					ch = *fmt;
+					if (ch < '0' || ch > '9')
+						break;
+				}
+			if (dot)
+				dwidth = n;
+			else
+				width = n;
+			goto reswitch;
+		case 'b':
+			num = (unsigned int)va_arg(ap, int);
+			p = va_arg(ap, char *);
+			for (q = ksprintn(nbuf, num, *p++, NULL, 0); *q;)
+				PCHAR(*q--);
+
+			if (num == 0)
+				break;
+
+			for (tmp = 0; *p;) {
+				n = *p++;
+				if (num & (1 << (n - 1))) {
+					PCHAR(tmp ? ',' : '<');
+					for (; (n = *p) > ' '; ++p)
+						PCHAR(n);
+					tmp = 1;
+				} else
+					for (; *p > ' '; ++p)
+						continue;
+			}
+			if (tmp)
+				PCHAR('>');
+			break;
+		case 'c':
+			PCHAR(va_arg(ap, int));
+			break;
+		case 'D':
+			up = va_arg(ap, unsigned char *);
+			p = va_arg(ap, char *);
+			if (!width)
+				width = 16;
+			while(width--) {
+				PCHAR(hex2ascii(*up >> 4));
+				PCHAR(hex2ascii(*up & 0x0f));
+				up++;
+				if (width)
+					for (q=p;*q;q++)
+						PCHAR(*q);
+			}
+			break;
+		case 'd':
+		case 'i':
+			base = 10;
+			sign = 1;
+			goto handle_sign;
+		case 'h':
+			if (hflag) {
+				hflag = 0;
+				cflag = 1;
+			} else
+				hflag = 1;
+			goto reswitch;
+		case 'j':
+			jflag = 1;
+			goto reswitch;
+		case 'l':
+			if (lflag) {
+				lflag = 0;
+				qflag = 1;
+			} else
+				lflag = 1;
+			goto reswitch;
+		case 'n':
+			if (jflag)
+				*(va_arg(ap, intmax_t *)) = retval;
+			else if (qflag)
+				*(va_arg(ap, int64_t *)) = retval;
+			else if (lflag)
+				*(va_arg(ap, long *)) = retval;
+			else if (zflag)
+				*(va_arg(ap, size_t *)) = retval;
+			else if (hflag)
+				*(va_arg(ap, short *)) = retval;
+			else if (cflag)
+				*(va_arg(ap, char *)) = retval;
+			else
+				*(va_arg(ap, int *)) = retval;
+			break;
+		case 'o':
+			base = 8;
+			goto handle_nosign;
+		case 'p':
+			base = 16;
+			sharpflag = (width == 0);
+			sign = 0;
+			num = (uintptr_t)va_arg(ap, void *);
+			goto number;
+		case 'q':
+			qflag = 1;
+			goto reswitch;
+		case 'r':
+			base = radix;
+			if (sign)
+				goto handle_sign;
+			goto handle_nosign;
+		case 's':
+			p = va_arg(ap, char *);
+			if (p == NULL)
+				p = "(null)";
+			if (!dot)
+				n = (int)strlen (p);
+			else
+				for (n = 0; n < dwidth && p[n]; n++)
+					continue;
+
+			width -= n;
+
+			if (!ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			while (n--)
+				PCHAR(*p++);
+			if (ladjust && width > 0)
+				while (width--)
+					PCHAR(padc);
+			break;
+		case 't':
+			tflag = 1;
+			goto reswitch;
+		case 'u':
+			base = 10;
+			goto handle_nosign;
+		case 'X':
+			upper = 1;
+		case 'x':
+			base = 16;
+			goto handle_nosign;
+		case 'y':
+			base = 16;
+			sign = 1;
+			goto handle_sign;
+		case 'z':
+			zflag = 1;
+			goto reswitch;
+handle_nosign:
+			sign = 0;
+			if (jflag)
+				num = va_arg(ap, uintmax_t);
+			else if (qflag)
+				num = va_arg(ap, uint64_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, unsigned long);
+			else if (zflag)
+				num = va_arg(ap, size_t);
+			else if (hflag)
+				num = (unsigned short)va_arg(ap, int);
+			else if (cflag)
+				num = (unsigned char)va_arg(ap, int);
+			else
+				num = va_arg(ap, unsigned int);
+			goto number;
+handle_sign:
+			if (jflag)
+				num = va_arg(ap, intmax_t);
+			else if (qflag)
+				num = va_arg(ap, int64_t);
+			else if (tflag)
+				num = va_arg(ap, ptrdiff_t);
+			else if (lflag)
+				num = va_arg(ap, long);
+			else if (zflag)
+				num = va_arg(ap, ssize_t);
+			else if (hflag)
+				num = (short)va_arg(ap, int);
+			else if (cflag)
+				num = (char)va_arg(ap, int);
+			else
+				num = va_arg(ap, int);
+number:
+			if (sign && (intmax_t)num < 0) {
+				neg = 1;
+				num = -(intmax_t)num;
+			}
+			p = ksprintn(nbuf, num, base, &n, upper);
+			tmp = 0;
+			if (sharpflag && num != 0) {
+				if (base == 8)
+					tmp++;
+				else if (base == 16)
+					tmp += 2;
+			}
+			if (neg)
+				tmp++;
+
+			if (!ladjust && padc == '0')
+				dwidth = width - tmp;
+			width -= tmp + imax(dwidth, n);
+			dwidth -= n;
+			if (!ladjust)
+				while (width-- > 0)
+					PCHAR(' ');
+			if (neg)
+				PCHAR('-');
+			if (sharpflag && num != 0) {
+				if (base == 8) {
+					PCHAR('0');
+				} else if (base == 16) {
+					PCHAR('0');
+					PCHAR('x');
+				}
+			}
+			while (dwidth-- > 0)
+				PCHAR('0');
+
+			while (*p)
+				PCHAR(*p--);
+
+			if (ladjust)
+				while (width-- > 0)
+					PCHAR(' ');
+
+			break;
+		default:
+			while (percent < fmt)
+				PCHAR(*percent++);
+			/*
+			 * Since we ignore an formatting argument it is no
+			 * longer safe to obey the remaining formatting
+			 * arguments as the arguments will no longer match
+			 * the format specs.
+			 */
+			stop = 1;
+			break;
+		}
+	}
+#undef PCHAR
+}
+#else /* defined(USE_ELF) */
+#error not supported
+#endif
diff -Nuarp ruby-2.7.6.a/common.mk ruby-2.7.6.b/common.mk
--- ruby-2.7.6.a/common.mk	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/common.mk	2022-11-08 10:29:28.490776300 -0500
@@ -81,7 +81,8 @@ ENC_MK        = enc.mk
 MAKE_ENC      = -f $(ENC_MK) V="$(V)" UNICODE_HDR_DIR="$(UNICODE_HDR_DIR)" \
 		RUBY="$(MINIRUBY)" MINIRUBY="$(MINIRUBY)" $(mflags)
 
-COMMONOBJS    = array.$(OBJEXT) \
+COMMONOBJS    = abrt.$(OBJEXT) \
+                array.$(OBJEXT) \
 		ast.$(OBJEXT) \
 		bignum.$(OBJEXT) \
 		class.$(OBJEXT) \
diff -Nuarp ruby-2.7.6.a/configure.ac ruby-2.7.6.b/configure.ac
--- ruby-2.7.6.a/configure.ac	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/configure.ac	2022-11-08 10:30:01.805714700 -0500
@@ -98,7 +98,7 @@ RUBY_BASE_NAME=`echo ruby | sed "$progra
 RUBYW_BASE_NAME=`echo rubyw | sed "$program_transform_name"`
 AC_SUBST(RUBY_BASE_NAME)
 AC_SUBST(RUBYW_BASE_NAME)
-AC_SUBST(RUBY_VERSION_NAME, '${RUBY_BASE_NAME}-${ruby_version}')
+AC_SUBST(RUBY_VERSION_NAME, '${RUBY_BASE_NAME}-${ruby_version_dir_name}')
 
 AC_CANONICAL_TARGET
 test x"$target_alias" = x &&
@@ -1873,6 +1873,7 @@ AC_CHECK_FUNCS(lstat)
 AC_CHECK_FUNCS(lutimes)
 AC_CHECK_FUNCS(malloc_usable_size)
 AC_CHECK_FUNCS(malloc_size)
+AC_CHECK_FUNCS(malloc_trim)
 AC_CHECK_FUNCS(mblen)
 AC_CHECK_FUNCS(memalign)
 AC_CHECK_FUNCS(memset_s)
@@ -3121,6 +3122,11 @@ AS_IF([test ${multiarch+set}], [
 ])
 
 archlibdir='${libdir}/${arch}'
+AC_ARG_WITH(archlibdir,
+	    AS_HELP_STRING([--with-archlibdir=DIR],
+			   [prefix for libruby [[LIBDIR/ARCH]]]),
+	    [archlibdir="$withval"])
+
 sitearchlibdir='${libdir}/${sitearch}'
 archincludedir='${includedir}/${arch}'
 sitearchincludedir='${includedir}/${sitearch}'
@@ -3710,9 +3716,6 @@ AS_CASE(["$target_os"],
     rubyw_install_name='$(RUBYW_INSTALL_NAME)'
     ])
 
-rubylibdir='${rubylibprefix}/${ruby_version}'
-rubyarchdir=${multiarch+'${rubyarchprefix}/${ruby_version}'}${multiarch-'${rubylibdir}/${arch}'}
-
 rubyarchprefix=${multiarch+'${archlibdir}/${RUBY_BASE_NAME}'}${multiarch-'${rubylibprefix}/${arch}'}
 AC_ARG_WITH(rubyarchprefix,
 	    AS_HELP_STRING([--with-rubyarchprefix=DIR],
@@ -3735,56 +3738,67 @@ AC_ARG_WITH(ridir,
 AC_SUBST(ridir)
 AC_SUBST(RI_BASE_NAME)
 
-AC_ARG_WITH(ruby-version,
-	    AS_HELP_STRING([--with-ruby-version=STR], [ruby version string for version specific directories [[full]] (full|minor|STR)]),
-            [ruby_version=$withval],
-            [ruby_version=full])
 unset RUBY_LIB_VERSION
-unset RUBY_LIB_VERSION_STYLE
-AS_CASE(["$ruby_version"],
-  [full],  [RUBY_LIB_VERSION_STYLE='3	/* full */'],
-  [minor], [RUBY_LIB_VERSION_STYLE='2	/* minor */'])
-AS_IF([test ${RUBY_LIB_VERSION_STYLE+set}], [
-    {
-    echo "#define RUBY_LIB_VERSION_STYLE $RUBY_LIB_VERSION_STYLE"
-    echo '#define STRINGIZE(x) x'
-    test -f revision.h -o -f "${srcdir}/revision.h" || echo '#define RUBY_REVISION 0'
-    echo '#include "version.h"'
-    echo 'ruby_version=RUBY_LIB_VERSION'
-    } > conftest.c
-    ruby_version="`$CPP -I. -I"${srcdir}" -I"${srcdir}/include" conftest.c | sed '/^ruby_version=/!d;s/ //g'`"
-    eval $ruby_version
-], [test -z "${ruby_version}"], [
-    AC_MSG_ERROR([No ruby version, No place for bundled libraries])
-], [
-    RUBY_LIB_VERSION="${ruby_version}"
-])
+RUBY_LIB_VERSION_STYLE='3	/* full */'
+{
+echo "#define RUBY_LIB_VERSION_STYLE $RUBY_LIB_VERSION_STYLE"
+echo '#define STRINGIZE(x) x'
+test -f revision.h -o -f "${srcdir}/revision.h" || echo '#define RUBY_REVISION 0'
+echo '#include "version.h"'
+echo 'ruby_version=RUBY_LIB_VERSION'
+} > conftest.c
+ruby_version="`$CPP -I. -I"${srcdir}" -I"${srcdir}/include" conftest.c | sed '/^ruby_version=/!d;s/ //g'`"
+eval $ruby_version
+
+RUBY_LIB_VERSION="${ruby_version}"
+
 AC_SUBST(RUBY_LIB_VERSION_STYLE)
 AC_SUBST(RUBY_LIB_VERSION)
 
+AC_ARG_WITH(ruby-version,
+	    AS_HELP_STRING([--with-ruby-version=STR], [ruby version string for version specific directories [[full]] (full|STR)]),
+            [ruby_version_dir_name=$withval],
+            [ruby_version_dir_name=full])
+AS_CASE(["$ruby_version_dir_name"],
+  [full], [ruby_version_dir_name='${ruby_version}'])
+
+ruby_version_dir=/'${ruby_version_dir_name}'
+
+if test -z "${ruby_version_dir_name}"; then
+    unset ruby_version_dir
+    AC_DEFINE(RUBY_LIB_VERSION_BLANK, 1)
+fi
+
+rubylibdir='${rubylibprefix}'${ruby_version_dir}
+rubyarchdir=${multiarch+'${rubyarchprefix}'${ruby_version_dir}}${multiarch-'${rubylibdir}/${arch}'}
+
 AC_ARG_WITH(sitedir,
 	    AS_HELP_STRING([--with-sitedir=DIR], [site libraries in DIR [[RUBY_LIB_PREFIX/site_ruby]], "no" to disable site directory]),
             [sitedir=$withval],
             [sitedir='${rubylibprefix}/site_ruby'])
-sitelibdir='${sitedir}/${ruby_version}'
+sitelibdir='${sitedir}'${ruby_version_dir}
 
 AC_ARG_WITH(sitearchdir,
 	    AS_HELP_STRING([--with-sitearchdir=DIR],
 			   [architecture dependent site libraries in DIR [[SITEDIR/SITEARCH]], "no" to disable site directory]),
             [sitearchdir=$withval],
-            [sitearchdir=${multiarch+'${rubysitearchprefix}/site_ruby/${ruby_version}'}${multiarch-'${sitelibdir}/${sitearch}'}])
+            [sitearchdir=${multiarch+'${rubysitearchprefix}/site_ruby'${ruby_version_dir}}${multiarch-'${sitelibdir}/${sitearch}'}])
 
 AC_ARG_WITH(vendordir,
 	    AS_HELP_STRING([--with-vendordir=DIR], [vendor libraries in DIR [[RUBY_LIB_PREFIX/vendor_ruby]], "no" to disable vendor directory]),
             [vendordir=$withval],
             [vendordir='${rubylibprefix}/vendor_ruby'])
-vendorlibdir='${vendordir}/${ruby_version}'
+vendorlibdir='${vendordir}'${ruby_version_dir}
 
 AC_ARG_WITH(vendorarchdir,
 	    AS_HELP_STRING([--with-vendorarchdir=DIR],
 			   [architecture dependent vendor libraries in DIR [[VENDORDIR/SITEARCH]], "no" to disable vendor directory]),
             [vendorarchdir=$withval],
-            [vendorarchdir=${multiarch+'${rubysitearchprefix}/vendor_ruby/${ruby_version}'}${multiarch-'${vendorlibdir}/${sitearch}'}])
+            [vendorarchdir=${multiarch+'${rubysitearchprefix}/vendor_ruby'${ruby_version_dir}}${multiarch-'${vendorlibdir}/${sitearch}'}])
+
+AC_ARG_WITH(rubygemsdir,
+           AS_HELP_STRING([--with-rubygemsdir=DIR], [custom rubygems directory]),
+            [rubygemsdir=$withval])
 
 AS_IF([test "${LOAD_RELATIVE+set}"], [
     AC_DEFINE_UNQUOTED(LOAD_RELATIVE, $LOAD_RELATIVE)
@@ -3801,6 +3815,7 @@ AC_SUBST(sitearchincludedir)dnl
 AC_SUBST(arch)dnl
 AC_SUBST(sitearch)dnl
 AC_SUBST(ruby_version)dnl
+AC_SUBST(ruby_version_dir_name)dnl
 AC_SUBST(rubylibdir)dnl
 AC_SUBST(rubyarchdir)dnl
 AC_SUBST(sitedir)dnl
@@ -3809,10 +3824,13 @@ AC_SUBST(sitearchdir)dnl
 AC_SUBST(vendordir)dnl
 AC_SUBST(vendorlibdir)dnl
 AC_SUBST(vendorarchdir)dnl
+AC_SUBST(rubygemsdir)dnl
 
 AC_SUBST(CONFIGURE, "`echo $0 | sed 's|.*/||'`")dnl
 AC_SUBST(configure_args, "`echo "${ac_configure_args}" | sed 's/\\$/$$/g'`")dnl
 
+target_cpu=`echo $target_cpu | sed s/i.86/i386/`
+
 AS_IF([test "${universal_binary-no}" = yes ], [
     arch="universal-${target_os}"
     AS_IF([test "${rb_cv_architecture_available}" = yes], [
diff -Nuarp ruby-2.7.6.a/eval_error.c ruby-2.7.6.b/eval_error.c
--- ruby-2.7.6.a/eval_error.c	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/eval_error.c	2022-11-08 10:29:58.540769900 -0500
@@ -241,8 +241,8 @@ print_backtrace(const VALUE eclass, cons
 		     (len < threshold ? 0 : 9) + 1);
 
 #define TRACE_MAX (TRACE_HEAD+TRACE_TAIL+5)
-#define TRACE_HEAD 8
-#define TRACE_TAIL 5
+#define TRACE_HEAD 100
+#define TRACE_TAIL 100
 
 	for (i = 1; i < len; i++) {
 	    VALUE line = RARRAY_AREF(errat, reverse ? len - i : i);
diff -Nuarp ruby-2.7.6.a/ext/openssl/extconf.rb ruby-2.7.6.b/ext/openssl/extconf.rb
--- ruby-2.7.6.a/ext/openssl/extconf.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/ext/openssl/extconf.rb	2022-11-08 10:29:47.636888400 -0500
@@ -88,7 +88,7 @@ def find_openssl_library
 end
 
 Logging::message "=== Checking for required stuff... ===\n"
-pkg_config_found = pkg_config("openssl") && have_header("openssl/ssl.h")
+pkg_config_found = !with_config("openssl-dir") && pkg_config("openssl") && have_header("openssl/ssl.h")
 
 if !pkg_config_found && !find_openssl_library
   Logging::message "=== Checking for required stuff failed. ===\n"
diff -Nuarp ruby-2.7.6.a/ext/openssl/openssl.gemspec ruby-2.7.6.b/ext/openssl/openssl.gemspec
--- ruby-2.7.6.a/ext/openssl/openssl.gemspec	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/ext/openssl/openssl.gemspec	2022-11-08 10:29:37.704694200 -0500
@@ -17,7 +17,6 @@ Gem::Specification.new do |spec|
 
   spec.required_ruby_version = ">= 2.3.0"
 
-  spec.add_runtime_dependency "ipaddr"
   spec.add_development_dependency "rake"
   spec.add_development_dependency "rake-compiler"
   spec.add_development_dependency "test-unit", "~> 3.0"
diff -Nuarp ruby-2.7.6.a/gc.c ruby-2.7.6.b/gc.c
--- ruby-2.7.6.a/gc.c	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/gc.c	2022-11-08 10:30:01.831206800 -0500
@@ -290,6 +290,9 @@ rb_gc_guarded_ptr_val(volatile VALUE *pt
 #ifndef GC_MALLOC_LIMIT_GROWTH_FACTOR
 #define GC_MALLOC_LIMIT_GROWTH_FACTOR 1.4
 #endif
+#ifndef GC_MALLOC_TRIM_FREQUENCY
+#define GC_MALLOC_TRIM_FREQUENCY 0
+#endif
 
 #ifndef GC_OLDMALLOC_LIMIT_MIN
 #define GC_OLDMALLOC_LIMIT_MIN (16 * 1024 * 1024 /* 16MB */)
@@ -328,6 +331,7 @@ typedef struct {
     size_t malloc_limit_min;
     size_t malloc_limit_max;
     double malloc_limit_growth_factor;
+    size_t malloc_trim_frequency;
 
     size_t oldmalloc_limit_min;
     size_t oldmalloc_limit_max;
@@ -350,6 +354,7 @@ static ruby_gc_params_t gc_params = {
     GC_MALLOC_LIMIT_MIN,
     GC_MALLOC_LIMIT_MAX,
     GC_MALLOC_LIMIT_GROWTH_FACTOR,
+    GC_MALLOC_TRIM_FREQUENCY,
 
     GC_OLDMALLOC_LIMIT_MIN,
     GC_OLDMALLOC_LIMIT_MAX,
@@ -698,6 +703,8 @@ typedef struct rb_objspace {
 #if GC_ENABLE_INCREMENTAL_MARK
 	unsigned int during_incremental_marking : 1;
 #endif
+        int collect_gc_stats;
+        int verbose_gc_stats;
     } flags;
 
     rb_event_flag_t hook_events;
@@ -772,14 +779,21 @@ typedef struct rb_objspace {
 
 	/* temporary profiling space */
 	double gc_sweep_start_time;
+        double gc_mark_start_time;
+
 	size_t total_allocated_objects_at_gc_start;
 	size_t heap_used_at_gc_start;
 
 	/* basic statistics */
 	size_t count;
+        double time;
 	size_t total_freed_objects;
 	size_t total_allocated_pages;
 	size_t total_freed_pages;
+        size_t total_mallocs;
+        size_t total_malloced_bytes;
+        size_t live_after_last_sweep;
+
     } profile;
     struct gc_list *global_list;
 
@@ -920,6 +934,7 @@ VALUE *ruby_initial_gc_stress_ptr = &rub
 #define heap_tomb               (&objspace->tomb_heap)
 #define dont_gc 		objspace->flags.dont_gc
 #define during_gc		objspace->flags.during_gc
+#define collect_gc_stats        objspace->flags.collect_gc_stats
 #define finalizing		objspace->atomic_flags.finalizing
 #define finalizer_table 	objspace->finalizer_table
 #define global_list		objspace->global_list
@@ -6908,6 +6923,107 @@ rb_gc_writebarrier_remember(VALUE obj)
 
 static st_table *rgengc_unprotect_logging_table;
 
+VALUE
+rb_gc_enable_stats()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    int old = collect_gc_stats;
+    collect_gc_stats = 1;
+    return old ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_enable_stats(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_enable_stats();
+}
+
+VALUE
+rb_gc_disable_stats()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    int old = collect_gc_stats;
+    collect_gc_stats = 0;
+    return old ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_disable_stats(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_disable_stats();
+}
+
+
+VALUE
+rb_gc_stats_enabled()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return collect_gc_stats ? Qtrue : Qfalse;
+}
+
+static VALUE
+gc_stats_enabled(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_stats_enabled();
+}
+
+double rb_gc_total_time()
+{
+    return rb_objspace.profile.time;
+}
+
+static VALUE
+gc_time(rb_execution_context_t *ec, VALUE _)
+{
+    return DBL2NUM(1000000*rb_objspace.profile.time);
+}
+
+VALUE
+rb_gc_heap_slots()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return SIZET2NUM(heap_allocated_pages * HEAP_PAGE_OBJ_LIMIT);
+}
+
+static
+VALUE gc_heap_slots(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_heap_slots();
+}
+
+VALUE
+rb_gc_heap_slots_live_after_last_gc()
+{
+    rb_objspace_t *objspace = &rb_objspace;
+    return SIZET2NUM(objspace->profile.live_after_last_sweep);
+}
+
+static
+VALUE gc_heap_slots_live_after_last_gc(rb_execution_context_t *ec, VALUE _)
+{
+    return rb_gc_heap_slots_live_after_last_gc();
+}
+
+size_t rb_gc_total_mallocs() {
+    return rb_objspace.profile.total_mallocs;
+}
+
+static VALUE
+gc_total_mallocs(rb_execution_context_t *ec, VALUE _)
+{
+    return SIZET2NUM(rb_objspace.profile.total_mallocs);
+}
+
+size_t rb_gc_total_malloced_bytes(void) {
+    return rb_objspace.profile.total_malloced_bytes;
+}
+
+static VALUE
+gc_total_malloced_bytes(rb_execution_context_t *ec, VALUE _)
+{
+    return SIZET2NUM(rb_objspace.profile.total_malloced_bytes);
+}
+
 static int
 rgengc_unprotect_logging_exit_func_i(st_data_t key, st_data_t val, st_data_t arg)
 {
@@ -7352,6 +7468,20 @@ gc_start(rb_objspace_t *objspace, int re
     gc_prof_timer_start(objspace);
     {
 	gc_marks(objspace, do_full_mark);
+#ifdef HAVE_MALLOC_TRIM
+        /* [Experimental] Explicitly free all eligible pages to the kernel.  See:
+         *
+         * - https://www.joyfulbikeshedding.com/blog/2019-03-14-what-causes-ruby-memory-bloat.html
+         * - https://bugs.ruby-lang.org/issues/15667
+         */
+#if USE_RGENGC
+        size_t gc_count = rb_objspace.profile.major_gc_count;
+#else
+        size_t gc_count = rb_objspace.profile.count;
+#endif
+        if (do_full_mark && gc_params.malloc_trim_frequency && gc_count % gc_params.malloc_trim_frequency == 0)
+            malloc_trim(0);
+#endif
     }
     gc_prof_timer_stop(objspace);
 
@@ -9475,6 +9605,7 @@ ruby_gc_set_params(void)
     get_envparam_size  ("RUBY_GC_OLDMALLOC_LIMIT_MAX", &gc_params.oldmalloc_limit_max, 0);
     get_envparam_double("RUBY_GC_OLDMALLOC_LIMIT_GROWTH_FACTOR", &gc_params.oldmalloc_limit_growth_factor, 1.0, 0.0, FALSE);
 #endif
+    get_envparam_size  ("RUBY_GC_MALLOC_TRIM_FREQUENCY", &gc_params.malloc_trim_frequency, 0);
 }
 
 void
@@ -9734,6 +9865,10 @@ objspace_malloc_increase(rb_objspace_t *
 {
     if (new_size > old_size) {
 	ATOMIC_SIZE_ADD(malloc_increase, new_size - old_size);
+        if (collect_gc_stats) {
+            ATOMIC_SIZE_ADD(objspace->profile.total_mallocs, 1);
+            ATOMIC_SIZE_ADD(objspace->profile.total_malloced_bytes, new_size - old_size);
+        }
 #if RGENGC_ESTIMATE_OLDMALLOC
 	ATOMIC_SIZE_ADD(objspace->rgengc.oldmalloc_increase, new_size - old_size);
 #endif
@@ -10313,6 +10448,12 @@ gc_malloc_allocated_size(VALUE self)
     return UINT2NUM(rb_objspace.malloc_params.allocated_size);
 }
 
+size_t
+rb_gc_malloc_allocated_size(void)
+{
+    return rb_objspace.malloc_params.allocated_size;
+}
+
 /*
  *  call-seq:
  *     GC.malloc_allocations -> Integer
@@ -10327,6 +10468,12 @@ gc_malloc_allocations(VALUE self)
 {
     return UINT2NUM(rb_objspace.malloc_params.allocations);
 }
+
+size_t
+rb_gc_malloc_allocations(void)
+{
+    return rb_objspace.malloc_params.allocations;
+}
 #endif
 
 void
@@ -10934,6 +11081,14 @@ gc_prof_mark_timer_start(rb_objspace_t *
 #if GC_PROFILE_MORE_DETAIL
     if (gc_prof_enabled(objspace)) {
 	gc_prof_record(objspace)->gc_mark_time = getrusage_time();
+    } else {
+        if (collect_gc_stats) {
+          objspace->profile.gc_mark_start_time = getrusage_time();
+        }
+    }
+#else
+    if (collect_gc_stats) {
+        objspace->profile.gc_mark_start_time = getrusage_time();
     }
 #endif
 }
@@ -10946,6 +11101,17 @@ gc_prof_mark_timer_stop(rb_objspace_t *o
     if (gc_prof_enabled(objspace)) {
         gc_profile_record *record = gc_prof_record(objspace);
 	record->gc_mark_time = elapsed_time_from(record->gc_mark_time);
+        if (collect_gc_stats) {
+            objspace->profile.time += record->gc_mark_time;
+        }
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.time += elapsed_time_from(objspace->profile.gc_mark_start_time);
+        }
+    }
+#else
+    if (collect_gc_stats) {
+        objspace->profile.time += elapsed_time_from(objspace->profile.gc_mark_start_time);
     }
 #endif
 }
@@ -10957,9 +11123,13 @@ gc_prof_sweep_timer_start(rb_objspace_t
     if (gc_prof_enabled(objspace)) {
 	gc_profile_record *record = gc_prof_record(objspace);
 
-	if (record->gc_time > 0 || GC_PROFILE_MORE_DETAIL) {
+	if (record->gc_time > 0 || GC_PROFILE_MORE_DETAIL || collect_gc_stats) {
 	    objspace->profile.gc_sweep_start_time = getrusage_time();
-	}
+        }
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.gc_sweep_start_time = getrusage_time();
+        }
     }
 }
 
@@ -10976,16 +11146,30 @@ gc_prof_sweep_timer_stop(rb_objspace_t *
 	    sweep_time = elapsed_time_from(objspace->profile.gc_sweep_start_time);
 	    /* need to accumulate GC time for lazy sweep after gc() */
 	    record->gc_time += sweep_time;
+            if (collect_gc_stats) {
+                objspace->profile.time += sweep_time;
+            }
 	}
 	else if (GC_PROFILE_MORE_DETAIL) {
 	    sweep_time = elapsed_time_from(objspace->profile.gc_sweep_start_time);
-	}
+            if (collect_gc_stats) {
+                objspace->profile.time += sweep_time;
+            }
+	} else {
+            if (collect_gc_stats) {
+                objspace->profile.time += elapsed_time_from(objspace->profile.gc_sweep_start_time);
+            }
+        }
 
 #if GC_PROFILE_MORE_DETAIL
 	record->gc_sweep_time += sweep_time;
 	if (heap_pages_deferred_final) record->flags |= GPR_FLAG_HAVE_FINALIZE;
 #endif
 	if (heap_pages_deferred_final) objspace->profile.latest_gc_info |= GPR_FLAG_HAVE_FINALIZE;
+    } else {
+        if (collect_gc_stats) {
+            objspace->profile.time += elapsed_time_from(objspace->profile.gc_sweep_start_time);
+        }
     }
 }
 
@@ -11004,9 +11188,13 @@ gc_prof_set_malloc_info(rb_objspace_t *o
 static inline void
 gc_prof_set_heap_info(rb_objspace_t *objspace)
 {
+    if (objspace->profile.total_allocated_objects_at_gc_start > objspace->profile.total_freed_objects)
+        objspace->profile.live_after_last_sweep =
+            objspace->profile.total_allocated_objects_at_gc_start - objspace->profile.total_freed_objects;
+
     if (gc_prof_enabled(objspace)) {
 	gc_profile_record *record = gc_prof_record(objspace);
-	size_t live = objspace->profile.total_allocated_objects_at_gc_start - objspace->profile.total_freed_objects;
+        size_t live = objspace->profile.live_after_last_sweep;
 	size_t total = objspace->profile.heap_used_at_gc_start * HEAP_PAGE_OBJ_LIMIT;
 
 #if GC_PROFILE_MORE_DETAIL
diff -Nuarp ruby-2.7.6.a/gc.rb ruby-2.7.6.b/gc.rb
--- ruby-2.7.6.a/gc.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/gc.rb	2022-11-08 10:29:53.966092600 -0500
@@ -158,6 +158,92 @@ module GC
   def self.compact
     __builtin_rb_gc_compact
   end
+
+  # call-seq:
+  #    GC.enable_stats	  => true or false
+  #
+  # Enables garbage collection statistics, returning <code>true</code> if garbage
+  # collection statistics was already enabled.
+  #
+  #    GC.enable_stats	 #=> false or true
+  #    GC.enable_stats	 #=> true
+  def self.enable_stats
+    __builtin_gc_enable_stats
+  end
+
+  #   call-seq:
+  #    GC.disable_stats	   => true or false
+  #
+  # Disables garbage collection statistics, returning <code>true</code> if garbage
+  # collection statistics was already disabled.
+  #
+  #    GC.disable_stats	  #=> false or true
+  #    GC.disable_stats	  #=> true
+  def self.disable_stats
+    __builtin_gc_disable_stats
+  end
+
+  # call-seq:
+  #    GC.stats_enabled?    => true or false
+  #
+  # Check whether GC stats have been enabled.
+  #
+  #    GC.stats_enabled?   #=> false or true
+  def self.stats_enabled?
+    __builtin_gc_stats_enabled
+  end
+
+  #   call-seq:
+  #    GC.time	  => Integer
+  #
+  # Returns the time spent during garbage collection while GC statistics collection
+  # was enabled (in micro seconds).
+  #
+  #    GC.time	  #=> 20000
+  def self.time
+    __builtin_gc_time
+  end
+
+  #  call-seq:
+  #	GC.heap_slots	=> Integer
+  #
+  #  Returns the number of heap slots available for object allocations.
+  #
+  #	GC.heap_slots	#=> 10000
+  def self.heap_slots
+    __builtin_gc_heap_slots
+  end
+
+  # call-seq:
+  #    GC.heap_slots_live_after_last_gc	   => Integer
+  #
+  # Returns the number of heap slots which were live after the last garbage collection.
+  #
+  #    GC.heap_slots_live_after_last_gc	   #=> 231223
+  def self.heap_slots_live_after_last_gc
+    __builtin_gc_heap_slots_live_after_last_gc
+  end
+
+  #   call-seq:
+  #	 GC.total_mallocs	   => Integer
+  #
+  #   Returns the number malloc calls. Might wrap around.
+  #
+  #	 GC.total_mallocs	   #=> 324234323246
+  def self.total_mallocs
+    __builtin_gc_total_mallocs
+  end
+
+  #   call-seq:
+  #	 GC.total_malloced_bytes	   => Integer
+  #
+  #   Returns the number of bytes allocated. Might wrap around.
+  #
+  #	 GC.total_malloced_bytes	   #=> 354656256432446
+  def self.total_malloced_bytes
+    __builtin_gc_total_malloced_bytes
+  end
+
 end
 
 module ObjectSpace
diff -Nuarp ruby-2.7.6.a/gc.rbinc ruby-2.7.6.b/gc.rbinc
--- ruby-2.7.6.a/gc.rbinc	2022-04-12 07:25:50.000000000 -0400
+++ ruby-2.7.6.b/gc.rbinc	2022-11-08 10:30:08.028463100 -0500
@@ -17,6 +17,14 @@ static void load_gc(void)
     RB_BUILTIN_FUNCTION(6, gc_stat, gc_stat, 1),
     RB_BUILTIN_FUNCTION(7, gc_latest_gc_info, gc_latest_gc_info, 1),
     RB_BUILTIN_FUNCTION(8, rb_gc_compact, rb_gc_compact, 0),
+    RB_BUILTIN_FUNCTION(9, gc_enable_stats, gc_enable_stats, 0),
+    RB_BUILTIN_FUNCTION(10, gc_disable_stats, gc_disable_stats, 0),
+    RB_BUILTIN_FUNCTION(11, gc_stats_enabled, gc_stats_enabled, 0),
+    RB_BUILTIN_FUNCTION(12, gc_time, gc_time, 0),
+    RB_BUILTIN_FUNCTION(13, gc_heap_slots, gc_heap_slots, 0),
+    RB_BUILTIN_FUNCTION(14, gc_heap_slots_live_after_last_gc, gc_heap_slots_live_after_last_gc, 0),
+    RB_BUILTIN_FUNCTION(15, gc_total_mallocs, gc_total_mallocs, 0),
+    RB_BUILTIN_FUNCTION(16, gc_total_malloced_bytes, gc_total_malloced_bytes, 0),
     RB_BUILTIN_FUNCTION(-1, NULL, NULL, 0),
   };
 
@@ -34,6 +42,14 @@ COMPILER_WARNING_ERROR(-Wincompatible-po
   if (0) rb_builtin_function_check_arity1(gc_stat);
   if (0) rb_builtin_function_check_arity1(gc_latest_gc_info);
   if (0) rb_builtin_function_check_arity0(rb_gc_compact);
+  if (0) rb_builtin_function_check_arity0(gc_enable_stats);
+  if (0) rb_builtin_function_check_arity0(gc_disable_stats);
+  if (0) rb_builtin_function_check_arity0(gc_stats_enabled);
+  if (0) rb_builtin_function_check_arity0(gc_time);
+  if (0) rb_builtin_function_check_arity0(gc_heap_slots);
+  if (0) rb_builtin_function_check_arity0(gc_heap_slots_live_after_last_gc);
+  if (0) rb_builtin_function_check_arity0(gc_total_mallocs);
+  if (0) rb_builtin_function_check_arity0(gc_total_malloced_bytes);
 COMPILER_WARNING_POP
 
   // load
diff -Nuarp ruby-2.7.6.a/include/ruby/intern.h ruby-2.7.6.b/include/ruby/intern.h
--- ruby-2.7.6.a/include/ruby/intern.h	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/include/ruby/intern.h	2022-11-08 10:29:53.980666500 -0500
@@ -544,6 +544,9 @@ void rb_gc(void);
 void rb_gc_copy_finalizer(VALUE,VALUE);
 VALUE rb_gc_enable(void);
 VALUE rb_gc_disable(void);
+VALUE rb_gc_enable_stats(void);
+VALUE rb_gc_disable_stats(void);
+VALUE rb_gc_stats_enabled(void);
 VALUE rb_gc_start(void);
 VALUE rb_define_finalizer(VALUE, VALUE);
 VALUE rb_undefine_finalizer(VALUE);
@@ -551,6 +554,11 @@ size_t rb_gc_count(void);
 size_t rb_gc_stat(VALUE);
 VALUE rb_gc_latest_gc_info(VALUE);
 void rb_gc_adjust_memory_usage(ssize_t);
+double rb_gc_total_time(void);
+VALUE rb_gc_heap_slots(void);
+VALUE rb_gc_heap_slots_live_after_last_gc(void);
+size_t rb_gc_total_mallocs(void);
+size_t rb_gc_total_malloced_bytes(void);
 /* hash.c */
 void rb_st_foreach_safe(struct st_table *, int (*)(st_data_t, st_data_t, st_data_t), st_data_t);
 #define st_foreach_safe rb_st_foreach_safe
diff -Nuarp ruby-2.7.6.a/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb ruby-2.7.6.b/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb
--- ruby-2.7.6.a/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/lib/bundler/vendor/net-http-persistent/lib/net/http/persistent.rb	2022-11-08 10:29:34.563605600 -0500
@@ -197,10 +197,10 @@ class Bundler::Persistent::Net::HTTP::Pe
   ##
   # The default connection pool size is 1/4 the allowed open files.
 
-  if Gem.win_platform? then
-    DEFAULT_POOL_SIZE = 256
-  else
+  if Process.const_defined? :RLIMIT_NOFILE
     DEFAULT_POOL_SIZE = Process.getrlimit(Process::RLIMIT_NOFILE).first / 4
+  else
+    DEFAULT_POOL_SIZE = 256
   end
 
   ##
diff -Nuarp ruby-2.7.6.a/lib/mkmf.rb ruby-2.7.6.b/lib/mkmf.rb
--- ruby-2.7.6.a/lib/mkmf.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/lib/mkmf.rb	2022-11-08 10:29:25.226215400 -0500
@@ -1930,7 +1930,7 @@ SRC
 SHELL = /bin/sh
 
 # V=0 quiet, V=1 verbose.  other values don't work.
-V = 0
+V = 1
 Q1 = $(V:1=)
 Q = $(Q1:0=@)
 ECHO1 = $(V:1=@ #{CONFIG['NULLCMD']})
diff -Nuarp ruby-2.7.6.a/lib/rdoc/ri/paths.rb ruby-2.7.6.b/lib/rdoc/ri/paths.rb
--- ruby-2.7.6.a/lib/rdoc/ri/paths.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/lib/rdoc/ri/paths.rb	2022-11-08 10:29:09.885743900 -0500
@@ -10,7 +10,7 @@ module RDoc::RI::Paths
   #:stopdoc:
   require 'rbconfig'
 
-  version = RbConfig::CONFIG['ruby_version']
+  version = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
 
   BASE    = if RbConfig::CONFIG.key? 'ridir' then
               File.join RbConfig::CONFIG['ridir'], version
diff -Nuarp ruby-2.7.6.a/lib/rubygems/defaults.rb ruby-2.7.6.b/lib/rubygems/defaults.rb
--- ruby-2.7.6.a/lib/rubygems/defaults.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/lib/rubygems/defaults.rb	2022-11-08 10:29:09.902733700 -0500
@@ -32,13 +32,13 @@ module Gem
              [
                File.dirname(RbConfig::CONFIG['sitedir']),
                'Gems',
-               RbConfig::CONFIG['ruby_version']
+               RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
              ]
            else
              [
                RbConfig::CONFIG['rubylibprefix'],
                'gems',
-               RbConfig::CONFIG['ruby_version']
+               RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
              ]
            end
 
@@ -75,7 +75,8 @@ module Gem
 
   def self.user_dir
     parts = [Gem.user_home, '.gem', ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    ruby_version_dir_name = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
+    parts << ruby_version_dir_name unless ruby_version_dir_name.empty?
     File.join parts
   end
 
@@ -158,7 +159,7 @@ module Gem
     return nil unless RbConfig::CONFIG.key? 'vendordir'
 
     File.join RbConfig::CONFIG['vendordir'], 'gems',
-              RbConfig::CONFIG['ruby_version']
+              RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
   end
 
   ##
diff -Nuarp ruby-2.7.6.a/loadpath.c ruby-2.7.6.b/loadpath.c
--- ruby-2.7.6.a/loadpath.c	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/loadpath.c	2022-11-08 10:29:21.740001400 -0500
@@ -65,22 +65,38 @@ const char ruby_initial_load_paths[] =
     RUBY_SEARCH_PATH "\0"
 #endif
 #ifndef NO_RUBY_SITE_LIB
+#ifdef RUBY_LIB_VERSION_BLANK
+    RUBY_SITE_LIB "\0"
+#else
     RUBY_SITE_LIB2 "\0"
+#endif
 #ifdef RUBY_THINARCH
     RUBY_SITE_ARCH_LIB_FOR(RUBY_THINARCH) "\0"
 #endif
     RUBY_SITE_ARCH_LIB_FOR(RUBY_SITEARCH) "\0"
+#ifndef RUBY_LIB_VERSION_BLANK
     RUBY_SITE_LIB "\0"
 #endif
+#endif
 
 #ifndef NO_RUBY_VENDOR_LIB
+#ifdef RUBY_LIB_VERSION_BLANK
+    RUBY_VENDOR_LIB "\0"
+#else
     RUBY_VENDOR_LIB2 "\0"
+#endif
 #ifdef RUBY_THINARCH
     RUBY_VENDOR_ARCH_LIB_FOR(RUBY_THINARCH) "\0"
 #endif
     RUBY_VENDOR_ARCH_LIB_FOR(RUBY_SITEARCH) "\0"
+#ifndef RUBY_LIB_VERSION_BLANK
     RUBY_VENDOR_LIB "\0"
 #endif
+#endif
+
+#ifdef RUBYGEMS_DIR
+    RUBYGEMS_DIR "\0"
+#endif
 
     RUBY_LIB "\0"
 #ifdef RUBY_THINARCH
diff -Nuarp ruby-2.7.6.a/miniprelude.c ruby-2.7.6.b/miniprelude.c
--- ruby-2.7.6.a/miniprelude.c	2022-04-12 07:25:50.000000000 -0400
+++ ruby-2.7.6.b/miniprelude.c	2022-11-08 10:30:04.910851300 -0500
@@ -167,8 +167,9 @@ static const struct {
 static const char prelude_name1[] = "<internal:gc>";
 static const struct {
     char L0[506]; /* 1..71 */
-    char L71[463]; /* 72..163 */
-    char L163[204]; /* 164..170 */
+    char L71[508]; /* 72..172 */
+    char L172[503]; /* 173..244 */
+    char L244[235]; /* 245..256 */
 } prelude_code1 = {
 #line 1 "gc.rb"
 "\n"/* for gc.c */
@@ -333,18 +334,106 @@ static const struct {
 "  def self.compact\n"
 "    __builtin_rb_gc_compact\n"
 "  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.enable_stats\011  => true or false */
+"\n"/*  */
+"\n"/* Enables garbage collection statistics, returning <code>true</code> if garbage */
+"\n"/* collection statistics was already enabled. */
+"\n"/*  */
+"\n"/*    GC.enable_stats\011 #=> false or true */
+"\n"/*    GC.enable_stats\011 #=> true */
+"  def self.enable_stats\n"
+"    __builtin_gc_enable_stats\n"
+"  end\n"
+,
+#line 173 "gc.rb"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*    GC.disable_stats\011   => true or false */
+"\n"/*  */
+"\n"/* Disables garbage collection statistics, returning <code>true</code> if garbage */
+"\n"/* collection statistics was already disabled. */
+"\n"/*  */
+"\n"/*    GC.disable_stats\011  #=> false or true */
+"\n"/*    GC.disable_stats\011  #=> true */
+"  def self.disable_stats\n"
+"    __builtin_gc_disable_stats\n"
+"  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.stats_enabled?    => true or false */
+"\n"/*  */
+"\n"/* Check whether GC stats have been enabled. */
+"\n"/*  */
+"\n"/*    GC.stats_enabled?   #=> false or true */
+"  def self.stats_enabled?\n"
+"    __builtin_gc_stats_enabled\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*    GC.time\011  => Integer */
+"\n"/*  */
+"\n"/* Returns the time spent during garbage collection while GC statistics collection */
+"\n"/* was enabled (in micro seconds). */
+"\n"/*  */
+"\n"/*    GC.time\011  #=> 20000 */
+"  def self.time\n"
+"    __builtin_gc_time\n"
+"  end\n"
+"\n"
+"\n"/*  call-seq: */
+"\n"/* GC.heap_slots\011=> Integer */
+"\n"/*  */
+"\n"/*  Returns the number of heap slots available for object allocations. */
+"\n"/*  */
+"\n"/* GC.heap_slots\011#=> 10000 */
+"  def self.heap_slots\n"
+"    __builtin_gc_heap_slots\n"
+"  end\n"
+"\n"
+"\n"/* call-seq: */
+"\n"/*    GC.heap_slots_live_after_last_gc\011   => Integer */
+"\n"/*  */
+"\n"/* Returns the number of heap slots which were live after the last garbage collection. */
+"\n"/*  */
+"\n"/*    GC.heap_slots_live_after_last_gc\011   #=> 231223 */
+"  def self.heap_slots_live_after_last_gc\n"
+"    __builtin_gc_heap_slots_live_after_last_gc\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*  GC.total_mallocs\011   => Integer */
+"\n"/*  */
+"\n"/*   Returns the number malloc calls. Might wrap around. */
+"\n"/*  */
+"\n"/*  GC.total_mallocs\011   #=> 324234323246 */
+"  def self.total_mallocs\n"
+"    __builtin_gc_total_mallocs\n"
+"  end\n"
+"\n"
+"\n"/*   call-seq: */
+"\n"/*  GC.total_malloced_bytes\011   => Integer */
+"\n"/*  */
+"\n"/*   Returns the number of bytes allocated. Might wrap around. */
+"\n"/*  */
+"\n"/*  GC.total_malloced_bytes\011   #=> 354656256432446 */
+"  def self.total_malloced_bytes\n"
+"    __builtin_gc_total_malloced_bytes\n"
+,
+#line 245 "gc.rb"
+"  end\n"
+"\n"
 "end\n"
 "\n"
 "module ObjectSpace\n"
-,
-#line 164 "gc.rb"
 "  def garbage_collect full_mark: true, immediate_mark: true, immediate_sweep: true\n"
 "    __builtin_gc_start_internal full_mark, immediate_mark, immediate_sweep\n"
 "  end\n"
 "\n"
 "  module_function :garbage_collect\n"
 "end\n"
-#line 348 "miniprelude.c"
+#line 437 "miniprelude.c"
 };
 
 static const char prelude_name2[] = "<internal:io>";
@@ -475,7 +564,7 @@ static const struct {
 "    __builtin_io_write_nonblock(buf, exception)\n"
 "  end\n"
 "end\n"
-#line 479 "miniprelude.c"
+#line 568 "miniprelude.c"
 };
 
 static const char prelude_name3[] = "<internal:pack>";
@@ -766,7 +855,7 @@ static const struct {
 "    __builtin_pack_unpack1(fmt)\n"
 "  end\n"
 "end\n"
-#line 770 "miniprelude.c"
+#line 859 "miniprelude.c"
 };
 
 static const char prelude_name4[] = "<internal:trace_point>";
@@ -1131,7 +1220,7 @@ static const struct {
 "    __builtin_tracepoint_attr_instruction_sequence\n"
 "  end\n"
 "end\n"
-#line 1135 "miniprelude.c"
+#line 1224 "miniprelude.c"
 };
 
 static const char prelude_name5[] = "<internal:warning>";
@@ -1184,7 +1273,7 @@ static const struct {
 "    __builtin_rb_warn_m(msgs, uplevel)\n"
 "  end\n"
 "end\n"
-#line 1188 "miniprelude.c"
+#line 1277 "miniprelude.c"
 };
 
 static const char prelude_name6[] = "<internal:prelude>";
@@ -1229,7 +1318,7 @@ static const struct {
 "\n"
 "  private :pp\n"
 "end\n"
-#line 1233 "miniprelude.c"
+#line 1322 "miniprelude.c"
 };
 
 static const char prelude_name7[] = "<internal:gem_prelude>";
@@ -1239,7 +1328,7 @@ static const struct {
 #line 1 "gem_prelude.rb"
 "require 'rubygems.rb' if defined?(Gem)\n"
 "require 'did_you_mean' if defined?(DidYouMean)\n"
-#line 1243 "miniprelude.c"
+#line 1332 "miniprelude.c"
 };
 
 #define PRELUDE_NAME(n) rb_usascii_str_new_static(prelude_name##n, sizeof(prelude_name##n)-1)
diff -Nuarp ruby-2.7.6.a/ruby.c ruby-2.7.6.b/ruby.c
--- ruby-2.7.6.a/ruby.c	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/ruby.c	2022-11-08 10:29:28.502599400 -0500
@@ -1451,10 +1451,14 @@ proc_options(long argc, char **argv, rub
 
 void Init_builtin_features(void);
 
+/* abrt.c */
+void Init_abrt(void);
+
 static void
 ruby_init_prelude(void)
 {
     Init_builtin_features();
+    Init_abrt();
     rb_const_remove(rb_cObject, rb_intern_const("TMP_RUBY_PREFIX"));
 }
 
diff -Nuarp ruby-2.7.6.a/spec/ruby/core/process/groups_spec.rb ruby-2.7.6.b/spec/ruby/core/process/groups_spec.rb
--- ruby-2.7.6.a/spec/ruby/core/process/groups_spec.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/spec/ruby/core/process/groups_spec.rb	2022-11-08 10:29:50.773170400 -0500
@@ -2,13 +2,15 @@ require_relative '../../spec_helper'
 
 describe "Process.groups" do
   platform_is_not :windows do
-    it "gets an Array of the gids of groups in the supplemental group access list" do
-      groups = `id -G`.scan(/\d+/).map { |i| i.to_i }
-      gid = Process.gid
+    guard -> { return ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP'] != "1" } do
+      it "gets an Array of the gids of groups in the supplemental group access list" do
+        groups = `id -G`.scan(/\d+/).map { |i| i.to_i }
+        gid = Process.gid
 
-      expected = (groups.sort - [gid]).uniq.sort
-      actual = (Process.groups - [gid]).uniq.sort
-      actual.should == expected
+        expected = (groups.sort - [gid]).uniq.sort
+        actual = (Process.groups - [gid]).uniq.sort
+        actual.should == expected
+      end
     end
   end
 end
diff -Nuarp ruby-2.7.6.a/spec/ruby/library/etc/getgrgid_spec.rb ruby-2.7.6.b/spec/ruby/library/etc/getgrgid_spec.rb
--- ruby-2.7.6.a/spec/ruby/library/etc/getgrgid_spec.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/spec/ruby/library/etc/getgrgid_spec.rb	2022-11-08 10:29:50.781991300 -0500
@@ -15,6 +15,7 @@ end
 platform_is_not :windows do
   grpname = nil
   guard -> {
+    return false if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     grpname = IO.popen(%w'id -gn', err: IO::NULL, &:read).chomp
     $?.success?
   } do
diff -Nuarp ruby-2.7.6.a/spec/ruby/library/etc/struct_group_spec.rb ruby-2.7.6.b/spec/ruby/library/etc/struct_group_spec.rb
--- ruby-2.7.6.a/spec/ruby/library/etc/struct_group_spec.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/spec/ruby/library/etc/struct_group_spec.rb	2022-11-08 10:29:50.791161300 -0500
@@ -3,6 +3,8 @@ require 'etc'
 
 describe "Struct::Group" do
   platform_is_not :windows do
+    next if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
+
     grpname = IO.popen(%w'id -gn', err: IO::NULL, &:read)
     next unless $?.success?
     grpname.chomp!
diff -Nuarp ruby-2.7.6.a/template/ruby.pc.in ruby-2.7.6.b/template/ruby.pc.in
--- ruby-2.7.6.a/template/ruby.pc.in	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/template/ruby.pc.in	2022-11-08 10:29:09.873920600 -0500
@@ -9,6 +9,7 @@ MAJOR=@MAJOR@
 MINOR=@MINOR@
 TEENY=@TEENY@
 ruby_version=@ruby_version@
+ruby_version_dir_name=@ruby_version_dir_name@
 RUBY_API_VERSION=@RUBY_API_VERSION@
 RUBY_PROGRAM_VERSION=@RUBY_PROGRAM_VERSION@
 RUBY_BASE_NAME=@RUBY_BASE_NAME@
diff -Nuarp ruby-2.7.6.a/template/verconf.h.tmpl ruby-2.7.6.b/template/verconf.h.tmpl
--- ruby-2.7.6.a/template/verconf.h.tmpl	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/template/verconf.h.tmpl	2022-11-08 10:29:21.747493200 -0500
@@ -36,6 +36,9 @@
 % if C["RUBY_SEARCH_PATH"]
 #define RUBY_SEARCH_PATH		"${RUBY_SEARCH_PATH}"
 % end
+% if C["rubygemsdir"]
+#define RUBYGEMS_DIR			"${rubygemsdir}"
+% end
 %
 % R = {}
 % R["ruby_version"] = '"RUBY_LIB_VERSION"'
diff -Nuarp ruby-2.7.6.a/test/-ext-/bug_reporter/test_bug_reporter.rb ruby-2.7.6.b/test/-ext-/bug_reporter/test_bug_reporter.rb
--- ruby-2.7.6.a/test/-ext-/bug_reporter/test_bug_reporter.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/test/-ext-/bug_reporter/test_bug_reporter.rb	2022-11-08 10:29:44.047873800 -0500
@@ -19,7 +19,7 @@ class TestBugReporter < Test::Unit::Test
     args = ["--disable-gems", "-r-test-/bug_reporter",
             "-C", tmpdir]
     stdin = "register_sample_bug_reporter(12345); Process.kill :SEGV, $$"
-    assert_in_out_err(args, stdin, [], expected_stderr, encoding: "ASCII-8BIT")
+    assert_in_out_err(args, stdin, [], expected_stderr, encoding: "ASCII-8BIT", timeout_error: nil)
   ensure
     FileUtils.rm_rf(tmpdir) if tmpdir
   end
diff -Nuarp ruby-2.7.6.a/test/fiddle/helper.rb ruby-2.7.6.b/test/fiddle/helper.rb
--- ruby-2.7.6.a/test/fiddle/helper.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/test/fiddle/helper.rb	2022-11-08 10:29:31.331555900 -0500
@@ -6,115 +6,6 @@ require 'fiddle'
 
 libc_so = libm_so = nil
 
-case RUBY_PLATFORM
-when /cygwin/
-  libc_so = "cygwin1.dll"
-  libm_so = "cygwin1.dll"
-when /android/
-  libdir = '/system/lib'
-  if [0].pack('L!').size == 8
-    libdir = '/system/lib64'
-  end
-  libc_so = File.join(libdir, "libc.so")
-  libm_so = File.join(libdir, "libm.so")
-when /linux/
-  libdir = '/lib'
-  case RbConfig::SIZEOF['void*']
-  when 4
-    # 32-bit ruby
-    case RUBY_PLATFORM
-    when /armv\w+-linux/
-      # In the ARM 32-bit libc package such as libc6:armhf libc6:armel,
-      # libc.so and libm.so are installed to /lib/arm-linux-gnu*.
-      # It's not installed to /lib32.
-      dirs = Dir.glob('/lib/arm-linux-gnu*')
-      libdir = dirs[0] if dirs && File.directory?(dirs[0])
-    else
-      libdir = '/lib32' if File.directory? '/lib32'
-    end
-  when 8
-    # 64-bit ruby
-    libdir = '/lib64' if File.directory? '/lib64'
-  end
-  libc_so = File.join(libdir, "libc.so.6")
-  libm_so = File.join(libdir, "libm.so.6")
-when /mingw/, /mswin/
-  require "rbconfig"
-  crtname = RbConfig::CONFIG["RUBY_SO_NAME"][/msvc\w+/] || 'ucrtbase'
-  libc_so = libm_so = "#{crtname}.dll"
-when /darwin/
-  libc_so = libm_so = "/usr/lib/libSystem.B.dylib"
-when /kfreebsd/
-  libc_so = "/lib/libc.so.0.1"
-  libm_so = "/lib/libm.so.1"
-when /gnu/	#GNU/Hurd
-  libc_so = "/lib/libc.so.0.3"
-  libm_so = "/lib/libm.so.6"
-when /mirbsd/
-  libc_so = "/usr/lib/libc.so.41.10"
-  libm_so = "/usr/lib/libm.so.7.0"
-when /freebsd/
-  libc_so = "/lib/libc.so.7"
-  libm_so = "/lib/libm.so.5"
-when /bsd|dragonfly/
-  libc_so = "/usr/lib/libc.so"
-  libm_so = "/usr/lib/libm.so"
-when /solaris/
-  libdir = '/lib'
-  case RbConfig::SIZEOF['void*']
-  when 4
-    # 32-bit ruby
-    libdir = '/lib' if File.directory? '/lib'
-  when 8
-    # 64-bit ruby
-    libdir = '/lib/64' if File.directory? '/lib/64'
-  end
-  libc_so = File.join(libdir, "libc.so")
-  libm_so = File.join(libdir, "libm.so")
-when /aix/
-  pwd=Dir.pwd
-  libc_so = libm_so = "#{pwd}/libaixdltest.so"
-  unless File.exist? libc_so
-    cobjs=%w!strcpy.o!
-    mobjs=%w!floats.o sin.o!
-    funcs=%w!sin sinf strcpy strncpy!
-    expfile='dltest.exp'
-    require 'tmpdir'
-    Dir.mktmpdir do |dir|
-      begin
-        Dir.chdir dir
-        %x!/usr/bin/ar x /usr/lib/libc.a #{cobjs.join(' ')}!
-        %x!/usr/bin/ar x /usr/lib/libm.a #{mobjs.join(' ')}!
-        %x!echo "#{funcs.join("\n")}\n" > #{expfile}!
-        require 'rbconfig'
-        if RbConfig::CONFIG["GCC"] = 'yes'
-          lflag='-Wl,'
-        else
-          lflag=''
-        end
-        flags="#{lflag}-bE:#{expfile} #{lflag}-bnoentry -lm"
-        %x!#{RbConfig::CONFIG["LDSHARED"]} -o #{libc_so} #{(cobjs+mobjs).join(' ')} #{flags}!
-      ensure
-        Dir.chdir pwd
-      end
-    end
-  end
-else
-  libc_so = ARGV[0] if ARGV[0] && ARGV[0][0] == ?/
-  libm_so = ARGV[1] if ARGV[1] && ARGV[1][0] == ?/
-  if( !(libc_so && libm_so) )
-    $stderr.puts("libc and libm not found: #{$0} <libc> <libm>")
-  end
-end
-
-libc_so = nil if !libc_so || (libc_so[0] == ?/ && !File.file?(libc_so))
-libm_so = nil if !libm_so || (libm_so[0] == ?/ && !File.file?(libm_so))
-
-# macOS 11.0+ removed libSystem.B.dylib from /usr/lib. But It works with dlopen.
-if RUBY_PLATFORM =~ /darwin/
-  libc_so = libm_so = "/usr/lib/libSystem.B.dylib"
-end
-
 if !libc_so || !libm_so
   ruby = EnvUtil.rubybin
   # When the ruby binary is 32-bit and the host is 64-bit,
diff -Nuarp ruby-2.7.6.a/test/ruby/test_process.rb ruby-2.7.6.b/test/ruby/test_process.rb
--- ruby-2.7.6.a/test/ruby/test_process.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/test/ruby/test_process.rb	2022-11-08 10:29:50.807094500 -0500
@@ -1561,6 +1561,7 @@ class TestProcess < Test::Unit::TestCase
   end
 
   def test_maxgroups
+    skip "Broken groups on my AD enabled machine" if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     max = Process.maxgroups
   rescue NotImplementedError
   else
@@ -1915,6 +1916,7 @@ class TestProcess < Test::Unit::TestCase
   def test_execopts_gid
     skip "Process.groups not implemented on Windows platform" if windows?
     skip "root can use Process.groups on Android platform" if RUBY_PLATFORM =~ /android/
+    skip "Broken groups on my AD enabled machine" if ENV['RUBY_TEST_OPTIONS_BROKEN_GROUP']
     feature6975 = '[ruby-core:47414]'
 
     groups = Process.groups.map do |g|
diff -Nuarp ruby-2.7.6.a/test/rubygems/test_gem.rb ruby-2.7.6.b/test/rubygems/test_gem.rb
--- ruby-2.7.6.a/test/rubygems/test_gem.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/test/rubygems/test_gem.rb	2022-11-08 10:29:09.911639200 -0500
@@ -1378,7 +1378,8 @@ class TestGem < Gem::TestCase
 
   def test_self_user_dir
     parts = [@userhome, '.gem', Gem.ruby_engine]
-    parts << RbConfig::CONFIG['ruby_version'] unless RbConfig::CONFIG['ruby_version'].empty?
+    ruby_version_dir_name = RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
+    parts << ruby_version_dir_name unless ruby_version_dir_name.empty?
 
     assert_equal File.join(parts), Gem.user_dir
   end
@@ -1454,7 +1455,7 @@ class TestGem < Gem::TestCase
     vendordir(File.join(@tempdir, 'vendor')) do
       expected =
         File.join RbConfig::CONFIG['vendordir'], 'gems',
-                  RbConfig::CONFIG['ruby_version']
+                  RbConfig::CONFIG['ruby_version_dir_name'] || RbConfig::CONFIG['ruby_version']
 
       assert_equal expected, Gem.vendor_dir
     end
diff -Nuarp ruby-2.7.6.a/tool/mkconfig.rb ruby-2.7.6.b/tool/mkconfig.rb
--- ruby-2.7.6.a/tool/mkconfig.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/tool/mkconfig.rb	2022-11-08 10:29:12.876509900 -0500
@@ -114,7 +114,7 @@ File.foreach "config.status" do |line|
     val = val.gsub(/\$(?:\$|\{?(\w+)\}?)/) {$1 ? "$(#{$1})" : $&}.dump
     case name
     when /^prefix$/
-      val = "(TOPDIR || DESTDIR + #{val})"
+      val = "(((TOPDIR && TOPDIR.empty?) ? nil : TOPDIR) || DESTDIR + #{val})"
     when /^ARCH_FLAG$/
       val = "arch_flag || #{val}" if universal
     when /^UNIVERSAL_ARCHNAMES$/
diff -Nuarp ruby-2.7.6.a/tool/rbinstall.rb ruby-2.7.6.b/tool/rbinstall.rb
--- ruby-2.7.6.a/tool/rbinstall.rb	2022-04-12 07:25:48.000000000 -0400
+++ ruby-2.7.6.b/tool/rbinstall.rb	2022-11-08 10:29:21.760166100 -0500
@@ -343,6 +343,7 @@ if CONFIG["vendordir"]
   vendorlibdir = CONFIG["vendorlibdir"]
   vendorarchlibdir = CONFIG["vendorarchdir"]
 end
+rubygemsdir = CONFIG["rubygemsdir"]
 mandir = CONFIG["mandir", true]
 docdir = CONFIG["docdir", true]
 enable_shared = CONFIG["ENABLE_SHARED"] == 'yes'
@@ -433,7 +434,7 @@ end
 
 install?(:doc, :rdoc) do
   if $rdocdir
-    ridatadir = File.join(CONFIG['ridir'], CONFIG['ruby_version'], "system")
+    ridatadir = File.join(CONFIG['ridir'], CONFIG['ruby_version_dir_name'] || CONFIG['ruby_version'], "system")
     prepare "rdoc", ridatadir
     install_recursive($rdocdir, ridatadir, :no_install => rdoc_noinst, :mode => $data_mode)
   end
@@ -570,7 +571,16 @@ end
 install?(:local, :comm, :lib) do
   prepare "library scripts", rubylibdir
   noinst = %w[*.txt *.rdoc *.gemspec]
+  # Bundler carries "rubygems.rb" file, so it must be specialcased :/
+  noinst += %w[rubygems.rb rubygems/ bundler.rb bundler/] if rubygemsdir
   install_recursive(File.join(srcdir, "lib"), rubylibdir, :no_install => noinst, :mode => $data_mode)
+  if rubygemsdir
+    noinst = %w[*.txt *.rdoc *.gemspec]
+    install_recursive(File.join(srcdir, "lib", "rubygems"), File.join(rubygemsdir, "rubygems"), :no_install => noinst, :mode => $data_mode)
+    install(File.join(srcdir, "lib", "rubygems.rb"), File.join(rubygemsdir, "rubygems.rb"), :mode => $data_mode)
+    install_recursive(File.join(srcdir, "lib", "bundler"), File.join(rubylibdir, "bundler"), :no_install => noinst, :mode => $data_mode)
+    install(File.join(srcdir, "lib", "bundler.rb"), rubylibdir, :mode => $data_mode)
+  end
 end
 
 install?(:local, :comm, :hdr, :'comm-hdr') do
